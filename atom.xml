<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EddieLee</title>
  
  <subtitle>to infinity and beyond✨🛸.</subtitle>
  <link href="https://soincredible.github.io/atom.xml" rel="self"/>
  
  <link href="https://soincredible.github.io/"/>
  <updated>2025-06-25T09:08:42.252Z</updated>
  <id>https://soincredible.github.io/</id>
  
  <author>
    <name>Eddie Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码热更新合集</title>
    <link href="https://soincredible.github.io/posts/99b1bffa/"/>
    <id>https://soincredible.github.io/posts/99b1bffa/</id>
    <published>2025-06-23T11:07:40.000Z</published>
    <updated>2025-06-25T09:08:42.252Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>HybridCLR相关</title>
    <link href="https://soincredible.github.io/posts/20505312/"/>
    <id>https://soincredible.github.io/posts/20505312/</id>
    <published>2025-06-22T00:31:38.000Z</published>
    <updated>2025-06-25T08:18:27.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《CLR via C#》这本书帮助读者建立起了C#的知识框架, 是笔者职业生涯中功不可没的好书, 不过本书的作者Jeffrey Richter是以.Net Framework框架在Windows平台进行开发的视角上介绍.Net的一些特性的, 而笔者作为一个Unity入门C#的半吊子在最初阅读本书的很长一段时间内是没有真正理解.Net的核心特性的. 在本篇博客中, 笔者尝试基于这本书, 加上笔者对Unity的理解, 站在Unity开发者的视角上, 诠释.Net中的一些关键性概念.</p></blockquote><h1 id="NET往事"><a href="#NET往事" class="headerlink" title=".NET往事"></a>.NET往事</h1><p>以在这本书里面并没有详细解释过.Net、.NetCore、.Net Standard、.Net Framework一系列的概念, 之所以有这么多的概念, 也是有历史原因的, 了解.Net的发言史能帮我们更好地理解这些概念、<br>.Net是.Net C#是C#, .Net是一套支持C#代码运行的框架体系, 除此之外.Net还支持F#、VB等语言 </p><p>.Net Framework、 .NetCore、 .Net这三者是对同一个对象在不同发展时期的不同称谓, 这一对象在不同发展时期具有不同的特点. </p><h2 id="Net-Framework是啥"><a href="#Net-Framework是啥" class="headerlink" title=".Net Framework是啥"></a>.Net Framework是啥</h2><p>此时的.Net只能够运行在Windows上</p><h2 id="Net-Core是啥"><a href="#Net-Core是啥" class="headerlink" title=".Net Core是啥"></a>.Net Core是啥</h2><p>.Net Core在原来.NetFramework的基础上, 增加了对于跨平台的支持</p><h2 id="Net-是啥"><a href="#Net-是啥" class="headerlink" title=".Net 是啥"></a>.Net 是啥</h2><p>经过一段时间的演变, .Net Core就变成了.Net</p><div class="table-container"><table><thead><tr><th>组件名称</th><th>作用</th><th>说明</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>CoreCLR / .NET Runtime</td><td>托管运行时/虚拟机，负责执行IL，中间语言JIT，GC</td><td><a href="https://github.com/dotnet/runtime（已开源）">https://github.com/dotnet/runtime（已开源）</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CoreFX / 基类库（Base Class Library, BCL）</td><td>常用系统API：IO、网络、集合、字符串等</td><td>现代叫runtime中的“libraries”</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ASP.NET Core</td><td>Web开发框架</td><td>支持Web服务器、API、MVC、Blazor、SignalR、gRPC等平台</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Entity Framework Core</td><td>对象关系映射（ORM）数据库组件</td><td>支持SQLServer、SQLite、MySQL等主流数据库</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>WinForms、WPF（Windows Only）</td><td>桌面GUI开发</td><td>.NET 5+支持基本移植，但仅限Windows</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MSBuild</td><td>构建系统</td><td>dotnet build 就是用的这个</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Roslyn</td><td>C#、VB.NET编译器和代码分析器</td><td><a href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>NuGet</td><td>包管理工具</td><td>在线/本地包管理</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CLI</td><td>命令行工具（dotnet）</td><td>包括dotnet、dotnet build、dotnet run等基础命令</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h2 id="Mono是啥"><a href="#Mono是啥" class="headerlink" title="Mono是啥"></a>Mono是啥</h2><p>Mono 项目始于 2001 年，由 Ximian 公司的创始人 Miguel de Icaza 领导。Ximian 是一家专注于 Linux 和开源软件的公司。Miguel de Icaza 的目标是创建一个.NET 框架的开源实现，以便在 Linux 上运行。</p><p>.NET 框架最初由微软开发，主要用于构建 Windows 应用程序。由于.NET 框架的闭源性，它无法直接在其他操作系统上运行。Mono 项目的出现打破了这一限制，使得.NET 开发者的代码能够在多种平台上运行。</p><p>随着时间的推移，Mono 项目得到了广泛的社区支持，并且不断发展和完善。它支持多种编程语言，包括 C#、Visual Basic.NET 和 F#，并且实现了许多.NET 框架的功能。Mono 项目在开源社区中的成功也促进了.NET 技术在非 Windows 平台上的普及。</p><p>还有就是.Net升级是.Net C# language升级是language<br>一般来说, 先是C#的语言有更新, 必须新增了某种语法或者语言特性 那么配套的.Net中就需要支持能够识别并驱动这些语法, 因此一般C#有新特性增加对应的.Net也有新的升级</p><p>说白了 .Net、.NetCore、.NetFramework、Mono每一个都是一套让C#代码能够运行跑起来的平台. 这就好比各家虚拟机平台, 而C#就像是你在微软官网上下载的Windows操作系统的镜像文件, 你可以将这个镜像文件挂载在VMWare平台上, 也可以挂载在Parallel Desktop平台上, 即便平台的底层实现不同, 但是因为它们都遵循同样的规范, 因此同样的一操作系统镜像文件可以跑在不同的虚拟机平台上, 这些平台遵循的规范, 类比到.Net中也就是<code>.Net Standard</code></p><h2 id="Net-Standard"><a href="#Net-Standard" class="headerlink" title=".Net Standard"></a>.Net Standard</h2><p>.Net Standard 是针对多个 .Net实现推出的一套正式的.Net API规范. 推出.NetStandard的背后动机是要提高.Net生态系统中的一致性. 但是 .Net5采用的不同的方法来建立一致性, 这种新方法在很多情况下都不需要使用到.Net Standard.</p><h2 id="Unity的发展史"><a href="#Unity的发展史" class="headerlink" title="Unity的发展史"></a>Unity的发展史</h2><h2 id="Unity何时引入的Mono"><a href="#Unity何时引入的Mono" class="headerlink" title="Unity何时引入的Mono"></a>Unity何时引入的Mono</h2><h1 id="C-代码是怎么跑起来的"><a href="#C-代码是怎么跑起来的" class="headerlink" title="C#代码是怎么跑起来的?"></a>C#代码是怎么跑起来的?</h1><p>在CLR via C#这本书中, 作者只提及了JIT Compiler这个概念, 笔者认为在一开始.Net可能就只支持JIT的方式执行C#代码, 而AOT和解释器方式则是跨平台的概念引入到.Net中后, 才出现的概念.</p><h2 id="AOT模式"><a href="#AOT模式" class="headerlink" title="AOT模式"></a>AOT模式</h2><p>我们就拿Unity开发举例子, 如果使用AOT的方式打包, 那么在打包阶段, 我们编写的C#代码就会全部被编译成机器码, 也就是.so文件, 这种代码就是原生的代码, 丢到机器上就就能立刻运行, 不需要编译, 但是机器码都是01, 存储效率低, 由我们的C#脚本转成机器码会造成代码膨胀, 听起来是不是很像IL2CPP?</p><h2 id="JIT模式"><a href="#JIT模式" class="headerlink" title="JIT模式"></a>JIT模式</h2><p>JIT方式打包, 在打包阶段, 我们编写的C#代码会被编译成IL, 打入一个.dll的文件, 这就是Mono的打包方式, 使用这种方式打的包, 包体小, 但是由于其代码不是原生的, 所以运行时需要依赖CLR将IL代码编译成原生代码执行, 比起AOT方式 在启动时间上会久一点, 因为需要编译, 但是只要编译了一次之后, 执行效率和AOT是没什么区别的</p><h2 id="Interpreter模式"><a href="#Interpreter模式" class="headerlink" title="Interpreter模式"></a>Interpreter模式</h2><p>解释器, 笔者第一次看到这个概念出现在C#中时, 是非常疑惑的, 因为笔者理解的解释器, 是像Python那种解释型语言才会使用到的东西, 而C#作为一个编译型语言, 其实C#并不是传统意义上的编译型语言, 因为C#是先编译成IL中间语言, 然后在运行时通过JITCompiler将中间语言编译成机器码执行的方式.</p><p>也就是, C#不解释型语言那样直接解释源代码执行, 也不像C++那样一次性把源代码编译成机器码执行.</p><p>解释器模式可以理解为是在Unity开发中代码热更新场景下, 业内开发者为了能够执行热更代码(dll)而开发的一种迷你版的CLR(虚拟机).<br>我再理解一下解释器的角色, 解释器就是在AOT打包方式下, 主包的.Net的虚拟机被剔除丧失了解析编译IL(dll)的能力, 需要一个迷你版的虚拟机(也就是解释器)来执行IL代码</p><h1 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h1><blockquote><p>C#和C++虽然都能生成DLL, 如果DLL的调用者是C#语言, 那么这两种DLL是有分别的: C#生成的DLL类型是托管类型的DLL, C++生成的DLL是非托管的(原生的)DLL, 前者的DLL导入到C#工程中编译器就能够自动的识别DLL中的成员类型, 后者生成的DLL导入到C#工程中则需要使用<code>[DLLImport]</code>Attribute来做一些额外的处理, 并且在C++侧也需要对于要在C#侧调用的方法签名上添加<code>extern &quot;C&quot;</code>标识</p></blockquote><h1 id="一个C-工程使用的-Net版本怎么看"><a href="#一个C-工程使用的-Net版本怎么看" class="headerlink" title="一个C#工程使用的.Net版本怎么看?"></a>一个C#工程使用的.Net版本怎么看?</h1><h1 id="一个C-工程使用的-Net版本怎么修改"><a href="#一个C-工程使用的-Net版本怎么修改" class="headerlink" title="一个C#工程使用的.Net版本怎么修改?"></a>一个C#工程使用的.Net版本怎么修改?</h1><h2 id="AOT-JIT"><a href="#AOT-JIT" class="headerlink" title="AOT JIT"></a>AOT JIT</h2><p>AOT和JIT是C#(当然别的基于CLR的语言也可以)代码运行的两种方式, AOT即Ahead of Time</p><ul><li>AOT Ahead of Time<br>什么是AOT?</li></ul><h1 id="代码热更新"><a href="#代码热更新" class="headerlink" title="代码热更新"></a>代码热更新</h1><h2 id="Lua、XLua"><a href="#Lua、XLua" class="headerlink" title="Lua、XLua"></a>Lua、XLua</h2><h2 id="ILRuntime"><a href="#ILRuntime" class="headerlink" title="ILRuntime"></a>ILRuntime</h2><h2 id="HybridCLR"><a href="#HybridCLR" class="headerlink" title="HybridCLR"></a>HybridCLR</h2><h2 id="sln-csproj-dll-asmdef的区别和联系"><a href="#sln-csproj-dll-asmdef的区别和联系" class="headerlink" title=".sln .csproj .dll .asmdef的区别和联系"></a>.sln .csproj .dll .asmdef的区别和联系</h2><p>.sln 是<br>.csproj 一个sln下会有多个csproj<br>.asmdef 这是Unity中的一个概念, 每创建一个asmdef, Unity都会自动生成这个asmdef对应的csproj<br>.dll dll一般有两种: 使用C#编译生成的dll, 这类dll属于托管类dll, 导入Unity能够直接被Unity编译器识别; 还有一类是使用c/c++等非托管类语言编译生成的dll, 这类dll需要C#具有能够调用原生(native)代码的能力, 需要使用<code>[DLLImport]</code>属性来导入方法</p><h1 id="JIT和解释器的区别是啥呢-不都是运行时编译代码嘛"><a href="#JIT和解释器的区别是啥呢-不都是运行时编译代码嘛" class="headerlink" title="JIT和解释器的区别是啥呢? 不都是运行时编译代码嘛?"></a>JIT和解释器的区别是啥呢? 不都是运行时编译代码嘛?</h1><p>JIT方式是有完整的Mono或者CLR虚拟机的机制, 而解释器则是一种针对Unity热更场景下的迷你版虚拟机机制.</p><h1 id="C-的执行机制"><a href="#C-的执行机制" class="headerlink" title="C#的执行机制"></a>C#的执行机制</h1><p>C#代码会被编译成IL语言, 在运行的时候, 通过一个Interpreter(解释器)逐行解释IL指令运行<br>在IOS上, 是不允许JIT的方式运行代码的, 只能使用AOT的方式运行<br>在Android等其他设备上AOT和JIT都是可以的</p><h1 id="Unity-PlayerSettings中有一个APICompatibilityLevel选项-是干嘛的"><a href="#Unity-PlayerSettings中有一个APICompatibilityLevel选项-是干嘛的" class="headerlink" title="Unity PlayerSettings中有一个APICompatibilityLevel选项 是干嘛的"></a>Unity PlayerSettings中有一个APICompatibilityLevel选项 是干嘛的</h1><p>你的Unity工程，允许代码能用（兼容）的 .NET（或Mono）API集合的标准程度。</p><p>Unity的脚本运行环境（Scripting Backend）是基于Mono（或IL2CPP）来实现C#环境的；<br>但Mono和微软官方.NET实现的API/标准并不是完全一致的，有新有旧、有全有残；<br>API Compatibility Level，就是让你指定用哪一套标准的API接口子集：<br>比如：.NET 2.0 Subset<br>又比如：.NET 4.x / .NET Standard 2.0<br>或者更高（随着Unity版本演进而变化）<br>这些选项，实际上背后对应着一组Unity定制的.NET Base Class Library (BCL)，决定你在C#脚本里能不能引用、编译、反射、调用某些标准库功能。</p><p><code>API Compatibility Level</code>会根据你所使用的Unity Editor版本变化而变化, 比如在<code>2020.3.48</code>版本中, <code>API Compatibility Level</code>的选项是<code>.Net 4.X</code>和<code>.Net Standard 2.0</code>, 而在<code>2022.3.15</code>版本中, <code>API Compatibility Level</code>的选项则变成了<code>.Net Standard 2.1</code>和<code>.Net Framework</code></p><h2 id="实际开发中如何选择"><a href="#实际开发中如何选择" class="headerlink" title="实际开发中如何选择?"></a>实际开发中如何选择?</h2><p>新项目：优先选“.NET 4.x”或“.NET Standard 2.0”。<br>项目中有现代C#语法（如async/await、LINQ等）：必须选新标准。<br>做插件/SDK跨Unity兼容：优先考虑“.NET Standard 2.0”。<br>有老DLL、Asset Store资产只支持2.0，且不想升级：临时用“.NET 2.0”。<br>手机版本极度精简、追求最小包体：用Subset，但很少有这种极端需求。</p><h1 id="如今行业内主流的热更方案究竟是怎么形成的"><a href="#如今行业内主流的热更方案究竟是怎么形成的" class="headerlink" title="如今行业内主流的热更方案究竟是怎么形成的?"></a>如今行业内主流的热更方案究竟是怎么形成的?</h1><ul><li>由于IOS对于JIT的限制, 导致主包必须使用AOT的方式打包, 而AOT打包会直接把.Net Mono虚拟机剔除掉, 将C#直接转成C++原生代码. 这就会导致主包不具备识别dll能力</li><li>接着, 由于各个操作系统平台对于原生代码的动态加载是有限制的（比如 dlopen 加新 so/dll）, 所以想要在运行时动态的加载一段逻辑进来, 只能使用非原生代码, 于是热更通常选择DLL（IL）</li><li>要让底包能认识和运行“热更dll”里的 C# 代码，就得有.NET虚拟机。但AOT打包让虚拟机相关能力被移除/阉割，不认dll。 但是虚拟机在AOT打包的时候已经几乎被完全剔除掉了, 因此我们必须让它恢复识别dll的功能, </li><li>要想恢复识别dll的能力，就得集成新的虚拟机或解释能力（比如ILRuntime/HybridCLR）。HybridCLR的意义就是让AOT包恢复充分甚至很大程度原生的DLL识别/运行能力。这就是HybridCLR所做的事情在AOT打包模式剔除掉Mono虚拟机识别dll代码能力的情况下, 重写AOT的打包方式, 让其保留能够识别dll代码的能力.</li></ul><h1 id="代码热更新-1"><a href="#代码热更新-1" class="headerlink" title="代码热更新"></a>代码热更新</h1><p>为什么代码热更新都选择使用JIT(将热更代码编译成dll)的方式, 而不选择AOT原生方式呢?</p><h1 id="热更的代码和热更的资源-哪个应该先加载"><a href="#热更的代码和热更的资源-哪个应该先加载" class="headerlink" title="热更的代码和热更的资源 哪个应该先加载?"></a>热更的代码和热更的资源 哪个应该先加载?</h1><p>热更代码的调用方式<br>有一种很取巧的方式加载热更代码, 那就是把热更代码挂载到某一个预制体上, 通过Unity的Awake方法调用热更代码的入口<br>AOT程序集 就是底包程序集 AOT是一种代码编译方式 它会</p><p>什么是streaming path? 什么是persistent path?</p><h1 id="一直有个问题是如果我区分程序集的话-我只修改了其中某一个程序集的代码-C-的编译器会不会只编译那个被修改代码的程序集而提高编译速度呢"><a href="#一直有个问题是如果我区分程序集的话-我只修改了其中某一个程序集的代码-C-的编译器会不会只编译那个被修改代码的程序集而提高编译速度呢" class="headerlink" title="一直有个问题是如果我区分程序集的话 我只修改了其中某一个程序集的代码 C#的编译器会不会只编译那个被修改代码的程序集而提高编译速度呢?"></a>一直有个问题是如果我区分程序集的话 我只修改了其中某一个程序集的代码 C#的编译器会不会只编译那个被修改代码的程序集而提高编译速度呢?</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/SunSpring/p/15047424.html">.net 温故知新：【2】 .Net Framework 、.Net 、 .NET Standard的概念与区别</a></li><li><a href="https://blog.csdn.net/codywangziham01/article/details/123689658">AOT 和 JIT、 IL2CPP和Mono、 CLR、 ILRuntime热更新原理</a></li><li><a href="https://www.cnblogs.com/fly-100/p/4594380.html">Unity跨平台原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/88692056">Unity从发布到流行经历了什么重大变化（2）</a></li><li><a href="https://blog.csdn.net/gz_huangzl/article/details/52486255">Unity将来时：IL2CPP是什么？有了Mono为什么还需要IL2CPP?</a></li><li><a href="https://blog.csdn.net/Funniyuan/article/details/136002603">.NET 发展历程与未来</a></li><li><a href="https://my.oschina.net/emacs_9244658/blog/18230886">Mono 软件发展历程详解</a></li><li><a href="https://www.cnblogs.com/willick/p/15038133.html">.NET 的发展简史</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;《CLR via C#》这本书帮助读者建立起了C#的知识框架, 是笔者职业生涯中功不可没的好书, 不过本书的作者Jeffrey Richter是以.Net Framework框架在Windows平台进行开发的视角上介绍.Net的一些特性的, 而笔者</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>人性的弱点</title>
    <link href="https://soincredible.github.io/posts/109e75d5/"/>
    <id>https://soincredible.github.io/posts/109e75d5/</id>
    <published>2025-06-18T10:58:23.000Z</published>
    <updated>2025-06-23T13:51:07.889Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityEditor开发中Singleton的设计</title>
    <link href="https://soincredible.github.io/posts/1477ebaf/"/>
    <id>https://soincredible.github.io/posts/1477ebaf/</id>
    <published>2025-06-11T08:14:28.000Z</published>
    <updated>2025-06-23T02:20:26.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Editor下创建单例"><a href="#在Editor下创建单例" class="headerlink" title="在Editor下创建单例"></a>在Editor下创建单例</h1><p>灵感来自Unity的<a href="https://sites.google.com/view/monkey-user-guide/getting-started">MonKey插件</a></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>我有一些由<code>ScriptableObject</code>、<code>json</code>或者别的格式组织的一组数据, 我希望在Editor模式下开发一套工具, 能让我对这一组数据进行增删改查, 根据MVC架构的思想, 必须有一个<code>Manager</code>来维护这一组数据的增删改查, 并且该<code>Manager</code>的生命周期需要和Unity Editor的生命周期保持一致.</p><h2 id="关键角色"><a href="#关键角色" class="headerlink" title="关键角色"></a>关键角色</h2><ul><li><a href="https://docs.unity3d.com/ScriptReference/InitializeOnLoadAttribute.html"><code>InitializeOnLoad</code></a>属性, 根据官方的描述, 该属性会在UnityEditor打开和代码重新编译的时候初始化Editor脚本. 你需要给这个Editor脚本提供一个静态的构造函数, <strong>注意</strong> 官方提到了 应该避免在InitialzeOnLoad中进行资产加载的操作, 因为InitialzeOnLoad是在资产导入完成前被调用的, 该操作有可能会导致资产加载失败. 要在需要进行资产操作的域重载后进行初始化, 可以使用<code>AssetPostprocessor.OnPostprocessAllAssets</code>回调. 但Unity2020版本中是没有这个接口的, 该回调支持所有资产操作, 并有一个参数提示是否进行了域重载. Unity不能保证 因此使用懒汉模式, 将在初始化操作中不能加载资源的操作变为了在初始化的过程中不能访问Instance的操作, 将加载资源的操作放在首次访问Instance之后 对于一个Editor单例, 如果该单例需要做一些加载操作, 那么就让这个单例实现IAssetProcess接口,</li></ul><p>EditorSingleton的实现<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Editor下创建单例&quot;&gt;&lt;a href=&quot;#在Editor下创建单例&quot; class=&quot;headerlink&quot; title=&quot;在Editor下创建单例&quot;&gt;&lt;/a&gt;在Editor下创建单例&lt;/h1&gt;&lt;p&gt;灵感来自Unity的&lt;a href=&quot;https://sit</summary>
      
    
    
    
    <category term="UnityEditor开发" scheme="https://soincredible.github.io/categories/UnityEditor%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityUGUIText实现描边</title>
    <link href="https://soincredible.github.io/posts/9125ebdc/"/>
    <id>https://soincredible.github.io/posts/9125ebdc/</id>
    <published>2025-05-27T15:41:18.000Z</published>
    <updated>2025-06-25T08:21:13.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过顶点方式实现描边"><a href="#通过顶点方式实现描边" class="headerlink" title="通过顶点方式实现描边"></a>通过顶点方式实现描边</h1><h2 id="UGUI中自带的Outline"><a href="#UGUI中自带的Outline" class="headerlink" title="UGUI中自带的Outline"></a>UGUI中自带的Outline</h2><h1 id="通过Shader方式实现描边"><a href="#通过Shader方式实现描边" class="headerlink" title="通过Shader方式实现描边"></a>通过Shader方式实现描边</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过顶点方式实现描边&quot;&gt;&lt;a href=&quot;#通过顶点方式实现描边&quot; class=&quot;headerlink&quot; title=&quot;通过顶点方式实现描边&quot;&gt;&lt;/a&gt;通过顶点方式实现描边&lt;/h1&gt;&lt;h2 id=&quot;UGUI中自带的Outline&quot;&gt;&lt;a href=&quot;#UGUI中自</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUGUI解构</title>
    <link href="https://soincredible.github.io/posts/e0e34b4b/"/>
    <id>https://soincredible.github.io/posts/e0e34b4b/</id>
    <published>2025-05-27T07:55:46.000Z</published>
    <updated>2025-06-23T11:11:03.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子——UGUI中的Text如何被绘制到屏幕上"><a href="#引子——UGUI中的Text如何被绘制到屏幕上" class="headerlink" title="引子——UGUI中的Text如何被绘制到屏幕上?"></a>引子——UGUI中的Text如何被绘制到屏幕上?</h1><p>参与绘制Text的角色:</p><ul><li>VertexHelper</li><li>TextGenerator</li><li>Font和FontData</li><li>BaseMeshEffect</li></ul><p>这是字体使用的Shader<br><figure class="highlight plaintext"><figcaption><span>Shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)</span><br><span class="line"></span><br><span class="line">Shader &quot;GUI/Text Shader&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Font Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Text Color&quot;, Color) = (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line"></span><br><span class="line">        Tags &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;PreviewType&quot;=&quot;Plane&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Lighting Off Cull Off ZTest Always ZWrite Off</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma multi_compile _ UNITY_SINGLE_PASS_STEREO STEREO_INSTANCING_ON STEREO_MULTIVIEW_ON</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata_t &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                fixed4 color : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                fixed4 color : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            uniform float4 _MainTex_ST;</span><br><span class="line">            uniform fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_t v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.color = v.color * _Color;</span><br><span class="line">                o.texcoord = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 col = i.color;</span><br><span class="line">                col.a *= tex2D(_MainTex, i.texcoord).a;</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这是所有的UGUI默认使用的Shader<br><figure class="highlight plaintext"><figcaption><span>Shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)</span><br><span class="line"></span><br><span class="line">Shader &quot;UI/Default&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line"></span><br><span class="line">        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8</span><br><span class="line">        _Stencil (&quot;Stencil ID&quot;, Float) = 0</span><br><span class="line">        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0</span><br><span class="line">        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255</span><br><span class="line">        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255</span><br><span class="line"></span><br><span class="line">        _ColorMask (&quot;Color Mask&quot;, Float) = 15</span><br><span class="line"></span><br><span class="line">        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;PreviewType&quot;=&quot;Plane&quot;</span><br><span class="line">            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stencil</span><br><span class="line">        &#123;</span><br><span class="line">            Ref [_Stencil]</span><br><span class="line">            Comp [_StencilComp]</span><br><span class="line">            Pass [_StencilOp]</span><br><span class="line">            ReadMask [_StencilReadMask]</span><br><span class="line">            WriteMask [_StencilWriteMask]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cull Off</span><br><span class="line">        Lighting Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest [unity_GUIZTestMode]</span><br><span class="line">        Blend One OneMinusSrcAlpha</span><br><span class="line">        ColorMask [_ColorMask]</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name &quot;Default&quot;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma target 2.0</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;UnityUI.cginc&quot;</span><br><span class="line"></span><br><span class="line">            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT</span><br><span class="line">            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP</span><br><span class="line"></span><br><span class="line">            struct appdata_t</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : POSITION;</span><br><span class="line">                float4 color    : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : SV_POSITION;</span><br><span class="line">                fixed4 color    : COLOR;</span><br><span class="line">                float2 texcoord  : TEXCOORD0;</span><br><span class="line">                float4 worldPosition : TEXCOORD1;</span><br><span class="line">                float4  mask : TEXCOORD2;</span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _TextureSampleAdd;</span><br><span class="line">            float4 _ClipRect;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float _UIMaskSoftnessX;</span><br><span class="line">            float _UIMaskSoftnessY;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_t v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f OUT;</span><br><span class="line">                UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);</span><br><span class="line">                float4 vPosition = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                OUT.worldPosition = v.vertex;</span><br><span class="line">                OUT.vertex = vPosition;</span><br><span class="line"></span><br><span class="line">                float2 pixelSize = vPosition.w;</span><br><span class="line">                pixelSize /= float2(1, 1) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));</span><br><span class="line"></span><br><span class="line">                float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);</span><br><span class="line">                float2 maskUV = (v.vertex.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);</span><br><span class="line">                OUT.texcoord = TRANSFORM_TEX(v.texcoord.xy, _MainTex);</span><br><span class="line">                OUT.mask = float4(v.vertex.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * half2(_UIMaskSoftnessX, _UIMaskSoftnessY) + abs(pixelSize.xy)));</span><br><span class="line"></span><br><span class="line">                OUT.color = v.color * _Color;</span><br><span class="line">                return OUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f IN) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half4 color = IN.color * (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd);</span><br><span class="line"></span><br><span class="line">                #ifdef UNITY_UI_CLIP_RECT</span><br><span class="line">                half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(IN.mask.xy)) * IN.mask.zw);</span><br><span class="line">                color.a *= m.x * m.y;</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                #ifdef UNITY_UI_ALPHACLIP</span><br><span class="line">                clip (color.a - 0.001);</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                color.rgb *= color.a;</span><br><span class="line"></span><br><span class="line">                return color;</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/TextGenerator.html">Unity TextGenerator API</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引子——UGUI中的Text如何被绘制到屏幕上&quot;&gt;&lt;a href=&quot;#引子——UGUI中的Text如何被绘制到屏幕上&quot; class=&quot;headerlink&quot; title=&quot;引子——UGUI中的Text如何被绘制到屏幕上?&quot;&gt;&lt;/a&gt;引子——UGUI中的Text如何</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线性代数在游戏开发中的应用</title>
    <link href="https://soincredible.github.io/posts/fd0318d/"/>
    <id>https://soincredible.github.io/posts/fd0318d/</id>
    <published>2025-05-27T03:38:12.000Z</published>
    <updated>2025-06-23T02:20:26.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断一个向量与坐标轴的重合度"><a href="#判断一个向量与坐标轴的重合度" class="headerlink" title="判断一个向量与坐标轴的重合度"></a>判断一个向量与坐标轴的重合度</h1><p>向量与每个坐标轴向量进行点积, 注意这里要求参与运算的所有向量都是归一化的, 点积结果会得到一个常数, 对这个常数取绝对值, 结果越大代表与该周向量越重合, 常数的正负代表的是与坐标轴的正方向还是负方向重合度更高. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断一个向量与坐标轴的重合度&quot;&gt;&lt;a href=&quot;#判断一个向量与坐标轴的重合度&quot; class=&quot;headerlink&quot; title=&quot;判断一个向量与坐标轴的重合度&quot;&gt;&lt;/a&gt;判断一个向量与坐标轴的重合度&lt;/h1&gt;&lt;p&gt;向量与每个坐标轴向量进行点积, 注意这里要求</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSharp中的CancellationToken</title>
    <link href="https://soincredible.github.io/posts/7331d0f1/"/>
    <id>https://soincredible.github.io/posts/7331d0f1/</id>
    <published>2025-05-24T01:08:07.000Z</published>
    <updated>2025-05-27T01:40:32.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://medium.com/@mitesh_shah/a-deep-dive-into-c-s-cancellationtoken-44bc7664555f">A Deep Dive into C#’s CancellationToken</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@mitesh_shah/a-deep-dive-into-c-s-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SVN——SubVersion学习记录</title>
    <link href="https://soincredible.github.io/posts/fb782408/"/>
    <id>https://soincredible.github.io/posts/fb782408/</id>
    <published>2025-05-22T13:04:39.000Z</published>
    <updated>2025-06-23T06:46:24.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SVN外链的使用"><a href="#SVN外链的使用" class="headerlink" title="SVN外链的使用"></a>SVN外链的使用</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SVN外链的使用&quot;&gt;&lt;a href=&quot;#SVN外链的使用&quot; class=&quot;headerlink&quot; title=&quot;SVN外链的使用&quot;&gt;&lt;/a&gt;SVN外链的使用&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>程序员超强大脑</title>
    <link href="https://soincredible.github.io/posts/823ad99a/"/>
    <id>https://soincredible.github.io/posts/823ad99a/</id>
    <published>2025-05-22T12:59:53.000Z</published>
    <updated>2025-05-23T01:30:36.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速阅读代码"><a href="#快速阅读代码" class="headerlink" title="快速阅读代码"></a>快速阅读代码</h2><p>提高快速查找相关信息的能力有助于减少反复浏览代码的次数. 如果代码阅读水平很高, 那么还可以降低浏览代码以查找其他信息的频率. 花在阅读代码方面的时间越少, 留给修复错误或者添加新功能的时间就越多, 程序员的效率因而越高.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快速阅读代码&quot;&gt;&lt;a href=&quot;#快速阅读代码&quot; class=&quot;headerlink&quot; title=&quot;快速阅读代码&quot;&gt;&lt;/a&gt;快速阅读代码&lt;/h2&gt;&lt;p&gt;提高快速查找相关信息的能力有助于减少反复浏览代码的次数. 如果代码阅读水平很高, 那么还可以降低浏览代码以查</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSharp中的委托</title>
    <link href="https://soincredible.github.io/posts/4f9ac505/"/>
    <id>https://soincredible.github.io/posts/4f9ac505/</id>
    <published>2025-05-22T01:00:06.000Z</published>
    <updated>2025-05-22T01:30:50.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>一篇很好的博客<a href="https://www.cnblogs.com/skysoot/archive/2012/04/05/2433639.html">https://www.cnblogs.com/skysoot/archive/2012/04/05/2433639.html</a></p><p>C#中的委托类似于C或C++中的函数指针。委托是存有对某个方法的引用的一种引用类型变量，引用可在运行时被改变。</p><p>委托特别用于实现事件和回调方法。所有的委托都派生自<code>System.Delegate</code>类。</p><h2 id="从实际问题出发来理解委托"><a href="#从实际问题出发来理解委托" class="headerlink" title="从实际问题出发来理解委托"></a>从实际问题出发来理解委托</h2><h3 id="将方法作为方法的参数"><a href="#将方法作为方法的参数" class="headerlink" title="将方法作为方法的参数"></a>将方法作为方法的参数</h3><p>这个标题非常地拗口，但我们先不管它，来看两个方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">EnglishGreeting(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;Good Moring,&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不管这两个方法有没有实际的意义，我们现在想通过这两个方法来向某人问好，当传入某人的姓名时，比如说”Joe”进去的时候，在这个方法中将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting方法则用于向屏幕输出”Good Moring, Joe”。</p><p>那么现在，假设这个程序要进行全球化了，我作为一个中国人，我不理解”Good Moring”是什么意思，那我就只能再加一个中文的问候方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;早上好，&quot;</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候GreetPeople也需要改一下了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？当然在进行这个之前，我们最好再定义一个枚举作为判断的依据：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Language&#123;</span><br><span class="line">English, Chinese</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name, Language lang</span>)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(lang)&#123;</span><br><span class="line"><span class="keyword">case</span> Language.English:</span><br><span class="line">EnglishGreeting(name);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Language.Chinese:</span><br><span class="line">    ChineseGreeting(name);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，尽管这样解决了问题，但是这个方法的可扩展性太差了，如果之后我们还要再添加韩文版、日文版，我们就不得不反复修改枚举和GreetPeople的方法，来适应新的需求。</p><p>那么在考虑新的解决方案之前，我们先来看看GreetPeople的方法签名：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name, Language lang</span>)</span>;</span><br></pre></td></tr></table></figure><p>我们只看<code>string name</code>，在这里，string是参数类型，name是参数变量，当我们赋给name字符串”Joe”时，他就代表了”Joe”这个值；当我们赋给他”周杰伦”时，它又代表着”周杰伦”这个值。然后，我们可以在这个方法体内对这个name进行其他的操作。</p><p>那我们再仔细想一想，假如GreetPeople方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值EnglishGreeting的时候它代表着EnglishGreeting()这个方法；当我们给它赋值ChineseGreeting的时候，它又代表着ChineseGreeting()的方法，我们将这个参数变量命名为MakeGreeting，那么不是可以如同给name赋值的时候一样，在调用Greet People()方法的时候，给这个MakeGreeting参数也附上值么，然后我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法是一样的，比如<code>MakeGreeting(name)</code>；</p><p>好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name, *** MakeGreeting</span>)</span>&#123;</span><br><span class="line">MakeGreeting(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <em>*</em>，这个位置通常放置的应该是参数的类型，但是到目前为止，我们仅仅想到的是应该有一个方法，并且按照这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？</p><p><strong>说明：</strong>这里已经不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是EnglishGreeting，而在这两个方法内部，已经对使用GroodMoring还是早上好做了区分。</p><p>下面就该委托出场了：</p><p>我们MakeGreeting代表的两个方法的签名如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chineseGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure><p>如同<code>name</code>可以接受string类型的数据一样，MakeGreeting它也代表着接受相同的一类数据，再进一步讲，就是MakeGreeting代表了参数类型和返回类型都相同的一类方法。本例中委托的定义如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure><p>与上面EnglishGreeting()方法的签名对比一下，出了加入delegate关键字以外，其他的部分都是完全一样的，那么再次调用GreetPeople方法，如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Greetingdelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name, Greetingdelegate MakeGreeting</span>)</span>&#123;</span><br><span class="line">MakeGreeting(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托Greeting Delegat出现的位置和string相同，string是一个类型，Greeting Delegate也是一个类型，或者说是一个类。但是委托的声明方式和类完全不同。实际上，委托在编译的时候确实会被编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。下面是一个完整的代码。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Good Morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;早上好, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name, GreetingDelegate MakeGreeting</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeGreeting(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GreetPeople(<span class="string">&quot;Joe&quot;</span>, EnglishGreeting);</span><br><span class="line">        GreetPeople(<span class="string">&quot;周杰伦&quot;</span>, ChineseGreeting);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合游戏开发中的实际应用，我们经常讲委托和单例模式、观察者模式等设计模式结合在一起使用，下面我将尝试抽象出一个事件中心的类，它专门负责处理各种委托事件，由于在一个游戏进程中只会有一个<strong>事件处理中心</strong>，所以我要将它设计成<a href="http://soincredible777.com.cn/posts/279644bd/">单例模式</a>。</p><p><strong>我们现在对委托做一个总结：委托是一个类，它定义了方法的类型，使得可以将方法作为另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量地使用if-else(switch)语句，同时使得程序具有更好的可扩展性。</strong></p><h2 id="声明委托"><a href="#声明委托" class="headerlink" title="声明委托"></a>声明委托</h2><p>委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。</p><p>假设有一个委托：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br></pre></td></tr></table></figure><p>上面的委托可被用于引用任何一个带有一个单一的string参数的方法，并返回一个int 类型的变量。</p><p>声明委托的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span> &lt;<span class="keyword">return</span> type&gt;&lt;<span class="built_in">delegate</span>-name&gt;&lt;parameter list&gt;</span><br></pre></td></tr></table></figure><h2 id="实例化委托"><a href="#实例化委托" class="headerlink" title="实例化委托"></a>实例化委托</h2><p>一旦声明了委托类型，委托对象就必须使用new关键字来创建，并且与一个特定的方法有关，当委托创建时，传递到new语句的参数就像方法调用一样书写，但是不带有参数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">printString</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br><span class="line">pringString ps1 = <span class="keyword">new</span> printString(WriteToScreen);</span><br><span class="line">printString ps2 = <span class="keyword">new</span> printString(WriteToFile);</span><br></pre></td></tr></table></figure><p>下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整形参数的方法，并返回一个整型值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DelegateAppl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">TestDelegate</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            num += p;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            num *= q;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);</span><br><span class="line">            nc1(<span class="number">25</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">            nc2(<span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面代码被编译和执行的时候，它会产生如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value of Num: 35</span><br><span class="line">Value of Num: 175</span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><ol><li>委托里面存储的方法可以是静态方法也可以是非静态的方法。</li><li>当声明的委托包含返回值的时候，不能直接调用Invoke方法，否则只会得到最后一个方法的结果。</li><li>定义委托与定义方法相比，一是没有方法体，而是多用了delegate修饰。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Test1</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Test2</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line">        MyDelegate myDelegate = <span class="keyword">new</span> MyDelegate(program.Test1);</span><br><span class="line">        myDelegate += program.Test2;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将delegate存放到一个数组中才能依次获取每一个方法的返回值。</span></span><br><span class="line">        Delegate[] delegates = myDelegate.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (MyDelegate item <span class="keyword">in</span> delegates)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托的多播-Multicasting-of-a-Delegate"><a href="#委托的多播-Multicasting-of-a-Delegate" class="headerlink" title="委托的多播(Multicasting of a Delegate)"></a>委托的多播(Multicasting of a Delegate)</h2><p>委托对象可以使用”+”运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可以被合并。”-“运算符可用于从合并的委托中移除组件委托。</p><p>使用委托的这个特点，我们可以创建一个委托被调用时要调用的方法的调用列表，这种行为被称为委托的多播(multicasting)，也叫组播。下面的程序演示了委托的多播：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DelegateAppl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">testdelegate</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            num += p;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            num *= q;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            NumberChanger nc;</span><br><span class="line">            NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);</span><br><span class="line"></span><br><span class="line">            nc = nc1;</span><br><span class="line">            nc += nc2;</span><br><span class="line">            nc += AddNum;</span><br><span class="line">            nc(<span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托的用途"><a href="#委托的用途" class="headerlink" title="委托的用途"></a>委托的用途</h2><p>下面实际演示了委托的用法，委托<code>printString</code>可用于引用带有一个字符串作为输入的方法，并不返回任何东西。</p><p>我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DelegateAppl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PrintString</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> FileStream fs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StreamWriter sw;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">printString</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteToScreen</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The String is:&#123;0&#125;&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteToFile</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;./message.txt&quot;</span>, FileMode.Append, FileAccess.Write);</span><br><span class="line">            sw = <span class="keyword">new</span> StreamWriter(fs);</span><br><span class="line">            sw.WriteLine(s);</span><br><span class="line">            sw.Flush();</span><br><span class="line">            sw.Close();</span><br><span class="line">            fs.Close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendString</span>(<span class="params">printString ps</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ps(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            printString ps1 = <span class="keyword">new</span> printString(WriteToScreen);</span><br><span class="line">            printString ps2 = <span class="keyword">new</span> printString(WriteToFile);</span><br><span class="line">            sendString(ps1);</span><br><span class="line">            sendString(ps2);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件基本上说是一个用户的操作，比如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件，比如中断。</p><p>C#中使用事件机制实现线程间的通信。</p><p>事件是一个受限制的委托，先看如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyDelegateClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyDelegate? myDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (myDelegate != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            myDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDelegateClass delegateClass = <span class="keyword">new</span> MyDelegateClass();</span><br><span class="line">        delegateClass.myDelegate += Run;</span><br><span class="line">        delegateClass.myDelegate.Invoke();</span><br><span class="line">        delegateClass.Test();</span><br><span class="line">        delegateClass.myDelegate = <span class="keyword">new</span> MyDelegate(Run);</span><br><span class="line">        delegateClass.myDelegate();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Running.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码运行时没有问题的，也就是说，我们在MyDelegateClass中声明的委托，既可以在当前类中执行，也可以在其他的类中执行，还可以在其他的类中重新赋值后再被调用执行。</p><p>接下来我们看看事件声明的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">delegate void MyDelegate();</span><br><span class="line"></span><br><span class="line">internal class MyDelegateClass</span><br><span class="line">&#123;</span><br><span class="line">    public event MyDelegate? myDelegate;</span><br><span class="line"></span><br><span class="line">    public void Test()</span><br><span class="line">    &#123;</span><br><span class="line">        if (myDelegate != null)</span><br><span class="line">        &#123;</span><br><span class="line">            myDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        MyDelegateClass delegateClass = new MyDelegateClass();</span><br><span class="line">        delegateClass.myDelegate += Run;</span><br><span class="line">        delegateClass.myDelegate.Invoke();</span><br><span class="line">        delegateClass.Test();</span><br><span class="line">        delegateClass.myDelegate = new MyDelegate(Run);</span><br><span class="line">        delegateClass.myDelegate();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void Run()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Running.......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到声明事件其实就是在声明委托变量的条件下，只用了个<code>event</code>修饰而已，即<code>myDelegate</code>现在是一个事件变量，而不是一个委托变量了，我们发现它仍然能在当前类中被执行，但是在另外的一个类中，既不能被直接调用执行，也不能被重新赋值了，只能通过<code>+=</code>或者<code>-=</code>来增减函数，这就是事件存在的必要，因为事件的这两个限制条件，在某种程度上会更安全。</p><p><strong>疑问：</strong>如果我在类中声明了一个委托，那么在实例化这个对象的时候，我并没有显式地给给这个委托赋值，<del>为什么不会报错呢</del>？但是如果我们在Main函数中实例化一个委托，不给他赋值的话，就会报错，为什么？</p><p>下面的代码给出了答案，上面说的两种情况都会报错的，但是在实例化对象的时候还需要手动地加一个判断条件，判断实例化的对象中的委托是不是空的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyDelegateClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> MyDelegate? myDelegate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegitserDelegate</span>(<span class="params">MyDelegate mmm</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myDelegate += mmm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InvokeDelegate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (myDelegate == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;委托是空的！不能调用！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            myDelegate.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Running.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Func</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDelegateClass delegateClass = <span class="keyword">new</span> MyDelegateClass();</span><br><span class="line">        delegateClass.InvokeDelegate();</span><br><span class="line">        MyDelegate mm = <span class="keyword">new</span> MyDelegate(MyDelegateClass.Run);</span><br><span class="line">        delegateClass.RegitserDelegate(mm);</span><br><span class="line">        delegateClass.InvokeDelegate();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中用到了一些访问修饰符</p><ul><li><code>public</code>: 公有访问，不受任何限制</li><li><code>private</code>: 私有访问，只限于本类成员访问，子类、实例都不能访问</li><li><code>protected</code>: 保护访问，只限于本类和子类访问，实例不能访问</li><li><code>internal</code>: 内部访问， 只限于本项目内访问，其他不能访问</li></ul><p><strong>TIPS：</strong>在计算机科学领域，<code>声明(Decalration)</code>指的是向编译器说明一个变量或者函数信息，包活：名字、类型、初始值等等，即声明变量、函数的属性细节；而<code>定义(Definition)</code>则指明变量、函数存储在哪里，当定义发生时，系统为变量或者函数分配内存单元。</p><h2 id="通过事件使用委托"><a href="#通过事件使用委托" class="headerlink" title="通过事件使用委托"></a>通过事件使用委托</h2><p>事件在类中声明且生成，且通过使用同一个类或者其他类中的委托与事件处理程序关联。包含事件的类用于发布事件，它被称为发布器(publisher)类。其他接受该事件的类被称为订阅器(subscriber)类。事件使用发布-订阅(publisher-subscriber)模型。</p><p>发布器(publisher)是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器类的对象调用这个事件，并通知其他的对象。</p><p>订阅器(subscriber)是一个接受事件并提供事件处理程序的对象。在发布器类中的委托调用订阅器类中。</p><h2 id="声明事件-Event"><a href="#声明事件-Event" class="headerlink" title="声明事件(Event)"></a>声明事件(Event)</h2><p>在类的内部声明事件，首先必须声明该事件的委托类型。如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后，声明事件本身，使用event关键字：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为BoilerLogHandler的委托和一个名为BoilerEventLog的事件，该事件在生成的时候会调用委托。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/******发布器类*******/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">NumManipulationHandler</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> NumManipulationHandler ChangeNum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnNumChanged</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ChangeNum != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ChangeNum(); <span class="comment">// 事件被触发</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Event not fire&quot;</span>);</span><br><span class="line">                Console.ReadKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EventTest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> n = <span class="number">5</span>;</span><br><span class="line">            SetValue(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> != n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">value</span> = n;</span><br><span class="line">                OnNumChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********订阅器类********/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">subscribEvent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;event fire&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/********触发********/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            EventTest e = <span class="keyword">new</span> EventTest(); <span class="comment">// 实例化对象，第一次没有触发事件</span></span><br><span class="line">            subscribEvent v = <span class="keyword">new</span> subscribEvent();</span><br><span class="line">            e.ChangeNum += <span class="keyword">new</span> EventTest.NumManipulationHandler(v.printf); <span class="comment">// 注册</span></span><br><span class="line">            e.SetValue(<span class="number">7</span>);</span><br><span class="line">            e.SetValue(<span class="number">11</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小故事："><a href="#小故事：" class="headerlink" title="小故事："></a>小故事：</h2><p>曾经.NET只有一个Delegate，别人想要使用委托的时候，必须使用delegate关键字来定义一个委托，但是这样有一个弊端，那就是delegate可以使用<code>=</code>将所有已经订阅的取消，也可以使用<code>+</code>和<code>-</code>对订阅进行合并和删除，只保留<code>=</code>之后的新的订阅，这就给了犯罪分子可乘之机。所以event应运而生，event是一种特殊的委托，它只能使用<code>+=</code>、<code>-=</code>，而不能直接使用<code>=</code>，也就是说，event在定义类（发布者）中是可以直接<code>=</code>的，但是在其他类中（订阅者）就只能使用<code>+=</code>、<code>-=</code>了，也就是说发布者发布了一个事件之后，订阅者针对他只能进行自身的订阅和取消。但是在事件发布和订阅的过程中，定义事件的原型委托类型常常是一件重复性的工作。所以<code>Event Handler</code>应运而生，它的出现就是为了避免这种重复性的工作，并建议尽量使用该类型作为事件的原型。</p><p>下面是EvenHandler的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TeacherArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler acthandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老师来了&quot;</span>);</span><br><span class="line">        TeacherArgs args = <span class="keyword">new</span> TeacherArgs() &#123; Name = Name &#125;;</span><br><span class="line">        acthandler(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HeadArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MedalCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Headmaster</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MedalCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler actHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Headmaster</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> medalCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        MedalCount = medalCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;校长来了&quot;</span>);</span><br><span class="line">        HeadArgs args = <span class="keyword">new</span> HeadArgs() &#123; Name = Name, MedalCount = MedalCount &#125;;</span><br><span class="line">        actHandler(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Teacher</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TeacherArgs args = e <span class="keyword">as</span> TeacherArgs;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;全体起立，喊：&#123;0&#125;好！&quot;</span>, args.Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Master</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HeadArgs args = e <span class="keyword">as</span> HeadArgs;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;全体起立，喊：&#123;0&#125;好&quot;</span>, args.Name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;校长获奖数为：&#123;0&#125;&quot;</span>, args.MedalCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Monitor</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MonitorArgs args = e <span class="keyword">as</span> MonitorArgs;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;班长来了，但是没有任何参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonitorArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Monitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler actHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;班长来了，但是什么参数都没有&quot;</span>);</span><br><span class="line">        MonitorArgs args = <span class="keyword">new</span> MonitorArgs() &#123; &#125;;</span><br><span class="line">        actHandler(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Students students = <span class="keyword">new</span> Students();</span><br><span class="line">        Headmaster headmaster = <span class="keyword">new</span> Headmaster(<span class="string">&quot;孙校长&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;刘老师&quot;</span>);</span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        headmaster.actHandler += students.Action_Master;</span><br><span class="line">        teacher.acthandler += students.Action_Teacher;</span><br><span class="line">        monitor.actHandler += students.Action_Monitor;</span><br><span class="line">        teacher.Come();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        headmaster.Come();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        monitor.Come();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>使用EventHandler可以</p><ol><li>标准化</li><li>可以省略定义委托这一步，不必定义多个不同类型的委托</li><li>搭配EventArgs，可以传递多个信息</li></ol><p>下面的代码是不使用EventHandler的实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics.Metrics;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TeacherDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">HeadMasterDelegate</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> medalCount</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MonitorDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> TeacherDelegate acthandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老师来了&quot;</span>);</span><br><span class="line">        acthandler(Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Headmaster</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> MedalCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> HeadMasterDelegate actHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Headmaster</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> medalCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        MedalCount = medalCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;校长来了&quot;</span>);</span><br><span class="line">        actHandler(Name, MedalCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Monitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> MonitorDelegate actHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;班长来了，但是什么参数都没有&quot;</span>);</span><br><span class="line">        actHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Teacher</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;全体起立，喊：&#123;0&#125;好！&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Master</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> medalCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;全体起立，喊：&#123;0&#125;好&quot;</span>, name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;校长获奖数为：&#123;0&#125;&quot;</span>, medalCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Monitor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;班长来了，但是没有任何参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Students students = <span class="keyword">new</span> Students();</span><br><span class="line">        Headmaster headmaster = <span class="keyword">new</span> Headmaster(<span class="string">&quot;孙校长&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;刘老师&quot;</span>);</span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        headmaster.actHandler += students.Action_Master;</span><br><span class="line">        teacher.acthandler += students.Action_Teacher;</span><br><span class="line">        monitor.actHandler += students.Action_Monitor;</span><br><span class="line">        teacher.Come();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        headmaster.Come();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        monitor.Come();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续回到小故事：在这个故事中，Delegate是老大哥，但是EventHandler是event的小弟，老大哥不太高兴了，说我也要有小弟，但更重要的原因是每次定义Delegate也是很麻烦的，所以Action应运而生，Action是系统预定义的一种委托，没有<strong>返回值</strong>，参数在<code>&lt;&gt;</code>中传入，下面就是使用Action的方法来实现上面的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Action&lt;<span class="built_in">string</span>&gt; acthandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老师来了&quot;</span>);</span><br><span class="line">        acthandler(Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Headmaster</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> MedalCount;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; actHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Headmaster</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> medalCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        MedalCount = medalCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;校长来了&quot;</span>);</span><br><span class="line">        actHandler(Name, MedalCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Monitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action actHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;班长来了，但是什么参数都没有&quot;</span>);</span><br><span class="line">        actHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Teacher</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;全体起立，喊：&#123;0&#125;好！&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Master</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> medalCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;全体起立，喊：&#123;0&#125;好&quot;</span>, name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;校长获奖数为：&#123;0&#125;&quot;</span>, medalCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action_Monitor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;班长来了，但是没有任何参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Students students = <span class="keyword">new</span> Students();</span><br><span class="line">        Headmaster headmaster = <span class="keyword">new</span> Headmaster(<span class="string">&quot;孙校长&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;刘老师&quot;</span>);</span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        headmaster.actHandler += students.Action_Master;</span><br><span class="line">        teacher.acthandler += students.Action_Teacher;</span><br><span class="line">        monitor.actHandler += students.Action_Monitor;</span><br><span class="line">        teacher.Come();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        headmaster.Come();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        monitor.Come();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段代码是用Func的方式实现的，Fun<code>&lt;&gt;</code>中比注册的函数的参数多1个，最后一个是参数是函数的返回类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Func&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt; acthandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老师来了&quot;</span>);</span><br><span class="line">        acthandler(Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Headmaster</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> MedalCount;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>, <span class="built_in">bool</span>&gt; actHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Headmaster</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> medalCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        MedalCount = medalCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;校长来了&quot;</span>);</span><br><span class="line">        actHandler(Name, MedalCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Monitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;<span class="built_in">bool</span>&gt; actHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Come</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;班长来了，但是什么参数都没有&quot;</span>);</span><br><span class="line">        actHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Action_Teacher</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;全体起立，喊：&#123;0&#125;好！&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Action_Master</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> medalCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;全体起立，喊：&#123;0&#125;好&quot;</span>, name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;校长获奖数为：&#123;0&#125;&quot;</span>, medalCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Action_Monitor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;班长来了，但是没有任何参数&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Students students = <span class="keyword">new</span> Students();</span><br><span class="line">        Headmaster headmaster = <span class="keyword">new</span> Headmaster(<span class="string">&quot;孙校长&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;刘老师&quot;</span>);</span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        headmaster.actHandler += students.Action_Master;</span><br><span class="line">        teacher.acthandler += students.Action_Teacher;</span><br><span class="line">        monitor.actHandler += students.Action_Monitor;</span><br><span class="line">        teacher.Come();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        headmaster.Come();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        monitor.Come();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写一个带有事件中心的发布、订阅系统"><a href="#写一个带有事件中心的发布、订阅系统" class="headerlink" title="写一个带有事件中心的发布、订阅系统"></a>写一个带有事件中心的发布、订阅系统</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"><span class="keyword">using</span> Microsoft.VisualBasic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerDeath</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;玩家死亡！向事件中心发送消息！&quot;</span>);</span><br><span class="line">        MessageCenter.Instance.SendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AudioManager Instance = <span class="keyword">new</span> AudioManager();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AudioManager</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是AudioManager，我已经创建完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayDeathAudio</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;执行死亡音效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataManager Instance = <span class="keyword">new</span> DataManager();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DataManager</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是DataManager，我已经创建完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;玩家死亡，执行数据重制&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnenyManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnenyManager Instance = <span class="keyword">new</span> EnenyManager();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnenyManager</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是EnemyManager，我已经创建完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnemyVictory</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;玩家死亡，敌人胜利！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MessageCenter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里是事件中心，处理游戏中各类事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MessageCenter Instance = <span class="keyword">new</span> MessageCenter();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MessageCenter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数使用private关键字就可以避免在别的类中使用new实例化对象了</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是事件中心，我已经初始化完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">PlayerDeathDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PlayerDeathDelegate DeathDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (DeathDelegate == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;委托是空的！没有什么好执行的！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            DeathDelegate.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">PlayerDeathDelegate deathDelegate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DeathDelegate += deathDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameStart</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerState player = <span class="keyword">new</span> PlayerState();</span><br><span class="line">        <span class="comment">// 游戏开始后要先将函数注册到事件中心去</span></span><br><span class="line">        MessageCenter.Instance.Register(AudioManager.Instance.PlayDeathAudio);</span><br><span class="line">        MessageCenter.Instance.Register(DataManager.Instance.ResetData);</span><br><span class="line">        MessageCenter.Instance.Register(EnenyManager.Instance.EnemyVictory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        player.PlayerDeath();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码还不够完善，比如现在只是处理了玩家死亡这一种事件，那如何处理玩家其他状态的事件呢？还有如果不是玩家，是别的什么比如宝物、使用药水等等各种的委托，该怎么实现？这都是后话了，委托的学习到此可以先告一段落了。</p><h1 id="项目中的按钮响应点击事件的方法"><a href="#项目中的按钮响应点击事件的方法" class="headerlink" title="项目中的按钮响应点击事件的方法"></a>项目中的按钮响应点击事件的方法</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonUI</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Button btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UI.Extension;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonPage</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ButtonUI _ui;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _ui = gameObject.GetComponent&lt;ButtonUI&gt;();</span><br><span class="line">        _ui.btn.onClick.AddListener(OnBtnClicked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBtnClicked</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;我被点击了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;委托&quot;&gt;&lt;a href=&quot;#委托&quot; class=&quot;headerlink&quot; title=&quot;委托&quot;&gt;&lt;/a&gt;委托&lt;/h1&gt;&lt;p&gt;一篇很好的博客&lt;a href=&quot;https://www.cnblogs.com/skysoot/archive/2012/04/05/243</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PhysX笔记</title>
    <link href="https://soincredible.github.io/posts/6f4ce0cc/"/>
    <id>https://soincredible.github.io/posts/6f4ce0cc/</id>
    <published>2025-05-14T08:09:35.000Z</published>
    <updated>2025-05-21T13:45:27.598Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>ProjectO</title>
    <link href="https://soincredible.github.io/posts/8a8aad75/"/>
    <id>https://soincredible.github.io/posts/8a8aad75/</id>
    <published>2025-05-14T08:08:18.000Z</published>
    <updated>2025-06-23T11:06:29.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><a href="https://soincredible.github.io/posts/20505312">代码热更新</a><br><a href="https://soincredible.github.io/posts/ae5b3442">资源加载</a><br><a href="https://soincredible.github.io/posts/ff09e316">ET框架8.1</a><br><a href="https://soincredible.github.io/posts/6f4ce0cc">物理模拟</a><br><a href="">动画</a><br><a href="">技能编辑器</a><br><a href="">数据库MongoDB</a><br><a href="">渲染</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://soincredible.github.io/posts/20505312&quot;&gt;代码热更新&lt;/a&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>The performance characteristics of async methods in C#</title>
    <link href="https://soincredible.github.io/posts/4b84508e/"/>
    <id>https://soincredible.github.io/posts/4b84508e/</id>
    <published>2025-05-13T00:59:38.000Z</published>
    <updated>2025-05-14T06:09:09.679Z</updated>
    
    <content type="html"><![CDATA[<p>在最近的两篇博客文章中，我们深入探讨了C#异步方法的内部实现机制，并详细分析了C#编译器提供的扩展点如何调整异步方法的行为。今天，我们将重点研究异步方法的性能特征。</p><p>正如本系列第一篇文章所述，编译器进行了大量转换工作，使异步编程体验几乎与同步编程无异。但为了实现这一点，编译器需要创建状态机实例、将其传递给异步方法生成器、调用任务等待器等。显然，所有这些逻辑都会带来性能开销，但具体代价有多大呢？</p><p>在TPL（任务并行库）出现之前，异步操作通常粒度较粗，因此其开销往往可以忽略不计。但在现代应用中，即使相对简单的程序每秒也可能执行成百上千次异步操作。TPL虽然针对这种工作负载进行了优化设计，但它并非魔法，仍然存在一定开销。</p><p>为了准确测量异步方法的开销，我们将对首篇博客中的示例进行适当调整后作为测试基准。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StockPrices</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> Count = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;(<span class="built_in">string</span> name, <span class="built_in">decimal</span> price)&gt; _stockPricesCache;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Async version</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">decimal</span>&gt; <span class="title">GetStockPriceForAsync</span>(<span class="params"><span class="built_in">string</span> companyId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> InitializeMapIfNeededAsync();</span><br><span class="line">        <span class="keyword">return</span> DoGetPriceFromCache(companyId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Sync version that calls async init</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">decimal</span> <span class="title">GetStockPriceFor</span>(<span class="params"><span class="built_in">string</span> companyId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeMapIfNeededAsync().GetAwaiter().GetResult();</span><br><span class="line">        <span class="keyword">return</span> DoGetPriceFromCache(companyId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Purely sync version</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">decimal</span> <span class="title">GetPriceFromCacheFor</span>(<span class="params"><span class="built_in">string</span> companyId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeMapIfNeeded();</span><br><span class="line">        <span class="keyword">return</span> DoGetPriceFromCache(companyId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">decimal</span> <span class="title">DoGetPriceFromCache</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> _stockPricesCache)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kvp.name == name)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> kvp.price;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">$&quot;Can&#x27;t find price for &#x27;<span class="subst">&#123;name&#125;</span>&#x27;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    [<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitializeMapIfNeeded</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Similar initialization logic.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">InitializeMapIfNeededAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_stockPricesCache != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">42</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Getting the stock prices from the external source.</span></span><br><span class="line">        <span class="comment">// Generate 1000 items to make cache hit somewhat expensive</span></span><br><span class="line">        _stockPricesCache = Enumerable.Range(<span class="number">1</span>, Count)</span><br><span class="line">            .Select(n =&gt; (name: n.ToString(), price: (<span class="built_in">decimal</span>)n))</span><br><span class="line">            .ToList();</span><br><span class="line">        _stockPricesCache.Add((name: <span class="string">&quot;MSFT&quot;</span>, price: <span class="number">42</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在最近的两篇博客文章中，我们深入探讨了C#异步方法的内部实现机制，并详细分析了C#编译器提供的扩展点如何调整异步方法的行为。今天，我们将重点研究异步方法的性能特征。&lt;/p&gt;
&lt;p&gt;正如本系列第一篇文章所述，编译器进行了大量转换工作，使异步编程体验几乎与同步编程无异。但为了实</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C#中的Task</title>
    <link href="https://soincredible.github.io/posts/323f6783/"/>
    <id>https://soincredible.github.io/posts/323f6783/</id>
    <published>2025-05-08T15:44:35.000Z</published>
    <updated>2025-05-09T01:44:30.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于TaskScheduler"><a href="#关于TaskScheduler" class="headerlink" title="关于TaskScheduler"></a>关于TaskScheduler</h1><p>TaskScheduler是C#<code>System.Threading.Tasks</code>命名空间下的一个抽象类, 在<code>.Net Framework 4.8</code>中C#内置了三个TaskScheduler的派生类: <code>ConcurrentExclusiveScheduler</code>、<code>SynchronizationContextTaskScheduler</code>、<code>ThreadPoolTaskScheduler</code>. </p><p>其中的<code>ThreadPoolTaskScheduler</code>, 被设置为了Default TaskScheduler</p><h1 id="ExecutionContext"><a href="#ExecutionContext" class="headerlink" title="ExecutionContext"></a>ExecutionContext</h1><p>执行上下文, </p><h1 id="StackCrawlMark"><a href="#StackCrawlMark" class="headerlink" title="StackCrawlMark"></a>StackCrawlMark</h1><h1 id="关于Thread"><a href="#关于Thread" class="headerlink" title="关于Thread"></a>关于Thread</h1><h1 id="调用Task-Run的时候-发生了什么"><a href="#调用Task-Run的时候-发生了什么" class="headerlink" title="调用Task.Run的时候 发生了什么"></a>调用Task.Run的时候 发生了什么</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于TaskScheduler&quot;&gt;&lt;a href=&quot;#关于TaskScheduler&quot; class=&quot;headerlink&quot; title=&quot;关于TaskScheduler&quot;&gt;&lt;/a&gt;关于TaskScheduler&lt;/h1&gt;&lt;p&gt;TaskScheduler是C#&lt;c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Extending the asynce methods in CSharp(译)</title>
    <link href="https://soincredible.github.io/posts/40aca622/"/>
    <id>https://soincredible.github.io/posts/40aca622/</id>
    <published>2025-05-08T13:01:43.000Z</published>
    <updated>2025-05-22T12:58:40.801Z</updated>
    
    <content type="html"><![CDATA[<p>首先要搞清楚, 为什么要实现我们自己的异步, 我们可以使用Task来完成我们的异步操作, 我们将需要异步的操作用Task包装, Task(Awaiter)何时结束、如何调度都是TaskScheduler做的, 我们没有太多权限干预 我们能做的只是告诉Task 等你的任务完成之后 你需要调用stateMachiner的MoveNext方法, 如果我要实现自己的类似ETTask的功能, 我希望我能自己决定如何调度这些ETTask, 要不然实现自己的ETTask的意义就没有了. C#中异步操作到这里就已经揭示地比较清楚了, 只是Task的调度目前对我们来说还是黑盒, 最好它也只是黑盒</p><p>因此, 在笔者看来, 要实现自己的异步, 就是要实现如何调度这些异步操作, 即我们要实现TaskScheduler的功能.</p><p>我们使用Task包装一些操作, 这些操作可能是<code>ComputeBound</code>类型或者<code>IOBound</code>类型, 也可能只是一个延时<code>Task.Delay</code>操作, 甚至可能就是一个简单的同步方法. 不论是什么操作, 你只要将该操作使用Task包装, 并且调用了该Task, 那么你就可以通过获取<code>Task.GetAwaiter()</code>接口获取到该Task的Awaiter, 然后通过调用Awaiter.IsComplete来判断包装进该Task的操作有没有完成.</p><p>我们希望的是Task可以被await, 那么Task中就要有一个<code>GetAwaiter()</code>方法<br>那么task的GetAwaiter方法返回回来的是一个TaskAwaiter类型<br>所以是TaskAwaiter类型实现了INotifyCompletion接口、 且TaskAwaiter中有<code>bool IsComplete &#123;get;&#125;</code>属性和<code>T GetResult()</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static async Task Foo()</span><br><span class="line">&#123;</span><br><span class="line">    var lazy = new Lazy&lt;int&gt;(() =&gt; 42);</span><br><span class="line">    var result = await lazy;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中() =&gt; 42 的含义<br>()：表示一个没有参数的匿名方法（类似无参函数）。</p><p>=&gt;：Lambda 运算符，分隔参数和方法体。</p><p>42：方法的返回值（此处直接返回常量值 42）。</p><p>Lazy<T> 的构造函数接受一个 Func<T> 委托（即一个无参且返回 T 类型的方法）。Lambda 表达式 () =&gt; 42 正好匹配这个委托类型：</p><p>Func<int> 的签名是 int Func()，而 () =&gt; 42 是一个无参且返回 int 的表达式。</p><p>因此，代码可以简化为 Lambda 形式，而不需要显式定义一个单独的方法。</p><p>在之前的博客文章中，我们讨论了C#编译器如何转换异步方法。本文将重点介绍C#编译器提供的扩展点，用于自定义异步方法的行为。</p><p>有三种方式可以控制异步方法的运行机制：</p><ul><li>在System.Runtime.CompilerServices命名空间中提供自定义的异步方法生成器</li><li>使用自定义任务等待器</li><li>定义自己的类任务类型</li></ul><h1 id="System-Runtime-CompilerServices命名空间中的自定义类型"><a href="#System-Runtime-CompilerServices命名空间中的自定义类型" class="headerlink" title="System.Runtime.CompilerServices命名空间中的自定义类型"></a>System.Runtime.CompilerServices命名空间中的自定义类型</h1><p>正如我们在上一篇文章中所了解的，C#编译器将异步方法转换为一个生成的状态机，该状态机依赖于一些预定义类型。但C#编译器并不要求这些已知类型必须来自特定程序集。例如，您可以在项目中提供自己的AsyncVoidMethodBuilder实现，C#编译器会将异步机制”绑定”到您的自定义类型。</p><p>这是探索底层转换原理和了解运行时情况的绝佳方式：</p><p>必须要注意, 这种方式你必须将你的builder定义在<code>System.Runtime.CompilerServices</code>命名空间下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">System.Runtime.CompilerServices</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AsyncVoidMethodBuilder.cs in your project</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AsyncVoidMethodBuilder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AsyncVoidMethodBuilder</span>()</span></span><br><span class="line">            =&gt; Console.WriteLine(<span class="string">&quot;.ctor&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncVoidMethodBuilder <span class="title">Create</span>()</span></span><br><span class="line">            =&gt; <span class="keyword">new</span> AsyncVoidMethodBuilder();</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetResult</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;SetResult&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>&lt;<span class="title">TStateMachine</span>&gt;(<span class="params"><span class="keyword">ref</span> TStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TStateMachine : IAsyncStateMachine</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">            stateMachine.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetStateMachine</span>(<span class="params">IAsyncStateMachine stateMachine</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetException</span>(<span class="params">Exception exception</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AwaitOnCompleted</span>&lt;<span class="title">TAwaiter</span>, <span class="title">TStateMachine</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">ref</span> TAwaiter awaiter, <span class="keyword">ref</span> TStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TAwaiter : INotifyCompletion</span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TStateMachine : IAsyncStateMachine</span></span><br><span class="line">        &#123;</span><br><span class="line">            stateMachine.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AwaitUnsafeOnCompleted</span>&lt;<span class="title">TAwaiter</span>, <span class="title">TStateMachine</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">ref</span> TAwaiter awaiter, <span class="keyword">ref</span> TStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TAwaiter : ICriticalNotifyCompletion</span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TStateMachine : IAsyncStateMachine</span></span><br><span class="line">        &#123;</span><br><span class="line">            stateMachine.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在, 你项目中所有的异步方法都会使用这个自定义版本的<code>AsyncVoidMethodBuilder</code>. 我们可以用下面的异步方法简单测试一下:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RunAsyncVoid</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Before VoidAsync&quot;</span>);</span><br><span class="line">    VoidAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After VoidAsync&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">VoidAsync</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果是:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before VoidAsync</span><br><span class="line">.ctor</span><br><span class="line">Start</span><br><span class="line">SetResult</span><br><span class="line">After VoidAsync</span><br></pre></td></tr></table></figure></p><p>您可以实现 UnsafeAwaitOnComplete 方法来测试带有 await 子句的异步方法在返回未完成任务时的行为。完整示例可以在 GitHub 上找到。</p><p>要修改 async Task 和 async Task<T> 方法的行为，您需要提供自己的 AsyncTaskMethodBuilder 和 AsyncTaskMethodBuilder<T> 实现。完整的实现示例可以在我的 GitHub 项目 EduAsync(*) 中找到，分别对应文件 AsyncTaskBuilder.cs 和 AsyncTaskMethodBuilderOfT.cs。</p><h1 id="Custom-awaiters"><a href="#Custom-awaiters" class="headerlink" title="Custom awaiters"></a>Custom awaiters</h1><p>前面的示例属于”黑客手段”，并不适合生产环境。虽然我们可以通过这种方式学习异步机制，但您肯定不希望在自己的代码库中看到这样的代码。C# 语言设计者在编译器中内置了正确的扩展点，允许在异步方法中”await”不同的类型。</p><p>要使某个类型成为”可等待的”（即可以在 await 表达式中使用），该类型需要遵循特定模式：</p><p>编译器必须能够找到一个名为 GetAwaiter 的实例方法或扩展方法。该方法的返回类型需要满足以下要求：</p><ul><li>必须实现 INotifyCompletion 接口</li><li>必须包含 bool IsCompleted {get;} 属性</li><li>必须提供 T GetResult() 方法</li></ul><p>这意味着我们可以轻易的将<code>Lazy&lt;T&gt;</code>变得awaitable:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> LazyAwaiter&lt;T&gt; : INotifyCompletion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Lazy&lt;T&gt; _lazy;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyAwaiter</span>(<span class="params">Lazy&lt;T&gt; lazy</span>)</span> =&gt; _lazy = lazy;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetResult</span>()</span> =&gt; _lazy.Value;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted =&gt; <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params">Action continuation</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">LazyAwaiterExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">LazyAwaiter</span>&lt;<span class="title">T</span>&gt; <span class="title">GetAwaiter</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> Lazy&lt;T&gt; lazy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LazyAwaiter&lt;T&gt;(lazy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> lazy = <span class="keyword">new</span> Lazy&lt;<span class="built_in">int</span>&gt;(() =&gt; <span class="number">42</span>);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> lazy;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例可能看起来有些刻意，但这种扩展机制实际上非常实用，并且已被广泛应用。例如：</p><p>.NET 的 Reactive Extensions 就提供了自定义等待器，允许在异步方法中等待 IObservable<T> 实例</p><p>基础类库(BCL)本身也包含多个实现：</p><p>YieldAwaitable（由 Task.Yield 使用）</p><p>HopToThreadPoolAwaitable</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> HopToThreadPoolAwaitable : INotifyCompletion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HopToThreadPoolAwaitable <span class="title">GetAwaiter</span>()</span> =&gt; <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted =&gt; <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params">Action continuation</span>)</span> =&gt; Task.Run(continuation);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetResult</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下单元测试展示了最后一个等待器的实际应用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> testThreadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">    <span class="keyword">await</span> Sample();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">async</span> Task <span class="title">Sample</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Assert.AreEqual(Thread.CurrentThread.ManagedThreadId, testThreadId);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">await</span> <span class="literal">default</span>(HopToThreadPoolAwaitable);</span><br><span class="line">        Assert.AreNotEqual(Thread.CurrentThread.ManagedThreadId, testThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何异步方法的第一部分（在首个 await 语句之前）都会同步执行。在大多数情况下，这种机制非常适合用于立即进行参数验证，但有时我们需要确保方法体不会阻塞调用者线程。HopToThreadPoolAwaitable 的作用就是确保方法的剩余部分在线程池线程而非调用者线程中执行。</p><h1 id="Task-Like-Types"><a href="#Task-Like-Types" class="headerlink" title="Task-Like Types"></a>Task-Like Types</h1><p>自定义等待器（custom awaiters）从支持 async/await 的编译器最初版本（即 C# 5）就已存在。这种扩展机制虽然很有用，但存在限制——所有异步方法都必须返回 void、Task 或 Task<T>。从 C# 7.2 开始，编译器开始支持类任务类型。</p><p>类任务类型是指具有关联构建器类型的类或结构体，该构建器类型通过 AsyncMethodBuilderAttribute(**) 标识。要使类任务类型真正有用，它必须满足前一节描述的”可等待”条件。本质上，类任务类型整合了前文所述的两种扩展机制，并将第一种方式转化为官方支持方案。</p><p>以下是一个定义为结构体的自定义类任务类型简单示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TaskLikeMethodBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskLikeMethodBuilder</span>()</span></span><br><span class="line">        =&gt; Console.WriteLine(<span class="string">&quot;.ctor&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TaskLikeMethodBuilder <span class="title">Create</span>()</span></span><br><span class="line">        =&gt; <span class="keyword">new</span> TaskLikeMethodBuilder();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetResult</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;SetResult&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>&lt;<span class="title">TStateMachine</span>&gt;(<span class="params"><span class="keyword">ref</span> TStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TStateMachine : IAsyncStateMachine</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">        stateMachine.MoveNext();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> TaskLike Task =&gt; <span class="literal">default</span>(TaskLike);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// AwaitOnCompleted, AwaitUnsafeOnCompleted, SetException </span></span><br><span class="line">    <span class="comment">// and SetStateMachine are empty</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">System.Runtime.CompilerServices.AsyncMethodBuilder(typeof(TaskLikeMethodBuilder))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TaskLike</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskLikeAwaiter <span class="title">GetAwaiter</span>()</span> =&gt; <span class="literal">default</span>(TaskLikeAwaiter);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TaskLikeAwaiter : INotifyCompletion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetResult</span>()</span> &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted =&gt; <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params">Action continuation</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以定义返回类任务类型（TaskLike）的方法，甚至可以在方法体内使用不同的类任务类型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> TaskLike <span class="title">FooAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Yield();</span><br><span class="line">    <span class="keyword">await</span> <span class="literal">default</span>(TaskLike);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入类任务类型（task-like types）的主要目的是减少异步操作的开销。每个返回 Task<T> 的异步操作至少会在托管堆上分配一个对象——即任务本身。对于绝大多数应用程序来说，这完全不是问题，尤其是处理粗粒度异步操作时。但对于基础设施级别的代码（每秒可能涉及数千个小型任务）而言，情况则不同。在这类场景下，减少每次调用的内存分配可以显著提升性能。</p><h1 id="异步模式扩展基础"><a href="#异步模式扩展基础" class="headerlink" title="异步模式扩展基础"></a>异步模式扩展基础</h1><p>C# 编译器为扩展异步方法提供了多种方式：</p><ul><li>修改现有基于 Task 的异步方法, 通过提供自定义的 AsyncTaskMethodBuilder 类型实现来改变行为</li><li>实现”可等待模式”, 通过实现 “awaitable pattern” 使类型支持 await 操作</li><li>构建自定义类任务类型（C# 7+）, 从 C# 7 开始支持创建自己的类任务类型</li></ul><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="Dissecting the async methods in C#">深度解析 C# 异步方法</a></p><p><a href="EduAsync repo on github">EduAsync 代码库（GitHub）</a></p><p><a href="Task-like types">类任务类型详解</a></p><p>下一篇博客, 我们将探讨异步方法的性能特征，并分析新型值类型 System.ValueTask 如何影响性能表现。</p><h1 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h1><p>将Unity异步操作类型变得可以await<br>笔者今天找到的应用场景: 在Unity中, 如果你在Editor模式下执行某些异步操作, 你是没有办法通过MonoBehaviour开启协程来驱动异步操作的, 当然有一些奇技淫巧, 比如I2那个多语言插件, 笔者记得好像是通过在场景中创建一个挂在了其异步操作的MonoBehaviour的节点, 在那个节点上执行异步操作, 但是笔者觉得还是不太优雅, 需要Unity协程驱动的异步操作变成可以被Task await的操作.</p><p>代码如下:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> UnityWebRequestAsyncOperationAwaiter : ICriticalNotifyCompletion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> UnityWebRequestAsyncOperation _asyncOperation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnityWebRequestAsyncOperationAwaiter</span>(<span class="params">UnityWebRequestAsyncOperation asyncOperation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _asyncOperation = asyncOperation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params">Action continuation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _asyncOperation.completed += _ =&gt; continuation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnsafeOnCompleted</span>(<span class="params">Action continuation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _asyncOperation.completed += _ =&gt; continuation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetResult</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_asyncOperation.webRequest.result != UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnityWebRequestException(_asyncOperation.webRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted =&gt; _asyncOperation.isDone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnityWebRequestException</span> : <span class="title">Exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnityWebRequestException</span>(<span class="params">UnityWebRequest request</span>) </span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"><span class="string">$&quot;Error: <span class="subst">&#123;request.error&#125;</span>\nURL: <span class="subst">&#123;request.url&#125;</span>&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UnityWebRequestAsyncOperationExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UnityWebRequestAsyncOperationAwaiter <span class="title">GetAwaiter</span>(<span class="params"><span class="keyword">this</span> UnityWebRequestAsyncOperation asyncOperation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnityWebRequestAsyncOperationAwaiter(asyncOperation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AIDebugger</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Command(<span class="string">&quot;SetAIMatch&quot;</span>, QuickName = <span class="string">&quot;设置匹配AI&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetAIMatch</span>(<span class="params">[CommandParameter(<span class="string">&quot;是否开启AI匹配&quot;</span></span>)]<span class="built_in">bool</span> enableAI)</span></span><br><span class="line">    &#123;</span><br><span class="line">        AIMatchDebugger.PostRequest(UserData.Instance.userId, enableAI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AIMatchDebugger</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;UI Elements&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> InputField userIdInput;</span><br><span class="line">    <span class="keyword">public</span> Toggle needAIToggle;</span><br><span class="line">    <span class="keyword">public</span> Toggle needAIOnlyToggle;</span><br><span class="line">    <span class="keyword">public</span> Button submitButton;</span><br><span class="line">    <span class="keyword">public</span> Text statusText;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Server Config&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> serverURL = <span class="string">&quot;http://fhdz3dfzwss.nalrer.cn:8016/gtest/dizhu/aiMatch&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        submitButton.onClick.AddListener(SubmitForm);</span><br><span class="line">        LoadDefaultValues();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadDefaultValues</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        userIdInput.text = <span class="string">&quot;72087&quot;</span>;</span><br><span class="line">        needAIToggle.isOn = <span class="literal">true</span>;</span><br><span class="line">        needAIOnlyToggle.isOn = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SubmitForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// PostRequest();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">PostRequest</span>(<span class="params"><span class="built_in">int</span> userId, <span class="built_in">bool</span> enableAI</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 准备表单数据</span></span><br><span class="line">            WWWForm form = <span class="keyword">new</span> WWWForm();</span><br><span class="line">            form.AddField(<span class="string">&quot;userId&quot;</span>, userId.ToString());</span><br><span class="line">            form.AddField(<span class="string">&quot;needAI&quot;</span>, enableAI ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            form.AddField(<span class="string">&quot;needAIOnly&quot;</span>, enableAI ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            QDebug.Log(<span class="string">&quot;请求发出去了&quot;</span>);</span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            <span class="keyword">using</span> (UnityWebRequest www = UnityWebRequest.Post(serverURL, form))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> www.SendWebRequest();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (www.result != UnityWebRequest.Result.Success)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// statusText.text = $&quot;Error: &#123;www.error&#125;&quot;;</span></span><br><span class="line">                    QDebug.LogError(www.error);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// statusText.text = &quot;修改成功&quot;;</span></span><br><span class="line">                    QDebug.Log(<span class="string">&quot;Form upload complete!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            QDebug.LogError(<span class="string">&quot;发生异常了&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// TODO handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者暂且认为第三种 Task-Like Types是当前主流的C#中实现自定义异步的方式. 想要用这种方式实现异步, 你需要:</p><p>你有很多的操作, 无论是C#提供给你的Task还是你自己基于C#实现的类Task都是把你想要用异步方式执行的操作包装起来. </p><p>构建自己的异步有三个重要角色:</p><ul><li>自己的AsyncMethodBuilder</li><li>自己的Awaiter</li><li>自己的TaskLike类型 这里注意<code>awaiter</code>是<code>awaiter</code>, <code>tasklike</code>是<code>tasklike</code>, 但是ETTask将既是tasklike又是awaiter</li></ul><ol><li>有一个名为<code>TaskLikeMethodBuilder</code>的method builder, 这个Builder里面需要如下接口<ul><li>public static TaskLikeMethodBuilder <strong>Create</strong>()接口</li><li>public void <strong>Start</strong><TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine接口</li><li>public void <strong>SetException</strong>(Exception e)接口</li><li>public void <strong>SetResult</strong>() 接口</li><li>public void <strong>AwaitOnCompleted</strong><TAwaiter, TStateMachine>(<pre><code>   ref TAwaiter awaiter, ref TStateMachine stateMachine)   where TAwaiter : INotifyCompletion   where TStateMachine : IAsyncStateMachine 接口</code></pre></li><li>public void <strong>AwaitUnsafeOnCompleted</strong><TAwaiter, TStateMachine>(<pre><code>   ref TAwaiter awaiter, ref TStateMachine stateMachine)   where TAwaiter : ICriticalNotifyCompletion   where TStateMachine : IAsyncStateMachine 接口</code></pre></li><li>public void <strong>SetStateMachine</strong>(IAsyncStateMachine stateMachine) 接口</li><li>public TaskLike <strong>Task</strong> // 名字必须是Task</li></ul></li><li>有一个实现了ICriticalNotifyCompletion接口的类<ul><li>OnCompleted(Action continuation)</li><li>UnsafeOnCompleted(Action continuation)</li></ul></li><li>一个Tasklike类<ul><li>有一个GetAwaiter</li><li>GetResult()接口</li><li>IsCompleted属性 注意必须是属性(Property)</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先要搞清楚, 为什么要实现我们自己的异步, 我们可以使用Task来完成我们的异步操作, 我们将需要异步的操作用Task包装, Task(Awaiter)何时结束、如何调度都是TaskScheduler做的, 我们没有太多权限干预 我们能做的只是告诉Task 等你的任务完成</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dissecting the async methods in CSharp</title>
    <link href="https://soincredible.github.io/posts/72dba58e/"/>
    <id>https://soincredible.github.io/posts/72dba58e/</id>
    <published>2025-05-07T12:44:20.000Z</published>
    <updated>2025-05-13T15:38:21.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于异步的历史"><a href="#关于异步的历史" class="headerlink" title="关于异步的历史"></a>关于异步的历史</h1><p>C#开发者在第一次接触异步的概念, 应该是通过Task类型. Task是在<code>.Net 4.0</code>的时候被引入的. 一个task就是一个work单元, 且该task承诺, 在这个task未来完成的时候, 会将结果返回给task的调用者. 这个Task可能是由IO操作支持或者计算密集型操作(这正好对应了笔者在协程部分所说的CPU密集型操作和IO型操作, Unity协程只能用来做IO型的异步操作). 重要的是该操作的结果是自包含的，且具有一等公民身份。你可以自由传递这个”未来”：将其存储在变量中、从方法返回它、或传递给其他方法。你可以将两个”未来”合并形成新的任务，可以同步等待结果，也可以通过添加”延续”来”等待”结果。仅凭任务实例本身，你就能决定在操作成功、失败或被取消时采取何种处理。</p><p>任务并行库 (TPL) 改变了我们对并发编程的认知，而 C# 5 通过引入 async/await 进一步推动了这一发展。async/await 让任务的组合变得更加容易，并允许开发者使用熟悉的代码结构，如 try/catch、using 等。但是async/await也有其开销. 要理解具体开销是什么, 我们需要深入底层机制中.</p><h1 id="异步方法内部"><a href="#异步方法内部" class="headerlink" title="异步方法内部"></a>异步方法内部</h1><p>普通方法只有一个入口点和一个退出点（虽然可能有多个 return 语句，但在运行时，每次调用仅有一个实际退出点）。但 异步方法（*） 和 迭代器方法（包含 yield return 的方法）则不同。对于异步方法而言，调用方几乎可以立即获取结果（即 Task 或 Task<T>），然后通过返回的任务（Task）来 “await” 方法的实际执行结果。</p><p>（*）我们定义的 “异步方法” 是指用 async 上下文关键字标记的方法。这并不一定意味着该方法会异步执行，甚至完全不意味着它是异步的。它仅表示 编译器会对该方法进行某些特殊转换。</p><p>看一下下面这个异步方法:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">StockPrices</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">decimal</span>&gt; _stockPrices;</span><br><span class="line">    <span class="comment">// 被标记了async的方法, Compiler会在背后将其内部的逻辑转调用一个状态机</span></span><br><span class="line">    <span class="comment">// 而这个异步方法中原来的逻辑会全部转移到Compiler自动生成的状态机的MoveNext方法中 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">decimal</span>&gt; <span class="title">GetStockPriceForAsync</span>(<span class="params"><span class="built_in">string</span> companyId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> InitializeMapIfNeededAsync();</span><br><span class="line">        _stockPrices.TryGetValue(companyId, <span class="keyword">out</span> <span class="keyword">var</span> result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 被标记了async的方法, Compiler会在背后将其转换成状态机</span></span><br><span class="line">    <span class="comment">// 而这个异步方法中原来的逻辑会全部转移到Compiler自动生成的状态机的MoveNext方法中 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">InitializeMapIfNeededAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_stockPrices != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">42</span>);</span><br><span class="line">        <span class="comment">// Getting the stock prices from the external source and cache in memory.</span></span><br><span class="line">        _stockPrices = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">decimal</span>&gt; &#123; &#123; <span class="string">&quot;MSFT&quot;</span>, <span class="number">42</span> &#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><blockquote><p>上面这段代码中的两个方法都使用了<code>async</code>标记, 到头来都只是为了<code>await Task.Delay(42)</code>这一行代码服务的.<br>为了更好的理解编译器做了或者能做什么, 让我们尝试着手写一下转换过程</p></blockquote></blockquote><h1 id="手动解构异步方法"><a href="#手动解构异步方法" class="headerlink" title="手动解构异步方法"></a>手动解构异步方法</h1><p>TPL（任务并行库）提供了两大核心构建模块，帮助我们构造和组合任务：</p><ul><li>任务延续（Task Continuation）-&gt; 通过 <code>Task.ContinueWith</code>实现</li><li>手动构建任务 -&gt; 通过 <code>TaskCompletionSource&lt;T&gt;</code> 类实现<br>（注：前者用于链式编排任务，后者用于手动控制任务生命周期。）<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GetStockPriceForAsync_StateMachine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> State &#123; Start, Step1, &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> StockPrices @this;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _companyId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> TaskCompletionSource&lt;<span class="built_in">decimal</span>&gt; _tcs;</span><br><span class="line">    <span class="keyword">private</span> Task _initializeMapIfNeededTask;</span><br><span class="line">    <span class="keyword">private</span> State _state = State.Start;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetStockPriceForAsync_StateMachine</span>(<span class="params">StockPrices @<span class="keyword">this</span>, <span class="built_in">string</span> companyId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.@this = @this;</span><br><span class="line">        _companyId = companyId;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_state == State.Start)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// The code from the start of the method to the first &#x27;await&#x27;.</span></span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(_companyId))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException();</span><br><span class="line"> </span><br><span class="line">                _initializeMapIfNeededTask = @this.InitializeMapIfNeeded();</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Update state and schedule continuation</span></span><br><span class="line">                _state = State.Step1;</span><br><span class="line">                _initializeMapIfNeededTask.ContinueWith(_ =&gt; Start());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (_state == State.Step1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Need to check the error and the cancel case first</span></span><br><span class="line">                <span class="keyword">if</span> (_initializeMapIfNeededTask.Status == TaskStatus.Canceled)</span><br><span class="line">                    _tcs.SetCanceled();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (_initializeMapIfNeededTask.Status == TaskStatus.Faulted)</span><br><span class="line">                    _tcs.SetException(_initializeMapIfNeededTask.Exception.InnerException);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// The code between first await and the rest of the method</span></span><br><span class="line"> </span><br><span class="line">                    @this._stockPrices.TryGetValue(_companyId, <span class="keyword">out</span> <span class="keyword">var</span> result);</span><br><span class="line">                    _tcs.SetResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            _tcs.SetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Task&lt;<span class="built_in">decimal</span>&gt; Task =&gt; _tcs.Task;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">decimal</span>&gt; <span class="title">GetStockPriceForAsync</span>(<span class="params"><span class="built_in">string</span> companyId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> stateMachine = <span class="keyword">new</span> GetStockPriceForAsync_StateMachine(<span class="keyword">this</span>, companyId);</span><br><span class="line">    stateMachine.Start();</span><br><span class="line">    <span class="keyword">return</span> stateMachine.Task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这段代码虽然冗长，但逻辑相对直接。原先在 GetStockPriceForAsync 中的所有逻辑都被转移到了 GetStockPriceForAsync_StateMachine.Start 方法中，该方法采用了”延续传递风格”(continuation passing style)。异步转换的核心算法就是将原始方法在 await 边界处分割成若干代码块：</p><ul><li>第一个代码块：从方法开始到第一个 await 之间的代码</li><li>第二个代码块：从第一个 await 到第二个 await 之间的代码</li><li>第三个代码块：从第二个 await 到第三个 await 或方法结束的代码 以此类推</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1 of the generated state machine:</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(_companyId)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException();</span><br><span class="line">_initializeMapIfNeededTask = @this.InitializeMapIfNeeded();</span><br></pre></td></tr></table></figure><p>每个被 await 的任务现在都变成了状态机的一个字段，而 Start 方法会将自己注册为这些任务的延续（continuation）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_state = State.Step1;</span><br><span class="line">_initializeMapIfNeededTask.ContinueWith(_ =&gt; Start());</span><br></pre></td></tr></table></figure><p>随后，当任务完成时，Start方法会被回调，并通过检查_state字段来确定当前执行阶段。接着，状态机会判断任务是成功完成、被取消还是出现异常。如果是成功完成的情况，状态机就会继续执行下一个代码块。当所有操作都完成后，状态机会设置TaskCompletionSource<T>实例的结果值，此时从GetStockPricesForAsync返回的任务状态就会变更为已完成。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The code between first await and the rest of the method</span></span><br><span class="line"> </span><br><span class="line">@this._stockPrices.TryGetValue(_companyId, <span class="keyword">out</span> <span class="keyword">var</span> result);</span><br><span class="line">_tcs.SetResult(result); <span class="comment">// The caller gets the result back</span></span><br></pre></td></tr></table></figure><p>这种”实现方式”存在几个严重缺陷：</p><ul><li>大量堆内存分配：<ul><li>状态机实例需要1次内存分配</li><li>TaskCompletionSource<T>需要1次分配</li><li>TaskCompletionSource<T>内部任务需要1次分配, 按照GPT的说法<code>TaskCompletionSource&lt;decimal&gt;</code>内部会自动创建一个<code>Task&lt;decimal&gt;</code> 实例（通过其 .Task 属性访问）</li><li>延续委托(delegate)需要1次分配, 指的应该是<code>_initializeMapIfNeededTask.ContinueWith(_ =&gt; Start());</code></li></ul></li><li>缺少”热路径优化”：<br>当被等待的任务已经完成时，完全没有必要创建延续委托</li><li>可扩展性不足：<br>实现与Task类紧密耦合，导致无法用于其他场景，例如：<ul><li>等待非Task类型</li><li>返回非Task/Task<T>类型</li></ul></li></ul><p>下面我们就来看一下上述提到的缺陷在真正的异步机制中是如何被解决的.</p><h1 id="异步机制"><a href="#异步机制" class="headerlink" title="异步机制"></a>异步机制</h1><p>编译器执行异步方法转换的整个过程, 其实已经和上面我们手动实现的方式十分接近了. 为了得到预期的行为, 编译器依赖于以下的类型:</p><ul><li>对于一个异步方法的生成的状态机, 其行为会像栈帧一样, 并且该状态机包含原始异步方法中的全部逻辑</li><li><code>AsyncTaskMethodBuilder&lt;T&gt;</code>持有完成的task（与 TaskCompletionSource<T> 类型非常相似）, 并且管理状态机的转换.</li><li><code>TaskAwaiter&lt;T&gt;</code>负责包装task, 并在需要时调度其延续</li><li><code>MoveNetRunner</code>负责在正确的执行上下文中调用<code>IAsyncStateMachine.MoveNext</code>方法</li></ul><p>生成的状态机在Debug模式下是一个类, 在Release模式下则是一个struct. 其他的类型(除了<code>MoveNextRunner</code>类)在BCL中均被定义为了struct.</p><p>编译器生成的状态机类型名称通常类似于<code>&lt;YourMethodNameAsync&gt;d_1</code>, 为了避免名称冲突, 生成的名字中包含了一些无效的标识符字符, 这些字符无法被用户直接定义或引用. 但是为了简化说明, 在后续的所有示例中, 我们还是将使用有效的标识符来替换掉<code>&lt;</code>、<code>&gt;</code>、<code>_</code>这些字符, 并且使用更容易理解的名字.</p><h1 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h1><p>原始的异步方法会创建一个状态机实例, 用捕获的状态（如果方法非静态，则包括 this 指针）初始化该实例, 通过传递状态机实例的引用并调用<code>AsyncTaskMethodBuilder&lt;T&gt;.Start</code>来启动执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AsyncStateMachine(typeof(_GetStockPriceForAsync_d__1))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">decimal</span>&gt; <span class="title">GetStockPriceFor</span>(<span class="params"><span class="built_in">string</span> companyId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _GetStockPriceForAsync_d__1 _GetStockPriceFor_d__;</span><br><span class="line">    _GetStockPriceFor_d__.__this = <span class="keyword">this</span>;</span><br><span class="line">    _GetStockPriceFor_d__.companyId = companyId;</span><br><span class="line">    _GetStockPriceFor_d__.__builder = AsyncTaskMethodBuilder&lt;<span class="built_in">decimal</span>&gt;.Create();</span><br><span class="line">    _GetStockPriceFor_d__.__state = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> __t__builder = _GetStockPriceFor_d__.__builder;</span><br><span class="line">    __t__builder.Start&lt;_GetStockPriceForAsync_d__1&gt;(<span class="keyword">ref</span> _GetStockPriceFor_d__);</span><br><span class="line">    <span class="keyword">return</span> _GetStockPriceFor_d__.__builder.Task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递引用是一个重要的优化, 因为一个状态机往往是相对大的结构(大于100bytes), 因此传递引用会避免冗余拷贝.<br>状态机代码如下:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> _GetStockPriceForAsync_d__1 : IAsyncStateMachine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> StockPrices __this;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> companyId;</span><br><span class="line">    <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="built_in">decimal</span>&gt; __builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> __state;</span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter __task1Awaiter;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">decimal</span> result;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TaskAwaiter awaiter;</span><br><span class="line">            <span class="keyword">if</span> (__state != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// State 1 of the generated state machine:</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(companyId))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException();</span><br><span class="line"> </span><br><span class="line">                awaiter = __this.InitializeLocalStoreIfNeededAsync().GetAwaiter();</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Hot path optimization: if the task is completed,</span></span><br><span class="line">                <span class="comment">// the state machine automatically moves to the next step</span></span><br><span class="line">                <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">                &#123;</span><br><span class="line">                    __state = <span class="number">0</span>;</span><br><span class="line">                    __task1Awaiter = awaiter;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// The following call will eventually cause boxing of the state machine.</span></span><br><span class="line">                    __builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                awaiter = __task1Awaiter;</span><br><span class="line">                __task1Awaiter = <span class="literal">default</span>(TaskAwaiter);</span><br><span class="line">                __state = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// GetResult returns void, but it&#x27;ll throw if the awaited task failed.</span></span><br><span class="line">            <span class="comment">// This exception is catched later and changes the resulting task.</span></span><br><span class="line">            awaiter.GetResult();</span><br><span class="line">            __this._stocks.TryGetValue(companyId, <span class="keyword">out</span> result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Final state: failure</span></span><br><span class="line">            __state = <span class="number">-2</span>;</span><br><span class="line">            __builder.SetException(exception);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Final state: success</span></span><br><span class="line">        __state = <span class="number">-2</span>;</span><br><span class="line">        __builder.SetResult(result);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">    &#123;</span><br><span class="line">        __builder.SetStateMachine(stateMachine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成的状态机代码看起来比较复杂, 但是本质上, 它和我们手写的那一版的代码是十分相似的.<br>即使两个版本十分相似, 但是还是有一些重要的不同的.</p><ol><li>“Hot Path” 优化</li></ol><p>不像我们原生的方式, 生成的状态机知道一个被awaited的task可能已经完成了<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awaiter = __this.InitializeLocalStoreIfNeededAsync().GetAwaiter();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Hot path optimization: if the task is completed,</span></span><br><span class="line"><span class="comment">// the state machine automatically moves to the next step</span></span><br><span class="line"><span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Irrelevant stuff</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The following call will eventually cause boxing of the state machine.</span></span><br><span class="line">    __builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果这个被await的task已经完成了(无论成功与否), 状态机会向前直行下一步<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetResult returns void, but it&#x27;ll throw if the awaited task failed.</span></span><br><span class="line"><span class="comment">// This exception is catched later and changes the resulting task.</span></span><br><span class="line">awaiter.GetResult();</span><br><span class="line">__this._stocks.TryGetValue(companyId, <span class="keyword">out</span> result);</span><br></pre></td></tr></table></figure></p><p>这就意味着, 如果所有awaited的task都已经完成了, 整个状态机将只会停留在栈上. 一个异步方法甚至在今天如果所有awaited的task都已经完成或者同步完成了, 那么这个异步方法是可以只会造成很小的内存开销的. 仅剩的开销只是这个task本身.</p><ol><li>错误处理</li></ol><p>当前逻辑并未专门处理任务处于故障状态或已取消状态的情况。状态机通过调用awaiter.GetResult()方法，当任务被取消时将抛出TaskCancelledException，若任务失败则抛出其他异常。这种设计十分优雅，因为GetResult()在错误处理机制上与task.Wait()或task.Result有本质区别。</p><p>无论是task.Wait()还是task.Result，即便任务因单一异常导致失败，它们都会抛出AggregateException。这背后的逻辑很简单：任务不仅可能代表通常只有单一故障的IO操作，也可能是并行计算的结果。后者可能产生多个错误，而AggregateException正是为聚合所有错误而设计。</p><p>但<code>async/await</code>模式专为异步操作设计，这类操作通常最多只会产生一个错误。因此语言设计者认为，若<code>awaiter.GetResult()</code>能对AggregateException进行解包并仅抛出首个异常，将更符合使用场景。这一设计并非完美，我们将在后续文章中看到这种抽象方案可能存在的漏洞。</p><p>异步状态机只是整个拼图的一部分。要完整理解其运作机制，我们还需了解状态机实例如何与<code>TaskAwaiter&lt;T&gt;</code>和<code>AsyncTaskMethodBuilder&lt;T&gt;</code>进行交互。</p><h1 id="这些模块是如何被联系到一起的呢"><a href="#这些模块是如何被联系到一起的呢" class="headerlink" title="这些模块是如何被联系到一起的呢?"></a>这些模块是如何被联系到一起的呢?</h1><p><a href="https://devblogs.microsoft.com/wp-content/uploads/sites/31/2019/06/Async_sequence_state_machine_thumb.png"></a></p><p>图表看似过于复杂，但每个组件都经过精心设计且扮演着重要角色。最有趣的协作发生在等待的任务尚未完成时（图中用棕色矩形标记）：</p><p>状态机注册任务延续</p><ul><li>状态机调用 <code>__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this)</code>，将自身注册为任务的延续。</li><li><code>AsyncTaskMethodBuilder</code> 确保任务完成后调用 <code>IAsyncStateMachine.MoveNext</code> 方法(译注:这句话的意思是说, 只要你, 更准确地说这段代码是编译器生成的, 调用了<code>AwaitUnsafeOnCompleted</code>接口, 那么编译器就能保证任务完成后会调用<code>IAsyncStateMachine.MoveNext</code>方法了)：<ul><li>捕获当前 执行上下文（ExecutionContext），创建一个 MoveNextRunner 实例，将其与当前状态机实例关联。</li><li>从<code>MoveNextRunner.Run</code>创建一个 Action 委托，用于在捕获的执行上下文中推进状态机。调用 TaskAwaiter.UnsafeOnCompleted(action)，将上述 Action 委托调度为等待任务的延续(译注: 可以去看一下C#源码中的<code>MoveNextRunner</code>和<code>AsyncMethodBuilderCore</code>的实现, 其中清晰地展示了如何捕获当前执行上下文、将<code>IAsyncStateMachine.MoveNext</code>方法和执行上下文一起包装进<code>MoveNextRunner.Run</code>生成的Action中)。<br>当等待的任务完成时，注册的回调（Action 委托）被触发，状态机继续执行异步方法的下一段代码块。</li></ul></li></ul><p>这张时序图中<code>AsyncTaskMethodBuilder</code>的<code>Start</code>方法的具体实现在上面编译器生成的代码中体现, 笔者把这部分代码贴到下面:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>Initiates the builder&#x27;s execution with the associated state machine.<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;TStateMachine&quot;&gt;</span>Specifies the type of the state machine.<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;stateMachine&quot;&gt;</span>The state machine instance, passed by reference.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line">[<span class="meta">DebuggerStepThrough</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>&lt;<span class="title">TStateMachine</span>&gt;(<span class="params"><span class="keyword">ref</span> TStateMachine stateMachine</span>) <span class="keyword">where</span> TStateMachine : IAsyncStateMachine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See comment on AsyncMethodBuilderCore.Start</span></span><br><span class="line">    <span class="comment">// AsyncMethodBuilderCore.Start(ref stateMachine);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stateMachine == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">    Contract.EndContractBlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the MoveNext method within a copy-on-write ExecutionContext scope.</span></span><br><span class="line">    <span class="comment">// This allows us to undo any ExecutionContext changes made in MoveNext,</span></span><br><span class="line">    <span class="comment">// so that they won&#x27;t &quot;leak&quot; out of the first await.</span></span><br><span class="line"></span><br><span class="line">    ExecutionContextSwitcher ecs = <span class="literal">default</span>(ExecutionContextSwitcher);</span><br><span class="line">    RuntimeHelpers.PrepareConstrainedRegions();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        ExecutionContext.EstablishCopyOnWriteScope(<span class="keyword">ref</span> ecs);</span><br><span class="line">        stateMachine.MoveNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        ecs.Undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是调用了状态机的MoveNext方法, 然后回到编译器为我们生成的代码中, 在状态机的MoveNext方法里, 调用了<code>__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);</code>我们看一下<code>AsyncTaskMethodBuilder</code>中的<code>AwaitUnsafeOnCompleted</code>的具体实现:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Schedules the specified state machine to be pushed forward when the specified awaiter completes.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;TAwaiter&quot;&gt;</span>Specifies the type of the awaiter.<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;TStateMachine&quot;&gt;</span>Specifies the type of the state machine.<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;awaiter&quot;&gt;</span>The awaiter.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;stateMachine&quot;&gt;</span>The state machine.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment">// 状态机调用 `__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this)`，将自身注册为任务的延续。</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AwaitUnsafeOnCompleted</span>&lt;<span class="title">TAwaiter</span>, <span class="title">TStateMachine</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ref</span> TAwaiter awaiter, <span class="keyword">ref</span> TStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TAwaiter : ICriticalNotifyCompletion</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TStateMachine : IAsyncStateMachine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 捕获当前 执行上下文（ExecutionContext），创建一个 MoveNextRunner 实例，将其与当前状态机实例关联。</span></span><br><span class="line">        AsyncMethodBuilderCore.MoveNextRunner runnerToInitialize = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> continuation = m_coreState.GetCompletionAction(AsyncCausalityTracer.LoggingOn ? <span class="keyword">this</span>.Task : <span class="literal">null</span>, <span class="keyword">ref</span> runnerToInitialize);</span><br><span class="line">        Contract.Assert(continuation != <span class="literal">null</span>, <span class="string">&quot;GetCompletionAction should always return a valid action.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is our first await, such that we&#x27;ve not yet boxed the state machine, do so now.</span></span><br><span class="line">        <span class="keyword">if</span> (m_coreState.m_stateMachine == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Force the Task to be initialized prior to the first suspending await so </span></span><br><span class="line">            <span class="comment">// that the original stack-based builder has a reference to the right Task.</span></span><br><span class="line">            <span class="keyword">var</span> builtTask = <span class="keyword">this</span>.Task;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box the state machine, then tell the boxed instance to call back into its own builder,</span></span><br><span class="line">            <span class="comment">// so we can cache the boxed reference.</span></span><br><span class="line">            Contract.Assert(!Object.ReferenceEquals((<span class="built_in">object</span>)stateMachine, (<span class="built_in">object</span>)stateMachine), <span class="string">&quot;Expected an unboxed state machine reference&quot;</span>);</span><br><span class="line">            <span class="comment">// 捕获当前 执行上下文（ExecutionContext），创建一个 MoveNextRunner 实例，将其与当前状态机实例关联。 这行代码内部将传入的stateMachine传递给MoveNextRunner的StateMachine</span></span><br><span class="line">            m_coreState.PostBoxInitialization(stateMachine, runnerToInitialize, builtTask);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 TaskAwaiter.UnsafeOnCompleted(action)，将上述 Action 委托调度为等待任务的延续。</span></span><br><span class="line">        awaiter.UnsafeOnCompleted(continuation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        AsyncMethodBuilderCore.ThrowAsync(e, targetContext: <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这下就和时序图中的内容对上了:<br><code>var continuation = m_coreState.GetCompletionAction(AsyncCausalityTracer.LoggingOn ? this.Task : null, ref runnerToInitialize);</code> 对应了时序图中<code>MoveNextRunner</code>部分.</p><p><code>awaiter.UnsafeOnCompleted(continuation);</code>对应了时序图中的<code>TaskAwaiter</code>部分, 当这个awaiter complete了之后, 就会触发传入的continuation, 也就是stateMachine的<code>MoveNext</code>. 整个流程就跑通了.</p><p>在我们示例中这个Awaiter是一个<code>TaskAwaiter</code>, 其<code>UnsafeOnCompleted</code>接口的实现如下:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>Schedules the continuation onto the <span class="doctag">&lt;see cref=&quot;System.Threading.Tasks.Task&quot;/&gt;</span> associated with this <span class="doctag">&lt;see cref=&quot;TaskAwaiter&quot;/&gt;</span>.<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;continuation&quot;&gt;</span>The action to invoke when the await operation completes.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;System.ArgumentNullException&quot;&gt;</span>The <span class="doctag">&lt;paramref name=&quot;continuation&quot;/&gt;</span> argument is null (Nothing in Visual Basic).<span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;System.InvalidOperationException&quot;&gt;</span>The awaiter was not properly initialized.<span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>This method is intended for compiler user rather than use directly in code.<span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">[<span class="meta">SecurityCritical</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnsafeOnCompleted</span>(<span class="params">Action continuation</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OnCompletedInternal(m_task, continuation, continueOnCapturedContext:<span class="literal">true</span>, flowExecutionContext:<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnCompletedInternal</span>(<span class="params">Task task, Action continuation, <span class="built_in">bool</span> continueOnCapturedContext, <span class="built_in">bool</span> flowExecutionContext</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (continuation == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;continuation&quot;</span>);</span><br><span class="line">    StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If TaskWait* ETW events are enabled, trace a beginning event for this await</span></span><br><span class="line">    <span class="comment">// and set up an ending event to be traced when the asynchronous await completes.</span></span><br><span class="line">    <span class="keyword">if</span> ( TplEtwProvider.Log.IsEnabled() || Task.s_asyncDebuggingEnabled)</span><br><span class="line">    &#123;</span><br><span class="line">        continuation = OutputWaitEtwEvents(task, continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the continuation onto the awaited task.</span></span><br><span class="line">    task.SetContinuationForAwait(continuation, continueOnCapturedContext, flowExecutionContext, <span class="keyword">ref</span> stackMark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C#源码看到这里其实就差不多了, 再往下看调用对于C#的使用者意义就不是很大了.</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>问题：什么是执行上下文？为何需要这种复杂的设计？<br>在同步代码中，每个线程通过 <code>线程本地存储（Thread-Local Storage）</code> 维护环境信息，例如：安全凭据（如 SecurityContext）区域性设置（如 CultureInfo）或者其他上下文数据（如 AsyncLocal<T> 的值）<br>当三个方法在同一个线程中依次调用时，这些信息会自动在方法间流动。但是对于异步方法来说就不再是这样了. 异步方法的每个代码段（如 await 前后的代码）可能在不同线程上执行，<code>线程本地存储(Thread-Local Storage)</code>失效。<br>因此执行上下文派上用场, 它为 一个逻辑控制流 维护上下文信息，即使该控制流跨越多线程。<br>例如，Task.Run 或 ThreadPool.QueueUserWorkItem 会 自动捕获调用线程的执行上下文，并将其与任务绑定。<br>当任务执行时，调度器（如 TaskScheduler）通过 ExecutionContext.Run 在捕获的上下文中运行委托，确保环境信息（如安全凭据）无缝延续。</p><p>通过下面这个例子理解一下:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Task <span class="title">ExecutionContextInAction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="keyword">new</span> AsyncLocal&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    li.Value = <span class="number">42</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Task.Run restores the execution context</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In Task.Run: &quot;</span> + li.Value);</span><br><span class="line">    &#125;).ContinueWith(_ =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The continuation restores the execution context as well</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In Task.ContinueWith: &quot;</span> + li.Value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中, 执行上下文通过<code>Task.Run</code>流向了<code>Task.ContinueWith</code>. 因此上面这段代码的执行结果如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In Task.Run: 42</span><br><span class="line">In Task.ContinueWith: 42</span><br></pre></td></tr></table></figure></p><p>但是不是所有在BCL中的方法都会自动捕获并恢复执行上下文. 两个例外是: <code>TaskAwaiter&lt;T&gt;.UnsafeOnCompledte</code>和<code>AsyncMethodBuilder&lt;T&gt;.AwaitUnsafeOnComplete</code>. 这看起来十分奇怪, 语言设计者决定添加不安全的方法手动使用<code>AsyncMethodBuilder&lt;T&gt;</code>和<code>MoveNetRunner</code>而不是依赖于内建的类似<code>AwaitTaskContinuation</code>这样的机制驱动执行上下文, 猜测这是出于性能问题考虑或者是对现有实现的另一个妥协.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">ExecutionContextInAsyncMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="keyword">new</span> AsyncLocal&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    li.Value = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The context is implicitely captured. li.Value is 42</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After first await: &quot;</span> + li.Value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tsk2 = Task.Yield();</span><br><span class="line">    tsk2.GetAwaiter().UnsafeOnCompleted(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The context is not captured: li.Value is 0</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Inside UnsafeOnCompleted: &quot;</span> + li.Value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> tsk2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The context is captured: li.Value is 42</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After second await: &quot;</span> + li.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">After first await: 42</span><br><span class="line">Inside UnsafeOnCompleted: 0</span><br><span class="line">After second await: 42</span><br></pre></td></tr></table></figure></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li><p>异步方法（async）的底层行为与同步方法截然不同，其核心机制依赖于编译器生成的 状态机（State Machine）：</p></li><li><p>编译器会为每个异步方法生成一个独立的状态机，将原方法的全部逻辑转移至状态机中。 状态机负责跟踪执行进度（通过状态值）、挂起（await 时）与恢复（任务完成时）的逻辑流转。</p></li><li><p>对同步完成的深度优化. 若所有等待的任务（await 的任务）已同步完成（如缓存命中、内存计算等无阻塞操作），异步方法的性能开销极低，几乎与同步方法无异。<br>此优化避免了不必要的上下文切换或调度，是异步编程高性能的关键保障。<br>异步场景的复杂性</p></li><li><p>当等待的任务未完成（需异步等待）时，状态机依赖一系列辅助类型（如 AsyncTaskMethodBuilder<T>、TaskAwaiter<T>、MoveNextRunner 等）协作完成：</p><ul><li>注册任务延续（Continuation）。</li><li>维护执行上下文（ExecutionContext）。<br>跨线程调度时的状态安全流转。</li></ul></li></ul><p>通过SharpLab, 我们生成了本篇示例中所有的经编译器处理过的异步代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"><span class="keyword">using</span> System.Security;</span><br><span class="line"><span class="keyword">using</span> System.Security.Permissions;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">[<span class="meta">assembly: CompilationRelaxations(8)</span>]</span><br><span class="line">[<span class="meta">assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)</span>]</span><br><span class="line">[<span class="meta">assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue | DebuggableAttribute.DebuggingModes.DisableOptimizations)</span>]</span><br><span class="line">[<span class="meta">assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyVersion(<span class="string">&quot;0.0.0.0&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">module: UnverifiableCode</span>]</span><br><span class="line">[<span class="meta">module: RefSafetyRules(11)</span>]</span><br><span class="line"></span><br><span class="line">[<span class="meta">NullableContext(1)</span>]</span><br><span class="line">[<span class="meta">Nullable(0)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">StockPrices</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;<span class="title">GetStockPriceForAsync</span>&gt;<span class="title">d__1</span> : <span class="title">IAsyncStateMachine</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Nullable(0)</span>]</span><br><span class="line">        <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="built_in">decimal</span>&gt; &lt;&gt;t__builder;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Nullable(0)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> companyId;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Nullable(0)</span>]</span><br><span class="line">        <span class="keyword">public</span> StockPrices &lt;&gt;<span class="number">4</span>__this;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">decimal</span> &lt;result&gt;<span class="number">5</span>__1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TaskAwaiter &lt;&gt;u__1;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> num = &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">            <span class="built_in">decimal</span> result;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TaskAwaiter awaiter;</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = &lt;&gt;<span class="number">4</span>__this.InitializeMapIfNeededAsync().GetAwaiter();</span><br><span class="line">                    <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num = (&lt;&gt;<span class="number">1</span>__state = <span class="number">0</span>);</span><br><span class="line">                        &lt;&gt;u__1 = awaiter;</span><br><span class="line">                        &lt;GetStockPriceForAsync&gt;d__1 stateMachine = <span class="keyword">this</span>;</span><br><span class="line">                        &lt;&gt;t__builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> stateMachine);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = &lt;&gt;u__1;</span><br><span class="line">                    &lt;&gt;u__1 = <span class="literal">default</span>(TaskAwaiter);</span><br><span class="line">                    num = (&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                awaiter.GetResult();</span><br><span class="line">                &lt;&gt;<span class="number">4</span>__this._stockPrices.TryGetValue(companyId, <span class="keyword">out</span> &lt;result&gt;<span class="number">5</span>__1);</span><br><span class="line">                result = &lt;result&gt;<span class="number">5</span>__1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">            &#123;</span><br><span class="line">                &lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">                &lt;&gt;t__builder.SetException(exception);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">            &lt;&gt;t__builder.SetResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in MoveNext</span></span><br><span class="line">            <span class="keyword">this</span>.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStateMachine</span>(<span class="params">IAsyncStateMachine stateMachine</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine</span></span><br><span class="line">            <span class="keyword">this</span>.SetStateMachine(stateMachine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;<span class="title">InitializeMapIfNeededAsync</span>&gt;<span class="title">d__2</span> : <span class="title">IAsyncStateMachine</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> AsyncTaskMethodBuilder &lt;&gt;t__builder;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Nullable(0)</span>]</span><br><span class="line">        <span class="keyword">public</span> StockPrices &lt;&gt;<span class="number">4</span>__this;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TaskAwaiter &lt;&gt;u__1;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> num = &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TaskAwaiter awaiter;</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = &lt;&gt;u__1;</span><br><span class="line">                    &lt;&gt;u__1 = <span class="literal">default</span>(TaskAwaiter);</span><br><span class="line">                    num = (&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">goto</span> IL_007c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (&lt;&gt;<span class="number">4</span>__this._stockPrices == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = Task.Delay(<span class="number">42</span>).GetAwaiter();</span><br><span class="line">                    <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num = (&lt;&gt;<span class="number">1</span>__state = <span class="number">0</span>);</span><br><span class="line">                        &lt;&gt;u__1 = awaiter;</span><br><span class="line">                        &lt;InitializeMapIfNeededAsync&gt;d__2 stateMachine = <span class="keyword">this</span>;</span><br><span class="line">                        &lt;&gt;t__builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> stateMachine);</span><br><span class="line">                        <span class="comment">// 从这里返回回去干嘛了呢?</span></span><br><span class="line">                        <span class="comment">// 程序会继续执行下面的语句</span></span><br><span class="line">                        <span class="comment">// Task(Awaiter)何时结束、如何调度都是TaskScheduler做的, 我们没有太多权限干预 我们能做的只是</span></span><br><span class="line">                        <span class="comment">// 告诉Task 等你的任务完成之后 你需要调用stateMachiner的MoveNext方法</span></span><br><span class="line">                        <span class="comment">// 如果我要实现自己的类似ETTask的功能, 我希望我能自己决定如何调度这些ETTask, 要不然实现自己的ETTask的意义就没有了.</span></span><br><span class="line">                        <span class="comment">// C#中异步操作到这里就已经揭示地比较清楚了, 只是Task的调度目前对我们来说还是黑盒, 最好它也只是黑盒</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> IL_007c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">goto</span> end_IL_0007;</span><br><span class="line">                IL_007c:</span><br><span class="line">                awaiter.GetResult();</span><br><span class="line">                StockPrices stockPrices = &lt;&gt;<span class="number">4</span>__this;</span><br><span class="line">                Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">decimal</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">decimal</span>&gt;();</span><br><span class="line">                dictionary.Add(<span class="string">&quot;MSFT&quot;</span>, <span class="number">42</span>m);</span><br><span class="line">                stockPrices._stockPrices = dictionary;</span><br><span class="line">                end_IL_0007:;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">            &#123;</span><br><span class="line">                &lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">                &lt;&gt;t__builder.SetException(exception);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">            &lt;&gt;t__builder.SetResult();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in MoveNext</span></span><br><span class="line">            <span class="keyword">this</span>.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStateMachine</span>(<span class="params">IAsyncStateMachine stateMachine</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine</span></span><br><span class="line">            <span class="keyword">this</span>.SetStateMachine(stateMachine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">decimal</span>&gt; _stockPrices;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AsyncStateMachine(typeof(&lt;GetStockPriceForAsync&gt;d__1))</span>]</span><br><span class="line">    [<span class="meta">DebuggerStepThrough</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">decimal</span>&gt; <span class="title">GetStockPriceForAsync</span>(<span class="params"><span class="built_in">string</span> companyId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        &lt;GetStockPriceForAsync&gt;d__1 stateMachine = <span class="keyword">new</span> &lt;GetStockPriceForAsync&gt;d__1();</span><br><span class="line">        stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder&lt;<span class="built_in">decimal</span>&gt;.Create();</span><br><span class="line">        stateMachine.&lt;&gt;<span class="number">4</span>__this = <span class="keyword">this</span>;</span><br><span class="line">        stateMachine.companyId = companyId;</span><br><span class="line">        stateMachine.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">        stateMachine.&lt;&gt;t__builder.Start(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">        <span class="keyword">return</span> stateMachine.&lt;&gt;t__builder.Task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AsyncStateMachine(typeof(&lt;InitializeMapIfNeededAsync&gt;d__2))</span>]</span><br><span class="line">    [<span class="meta">DebuggerStepThrough</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Task <span class="title">InitializeMapIfNeededAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        &lt;InitializeMapIfNeededAsync&gt;d__2 stateMachine = <span class="keyword">new</span> &lt;InitializeMapIfNeededAsync&gt;d__2();</span><br><span class="line">        stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create();</span><br><span class="line">        stateMachine.&lt;&gt;<span class="number">4</span>__this = <span class="keyword">this</span>;</span><br><span class="line">        stateMachine.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">        stateMachine.&lt;&gt;t__builder.Start(<span class="keyword">ref</span> stateMachine); <span class="comment">// 这里面会第一次调用StateMachine的MoveNext方法</span></span><br><span class="line">        <span class="keyword">return</span> stateMachine.&lt;&gt;t__builder.Task; <span class="comment">// 会立刻返回Task回去 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于异步的历史&quot;&gt;&lt;a href=&quot;#关于异步的历史&quot; class=&quot;headerlink&quot; title=&quot;关于异步的历史&quot;&gt;&lt;/a&gt;关于异步的历史&lt;/h1&gt;&lt;p&gt;C#开发者在第一次接触异步的概念, 应该是通过Task类型. Task是在&lt;code&gt;.Net 4.</summary>
      
    
    
    
    <category term="C#" scheme="https://soincredible.github.io/categories/C/"/>
    
    
    <category term="异步" scheme="https://soincredible.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>精细化实验策略下一种多策略交叉的美术、动效框架的实现</title>
    <link href="https://soincredible.github.io/posts/4bbdbff1/"/>
    <id>https://soincredible.github.io/posts/4bbdbff1/</id>
    <published>2025-05-01T15:07:44.000Z</published>
    <updated>2025-05-07T03:12:56.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔者对精细化实验的定义"><a href="#笔者对精细化实验的定义" class="headerlink" title="笔者对精细化实验的定义"></a>笔者对精细化实验的定义</h1><p>当游戏要新增或改动一个功能时, 如果开发者不能确其会对用户体验造成什么影响, 就会用做实验的方式将功能发布到线上, 即将用户分为对照组和实验组, 看两组用户的数据表现, 来判断该功能的好坏. 如果实验组数据好于对照组, 则应用实验组, 反之应用对照组. 不论应用哪一组, 没有被应用的那一组的硬编码就可以删除掉, 因此实验组与对照组逻辑的代码只是会临时插入到项目中, 只要实验应用了之后把非应用实验分支的代码删干净, 长期下来是不会对整个项目代码结构有什么影响. 但是我们团队在按照上述模式推进了一段时间之后发现了这种模式存在问题, 同一个版本上线的多个实验之间存在交叉, 且会对单个实验的结果产生影响, 而且有的实验短期内是实验组的数据好, 而长期又变成了对照组的数据好. 因此, 我们认为之前对实验数据的结论不准确, 我们决定将一段周期内最早的那个版本的项目状态定义为<strong>基线组</strong>, 在这一周期内的每个版本会上线的实验都不会应用, 而是会一直在线上跑, 随着实验越开越多, 实验之间的交叉问题越来越严重, 又因为这些实验的分支代码不会删除, 代码也会变得越来越难以维护, 上述这种在一段周期上线大量不会应用实验, 且希望每个实验都能交叉, 在一段周期后会形成上百、上千条实验分支的实验, 就是<strong>精细化实验</strong>, 对应的, 我们团队就需要一套能够管理精细化实验的框架.</p><h1 id="精细化框架的实现思路"><a href="#精细化框架的实现思路" class="headerlink" title="精细化框架的实现思路"></a>精细化框架的实现思路</h1><p>每个实验能够交叉, 是十分美好的愿景. 但是, 在实际开发中我们发现, 经常会有互为互斥关系的实验存在, 比如两个实验同时对模块A做了改动, 或者实验一影响模块ABC, 实验二影响模块ABD, 这种情况是不可避免的, 因此, 精细化框架要做的事情, 不仅仅是驱动这些实验, 还要制定一套规范, 处理实验之间的冲突问题. </p><p>本篇博客笔者会以UI换皮实验和动效换皮实验为例子, 阐述UI框架、动效播放框架的实现思路, 以及这些框架和精细化框架的协同过程. </p><h2 id="从ABTest框架说起"><a href="#从ABTest框架说起" class="headerlink" title="从ABTest框架说起"></a>从ABTest框架说起</h2><p>我们最初使用的AB测试系统十分简陋, AB测系统在启动时从磁盘上加载上来所有的AB实验信息, 根据设备的uid, 判断一个用户该表现为对照组还是实验组是根据用户使用设备的uid, 我们在后台配置一个实验的时候, 有多少个实验组就会生成几个“桶”, 这些桶里面装的是用户设备的uid, 用户设备启动游戏的时候, 程序能够知道当前设备在哪个桶里, 但是在某一个桶里并不意味着就一定表现为这个桶所对应的实验组, 还有其他的限制条件, 比如安装版本必须大于某一个版本或者必须是新用户, 或者必须是某一国家地区的等等. 总之, 业务层只需要把它们关系的实验字段传入, 就能够拿到当前设备对应实验所在的实验组是哪一个. </p><h2 id="精细化实验模块登场"><a href="#精细化实验模块登场" class="headerlink" title="精细化实验模块登场"></a>精细化实验模块登场</h2><p>精细化实验要做的, 就是把ABTest框架和业务层解耦, 作为两者之间的桥梁. 当你想让两个模块解耦时, 最直接的方式就是在两个模块通讯的接口处增加桥接层, 有了这层桥接, ABTest中庞大的数据不至于一下子涌向业务层, 而是在精细化实验层整合、处理, 精细化实验层会把ABTest中影响同一个业务的实验们按照人为定义的规则进行整合、冲突处理, 然后将结果转换成对应业务能够识别的格式——精细化实验层需要和每一个具体的业务定义一套协议, 这套协议能够描述, 经过多个实验的多重影响, 该业务最终的表现效果是怎样的. 我们计划使用Json作为这些实验配置的载体:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;1024&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;uiTest&quot;,</span><br><span class="line">        &quot;experimentSceneType&quot;: &quot;UIStyle&quot;, </span><br><span class="line">        &quot;experimentParam&quot;: &#123;</span><br><span class="line">            &quot;group1&quot;: [</span><br><span class="line">                [</span><br><span class="line">                    &quot;homePage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;playPage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;resultPage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;settingPage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ]</span><br><span class="line">            ],</span><br><span class="line">            &quot;group2&quot;: [</span><br><span class="line">                [</span><br><span class="line">                    &quot;homePage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;playPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;resultPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;settingPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">     &quot;1025&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;uiTest2&quot;,</span><br><span class="line">        &quot;experimentSceneType&quot;: &quot;UIStyle&quot;, </span><br><span class="line">        &quot;experimentParam&quot;: &#123;</span><br><span class="line">            &quot;group1&quot;: [</span><br><span class="line">                [</span><br><span class="line">                    &quot;homePage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;playPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;resultPage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;settingPage&quot;,</span><br><span class="line">                    4</span><br><span class="line">                ]</span><br><span class="line">            ],</span><br><span class="line">            &quot;group2&quot;: [</span><br><span class="line">                [</span><br><span class="line">                    &quot;homePage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;playPage&quot;,</span><br><span class="line">                    3</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;resultPage&quot;,</span><br><span class="line">                    5</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;settingPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><br>对上述Json格式做一下说明, 最外层的数字代表实验ID, <code>name</code>是实验名, <code>experimentSceneType</code>是实验场景, <code>experimentParam</code>能够描述实验场景下的实验内容, <code>group</code>代表实验分组, 不同实验场景下<code>group</code>字段下的结构不一样, 在<code>UIStyle</code>实验场景下是一个列表, 每个元素代表一个UI, 和该UI使用的<code>styleId</code>.</p><p>程序启动时必定加载上面两个实验, 并命中其中一个实验组, 而这两个实验是互斥的, 因此会在精细化实验层进行处理. 具体的处理规则, 则需要和策划团队一起制定, 硬编码进精细化实验模块中, 等业务场景足够丰富的时候, 也许可以从中提取出一套规则来支持配置. 不过这就不在本篇博客要讨论的范畴内了. 总之, 经过精细化层的处理之后, UIStyle实验场景会得到一组类似group字段内的列表, 这里面存储了所有UI的styleId, UIManager侧维护着每个UI每个styleId的映射关系. 有精细化层传来的参数, UIManager就可以给每个UI设置运行时styleId了. </p><p>我们设计的实验表格如下:</p><h2 id="UI框架的配表"><a href="#UI框架的配表" class="headerlink" title="UI框架的配表"></a>UI框架的配表</h2><h2 id="音频框架配表"><a href="#音频框架配表" class="headerlink" title="音频框架配表"></a>音频框架配表</h2><h2 id="动效配表"><a href="#动效配表" class="headerlink" title="动效配表"></a>动效配表</h2><h2 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;笔者对精细化实验的定义&quot;&gt;&lt;a href=&quot;#笔者对精细化实验的定义&quot; class=&quot;headerlink&quot; title=&quot;笔者对精细化实验的定义&quot;&gt;&lt;/a&gt;笔者对精细化实验的定义&lt;/h1&gt;&lt;p&gt;当游戏要新增或改动一个功能时, 如果开发者不能确其会对用户体验造成什</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>时势:周期波动下的国家、社会和个人</title>
    <link href="https://soincredible.github.io/posts/1cb37a62/"/>
    <id>https://soincredible.github.io/posts/1cb37a62/</id>
    <published>2025-04-29T05:58:00.000Z</published>
    <updated>2025-05-07T03:12:56.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日本失落的三十年"><a href="#日本失落的三十年" class="headerlink" title="日本失落的三十年"></a>日本失落的三十年</h1><p>日本财团</p><p>广场协议</p><p>国债</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;日本失落的三十年&quot;&gt;&lt;a href=&quot;#日本失落的三十年&quot; class=&quot;headerlink&quot; title=&quot;日本失落的三十年&quot;&gt;&lt;/a&gt;日本失落的三十年&lt;/h1&gt;&lt;p&gt;日本财团&lt;/p&gt;
&lt;p&gt;广场协议&lt;/p&gt;
&lt;p&gt;国债&lt;/p&gt;
</summary>
      
    
    
    
    <category term="读万卷书" scheme="https://soincredible.github.io/categories/%E8%AF%BB%E4%B8%87%E5%8D%B7%E4%B9%A6/"/>
    
    
    <category term="读书笔记" scheme="https://soincredible.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>对C#中类型转换和拆装箱的思考</title>
    <link href="https://soincredible.github.io/posts/fad28a7c/"/>
    <id>https://soincredible.github.io/posts/fad28a7c/</id>
    <published>2025-04-26T03:18:44.000Z</published>
    <updated>2025-06-23T11:09:10.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型转换的开销来自哪里"><a href="#类型转换的开销来自哪里" class="headerlink" title="类型转换的开销来自哪里?"></a>类型转换的开销来自哪里?</h1><p>类型转换在时间和空间上都会造成开销, 因为类型转换C#编译器会生成额外的类型转换处理代码, 导致代码文件的体积变大. 既然有额外的IL代码生成则就需要有额外的时间去执行. 如果类型转换中涉及到装拆箱操作, 则还会对运行时内存产生影响.</p><ul><li>CLR会生成额外IL代码执行类型转换是否合法的判断逻辑, 这部分开销是不可避免的, 即便开发者笃定类型转换必定合法. 不过这部分开销的影响并不大. 如果类型转换判定为不合法, 则需要额外的开销来处理异常, 我们通常会有两种类型转换的方式, 两种转换方式不合法的处理的开销不同:<ul><li>使用类型强转, 即<code>var a = (someType)b</code>形式, 这种方式在转换不合法的时候会抛出异常, 开销较大.</li><li>使用<code>as</code>操作符,即<code>var a = b as someType</code>, 这种方式在转换不合法的时候会将a字段设置为<code>null</code>,开销小. 更推荐使用这种方式.<br>不过如果你真的笃定类型转换不会出错, 那么以上这两种类型转换的方式其实影响不大.</li></ul></li><li>拆箱装箱造成的开销, 请记住这句话:<strong>装箱拆箱一定是类型转换造成的, 但是类型转换不一定会导致装箱拆箱</strong> 装拆箱详解请继续往下看.</li></ul><h1 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h1><p>值类型创建在栈上, 堆类型创建在堆上 这句话是不完全对的, 更准确的描述是: 引用类型一定创建在堆上, 值类型既可以创建在堆上, 也可以创建在栈上, 值类型创建在栈还是堆上取决于它所在的容器: 如果值类型是引用类型的一个成员字段, 则该值类型创建在堆上, 如果该值类型是一个局部变量(临时变量)或者是一个是另外一个值类型的字段成员的话, 则创建在堆上.</p><h1 id="装箱拆箱的开销来自哪里"><a href="#装箱拆箱的开销来自哪里" class="headerlink" title="装箱拆箱的开销来自哪里"></a>装箱拆箱的开销来自哪里</h1><p><strong>装箱过程发生了什么</strong></p><ol><li>在托管堆中分配内存, 分配的内存量是值类型各字段所需的内存量, 还要加上托管堆所有对象都有的两个额外成员(类型对象指针和同步块索引)所需的内存量</li><li>值类型的字段复制到新分配的堆内存</li><li>返回对象地址. 现在该地址是对象引用; 值类型成了引用类型</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>拆箱过程发生了什么</strong><br>请反复阅读并理解这句话: <strong>拆箱不是直接将装箱过程倒过来, 拆箱过程本身不会复制任何类型, 但是拆箱过后往往跟随着一次字段的复制.</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object obj = 10; //装箱</span><br><span class="line"></span><br><span class="line">int a = (int)b // 拆箱 + 字段的复制</span><br></pre></td></tr></table></figure><br><code>(int)b</code>部分完成了拆箱操作, <code>int a =</code>部分完成了字段复制操作, 我们在写代码的时候很自然而然地会这么写. </p><p>另外，值类型装箱后是不能改变它的值的，装箱后的值具有恒定性（Immutable）的特点，如果想给引用类型的变量赋予新的值，那就需要再堆上另开辟新的内存空间，一旦一个值类型被装箱，它的值就没有办法改变了. 看下面的代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct ValueType</span><br><span class="line">&#123;</span><br><span class="line">    public int Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void SomeFunc()</span><br><span class="line">&#123;</span><br><span class="line">    var value = new ValueType</span><br><span class="line">    &#123;</span><br><span class="line">        Value = 100</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    object vv = value;</span><br><span class="line">    </span><br><span class="line">    ((ValueType)vv).Value = 200; // 这里会报错Cannot modify struct member when accessed struct is not classified as a variable</span><br><span class="line"></span><br><span class="line">    var vvv = ((ValueType)vv); // 不会报错</span><br><span class="line">    vvv.Value = 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到, 如果只是进行拆箱操作, 我们无法对拆箱后的字段做任何修改, 并报错提示拆箱后的值成员并没有分类为变量, 我们必须将拆箱后的数据复制给一个值类型变量, 在这个变量上进行修改, 不过这个变量是拆箱数据的拷贝, 拆箱的数据没有任何关系. 所以上面才说<strong>拆箱过后往往跟随着一次字段的复制</strong></p><h1 id="反复地拆装箱"><a href="#反复地拆装箱" class="headerlink" title="反复地拆装箱"></a>反复地拆装箱</h1><p>反复地拆装箱会产生额外的IL代码, 增加代码体积. 更大的问题是, 额外的装箱步骤会在托管堆中分配额外的对象, 将来必须对其进行垃圾回收. 拆装箱的滥用会严重影响程序的性能和内存消耗.<br>如果我们想修改装箱后的值类型的内容, 虽然笔者想不出实际开发中会有这种场景, 我们就必须先将其拆箱, 接着复制给一个值类型变量, 修改值类型变量的内容, 将值类型变量装箱, 最后把指向原来装箱值类型在堆上地址的引用指向的地址改为指向新的值类型变量装箱后所在堆上的地址. 那么原来那一个被装箱的值类型在堆上占据的内容空间就废弃了, 在未来需要进行垃圾回收. 这也就是为什么装箱拆箱会引起GC。</p><h1 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h1><p>在实际写代码的过程中, 拆装箱问题并不常见, 因为大部分开发者想都不想只会把class传来传去, 而且我们肯定不会闲得声明一个object类型的字段, 却用一个值类型的数据给它赋值. 所以类型转换中主要的性能开销<strong>在于CLR会生成额外IL代码执行类型转换是否合法的判断逻辑</strong>(程序员一般情况下还是可以保证类型转换是合法的). </p><h1 id="其他要注意的点"><a href="#其他要注意的点" class="headerlink" title="其他要注意的点"></a>其他要注意的点</h1><p><strong>类型检查中要注意的点</strong><br>使用<code>is</code>操作符和<code>.GetType()</code>接口都可以做类型检查, 但是两者的开销是不同的, 按照GPT的说法, <code>is</code>操作符的性能开销要小于<code>.GetType()</code>的开销:</p><ul><li>使用<code>is</code>操作符, C#编译器生成直接的类型检查指令(isinst IL指令), 无需触发完整的类型元数据加载. <code>is</code>操作符会利用类型继承关系进行快速判断, 无需获取完整的Type对象, 值类型优化: 如果转换后的类型是值类型, is会避免装箱, 前提是obj是值类型且类型兼容</li><li>使用<code>.GetType()</code>时, 会触发完整类型元数据加载, 需要访问对象的Type对象, 涉及元数据查询<br>精确类型比较: GetTypE()返回的是对象的实际运行时类型, 与typeof(MyType)比较时,只有当obj的运行时类型完全等于MyType时才返回true, <code>.GetType()</code>是虚方法调用, 需经过虚方法表查找.</li></ul><p>当然, <code>.GetType</code>也有其用武之处, 因为在有些场景下确实是需要精确查找的, 继承关系A-&gt;B-&gt;C, A是基类, 如果传入的实例是C, 使用<code>is B</code>返回的结果是true, 而使用<code>.GetType() == typeof(B)</code> 返回的是false. 实际开发中大部分场景下<code>is</code>操作符就足够完成需求了.</p><p><strong>typeof、GetType()、is 和 as 这四种类型判断操作的开销对比</strong><br>| 操作      | 开销来源                         | 适用场景                 | 示例代码                              |<br>| ————- | ———————————————— | ———————————— | ——————————————————- |<br>| typeof(T) | ⚡️ 编译时静态解析（零运行时开销） | 编译时已知类型           | if (type == typeof(MyClass))          |<br>| is        | ⚡️ 单次类型检查（无转换）         | 安全类型检查             | if (obj is MyClass)                   |<br>| as        | ⚡️ 单次类型检查 + 返回转换结果    | 安全类型转换             | var x = obj as MyClass;               |<br>| GetType() | ⚠️ 访问对象类型句柄 + 元数据查找  | 需获取对象实际运行时类型 | if (obj.GetType() == typeof(MyClass)) |</p><p><strong>值类型、引用类型与闭包</strong></p><p>因为值类型的生命周期会随着其作用域的结束而释放掉, 但是引用类型不会, 引用类型释放掉的只是指向堆上内存位置的指针而已. 本来笔者计划使用闭包的方式把两种类型带出其各自的作用域, 不过实操下来, 两种类型里面的数据都是正常读取的. 据GPT说值类型的闭包是将数据复制了一份传入到了闭包中, 因此在原值类型数据生命周期外数据能正确读取, 而引用类型则是在其生命周期结束之后, 真正的数据还都存放在堆上呢根本就没释放掉呢, 因此可以正确读取, 不过笔者个人猜测, 引用类型本身(或者叫创建在线程栈上指向堆中数据的指针)在生命周期结束后其实也被释放掉了, 在闭包中也是传入了这个引用类型本身的一份拷贝而已. 但是笔者在这里就不深究了.</p><h1 id="更优雅的类型转换"><a href="#更优雅的类型转换" class="headerlink" title="更优雅的类型转换"></a>更优雅的类型转换</h1><p>按照GPT的说法, 泛型是一种能够规避类型转换、且保证类型安全的双赢方法, 泛型的类型转换并不是在运行时做的, 而是在编译时编译器静默地进行了类型转换, 因此泛型在运行时是没有额外开销的. </p><p>下面看两组代码的对比:<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUILogic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnShow</span>(<span class="params"><span class="built_in">object</span> data</span>)</span>; <span class="comment">// 数据用 object 传递</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnClose</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非泛型基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseEUI</span> : <span class="title">MonoBehaviour</span>, <span class="title">IUILogic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnShow</span>(<span class="params"><span class="built_in">object</span> data</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnClose</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体 UI 类（需手动转换数据）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayPage</span> : <span class="title">BaseEUI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnShow</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> showData = (PlayPageShowData)data; <span class="comment">// 运行时转换</span></span><br><span class="line">        <span class="comment">// 实际逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnClose</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UI 管理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIMgr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIMgr Instance &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> UIMgr();</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;Type, BaseEUI&gt; _uiInstances = <span class="keyword">new</span> Dictionary&lt;Type, BaseEUI&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowUI</span>(<span class="params">Type uiType, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_uiInstances.TryGetValue(uiType, <span class="keyword">out</span> <span class="keyword">var</span> ui))</span><br><span class="line">        &#123;</span><br><span class="line">            ui.OnShow(data); <span class="comment">// 非泛型调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = Resources.Load(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> go = Object.Instantiate(obj) <span class="keyword">as</span> GameObject;</span><br><span class="line">            ui = go.AddComponent(uiType) <span class="keyword">as</span> BaseEUI;</span><br><span class="line">            ui.OnShow(data);</span><br><span class="line">            _uiInstances.Add(uiType, ui);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="keyword">var</span> param = <span class="keyword">new</span> PlayPageShowData();</span><br><span class="line">UIMgr.Instance.ShowUI(<span class="keyword">typeof</span>(PlayPage), param); <span class="comment">// 需显式传递 Type</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型接口（类型安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUILogic</span>&lt;<span class="title">TUIShowData</span>&gt; <span class="keyword">where</span> <span class="title">TUIShowData</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnShow</span>(<span class="params">TUIShowData data</span>)</span>; <span class="comment">// 明确数据类型</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnClose</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseEUI</span>&lt;<span class="title">TUIShowData</span>&gt; : <span class="title">MonoBehaviour</span>, <span class="title">IUILogic</span>&lt;<span class="title">TUIShowData</span>&gt; </span><br><span class="line">    <span class="keyword">where</span> <span class="title">TUIShowData</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnShow</span>(<span class="params">TUIShowData data</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnClose</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体 UI 类（无需手动转换数据）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayPage</span> : <span class="title">BaseEUI</span>&lt;<span class="title">PlayPageShowData</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnShow</span>(<span class="params">PlayPageShowData data</span>) <span class="comment">// 直接使用具体类型</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接访问 data 的字段，无需类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnClose</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UI 管理器（泛型版）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIMgr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIMgr Instance &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> UIMgr();</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;Type, <span class="built_in">object</span>&gt; _uiInstances = <span class="keyword">new</span> Dictionary&lt;Type, <span class="built_in">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型方法：类型安全且无装箱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowUI</span>&lt;<span class="title">TUI</span>, <span class="title">TUIShowData</span>&gt;(<span class="params">TUIShowData data</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TUI : BaseEUI&lt;TUIShowData&gt;, <span class="keyword">new</span>()</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TUIShowData : <span class="keyword">struct</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_uiInstances.TryGetValue(<span class="keyword">typeof</span>(TUI), <span class="keyword">out</span> <span class="keyword">var</span> ui))</span><br><span class="line">        &#123;</span><br><span class="line">            ((IUILogic&lt;TUIShowData&gt;)ui).OnShow(data); <span class="comment">// 需一次接口转换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = Resources.Load(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> go = Object.Instantiate(obj) <span class="keyword">as</span> GameObject;</span><br><span class="line">            <span class="keyword">var</span> uiLogic = go.AddComponent&lt;TUI&gt;();</span><br><span class="line">            uiLogic.OnShow(data);</span><br><span class="line">            _uiInstances.Add(<span class="keyword">typeof</span>(TUI), uiLogic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="keyword">var</span> param = <span class="keyword">new</span> PlayPageShowData();</span><br><span class="line">UIMgr.Instance.ShowUI&lt;PlayPage, PlayPageShowData&gt;(param); <span class="comment">// 编译时类型检查</span></span><br></pre></td></tr></table></figure><p>对比上面两组代码, 非泛型方式打开一个UI要经过4次类型转换, 而且还有装箱和拆箱的风险; 而泛型版本打开一个UI只需要进行2次类型转换 </p><p><strong>非泛型和泛型方案对比</strong><br>| 特性         | 非泛型方案                        | 泛型方案 (IUILogic<T>)           |<br>| —————— | ————————————————- | ———————————————— |<br>| 类型安全     | ❌ 运行时可能 InvalidCastException | ✔️ 编译时检查                     |<br>| 数据传递效率 | ⚠️ 值类型会装箱（struct → object） | ✔️ 无装箱（直接传递 struct）      |<br>| 代码复杂度   | ✔️ 更简单                          | ❌ 需要泛型约束和类型参数         |<br>| 性能开销     | ⚠️ 装箱/拆箱 + 类型转换            | ⚡️ 无额外开销（除可能的 as 转换） |<br>| 扩展性       | ❌ 新增 UI 需手动维护数据类型      | ✔️ 自动适配不同 TUIShowData       |</p><p><strong>注意</strong> 泛型确实是一种十分优雅的类型转换方式, 但是妄图使用泛型替代所有的类型转换是不可能的. 泛型在一定程度上破坏了突破了面向对象的继承结构的限制, 但是你想要在面向对象的编程语言中编写非面向对象的代码是十分困难的, 看上面UIMgr代码的例子你就知道了, UIMgr作为所有UI的管理者, 它管理者一类UI, 为了实现管理一组对象的效果, 这一组对象在UIMgr的视角下必须是同一种类的, 也就是它们要具有同一父类, 因此即便泛型打破了继承关系, 但是在管理一组对象这种领域还是无法替代普通类型转换, 所以在由上层管理到底层执行之间有一个不可避免的类型转换, 不过这一次类型转换是必定成功的, 这是由上层管理和底层具体执行视角不同导致的.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因此, 滥用object作为接口的参数并不是一种优雅的方式, 类型转换在实际开发中不可避免, 但我们还是可以通过泛型等方式尽可能地减少类型转换的开销.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类型转换的开销来自哪里&quot;&gt;&lt;a href=&quot;#类型转换的开销来自哪里&quot; class=&quot;headerlink&quot; title=&quot;类型转换的开销来自哪里?&quot;&gt;&lt;/a&gt;类型转换的开销来自哪里?&lt;/h1&gt;&lt;p&gt;类型转换在时间和空间上都会造成开销, 因为类型转换C#编译器会生</summary>
      
    
    
    
    
    <category term="C#" scheme="https://soincredible.github.io/tags/C/"/>
    
  </entry>
  
</feed>
