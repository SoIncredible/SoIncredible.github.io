<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EddieLee</title>
  
  <subtitle>to infinity and beyond✨🛸.</subtitle>
  <link href="https://soincredible.github.io/atom.xml" rel="self"/>
  
  <link href="https://soincredible.github.io/"/>
  <updated>2025-09-09T10:30:20.761Z</updated>
  <id>https://soincredible.github.io/</id>
  
  <author>
    <name>Eddie Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>迷思——是要过程还是要结果</title>
    <link href="https://soincredible.github.io/posts/8518d869/"/>
    <id>https://soincredible.github.io/posts/8518d869/</id>
    <published>2025-09-09T02:02:54.000Z</published>
    <updated>2025-09-09T10:30:20.761Z</updated>
    
    <content type="html"><![CDATA[<p>要做一个transform从某点移动到某点的效果, 两种方式, 第一种在Update里面每帧去更新位置, 第二种使用DoTween, 给一个起始点, 给一个终点就完事了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要做一个transform从某点移动到某点的效果, 两种方式, 第一种在Update里面每帧去更新位置, 第二种使用DoTween, 给一个起始点, 给一个终点就完事了.&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityEditorUITookit开发</title>
    <link href="https://soincredible.github.io/posts/7c88a7b8/"/>
    <id>https://soincredible.github.io/posts/7c88a7b8/</id>
    <published>2025-09-09T01:05:50.000Z</published>
    <updated>2025-09-09T10:30:20.759Z</updated>
    
    
    
    
    <category term="UnityEditor" scheme="https://soincredible.github.io/categories/UnityEditor/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityEditorIMGUI开发</title>
    <link href="https://soincredible.github.io/posts/7f55a4b3/"/>
    <id>https://soincredible.github.io/posts/7f55a4b3/</id>
    <published>2025-09-09T01:05:37.000Z</published>
    <updated>2025-09-09T10:30:20.758Z</updated>
    
    <content type="html"><![CDATA[<h1>何为IMGUI</h1><p>IMGUI即Immediate Mode GUI</p><h1>一些疑问</h1><h1>1. Editor GUI（OnGUI）模式</h1><p>Unity 的 Editor 扩展（EditorWindow、Editor、CustomInspector 等）使用的是<strong>Immediate Mode GUI</strong>，即 IMGUI。</p><ul><li>在 IMGUI（OnGUI）里，每次要显示控件都必须重新绘制一遍，所以 _textArea = GUILayout.TextArea(_textArea); 这种写法是<strong>必要的</strong>，也是推荐的。</li><li>只要你需要文本输入框能保存、显示、修改文本，就必须把每帧 OnGUI 返回的最新字符串赋值回来，否者控件无法响应用户输入。</li><li>OnGUI 并不是像 Update 那样只做逻辑运算，它是“每帧重画+同步最新值”的机制。</li></ul><p><strong>这个流程虽然“每帧赋值”，但实际上是：</strong></p><ul><li>用户输入 → 控件更新，控件的内容通过 TextArea 的返回值传递出来。</li><li>你用一个变量保存起来，下次再传进去，循环往复。</li></ul><p>实际上，这样的“赋值”并不是真正“每帧都做了无用功”，它不涉及复杂逻辑，只是保证数据同步，很轻量。</p><hr><h1>2. UGUI（UnityEngine.UI）模式</h1><p>UGUI 使用的是<strong>Retained Mode GUI</strong>，即“保持式 GUI”。</p><ul><li>UGUI（比如 InputField）是 GameObject，上面挂着脚本组件（InputField、Text 等），值都是挂在对象内部，“实时绑定、事件驱动”，只有当用户输入发生变化时才会更新内部值。</li><li>你<strong>不需要每帧赋值 InputField.text</strong>，通常只在初始化或特定逻辑中赋值，或者通过事件（onValueChanged）处理输入变化。</li></ul><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InputField input;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    input.onValueChanged.AddListener(OnInputChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnInputChanged</span>(<span class="params"><span class="built_in">string</span> newText</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里只在用户输入改变时触发一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每帧 Update 时 <strong>并不需要 assign</strong>。</p><hr><h2 id="3-为什么-Editor-要这样写？">3. 为什么 Editor 要这样写？</h2><p>因为 IMGUI 的机制只能你自己手动接管“可视控件内容”和“你的变量”，<br>每帧同步其实只是“状态同步”，并不是做大量冗余逻辑。所以<strong>IMGUI风格就该每帧赋值；UGUI则用事件驱动。</strong></p><hr><h2 id="4-有没有“更优雅”的写法？">4. 有没有“更优雅”的写法？</h2><ul><li>在 Editor .OnGUI，没有更优雅的方案，这就是官方推荐用法（<strong>赋值其实就1条指令，性能压力很小</strong>）。</li><li>如果你只想提高代码“观感”，可以包装一层函数，但底层逻辑还是要你管数据同步。</li><li>UGUI、EditorGUILayout、Runtime GUI，没有更优雅方案，因为机制不同。</li></ul><hr><h2 id="结论">结论</h2><ul><li><strong>Editor IMGUI 就要每帧赋值，这是机制要求。</strong></li><li><strong>UGUI/InputField等只在需要时赋值，不必每帧。</strong></li><li><strong>赋值本身只是同步文本状态，不是无用功，也不影响性能。</strong></li></ul><hr><h3 id="延伸阅读">延伸阅读</h3><p>官方说明：<br><a href="https://docs.unity3d.com/Manual/UI-system-compare.html">IMGUI Vs Retained Mode</a><br><a href="https://docs.unity3d.com/ScriptReference/GUILayout.TextArea.html">Editor scripting: Immediate/Retained GUI</a></p><hr><p><strong>简明一句话：IMGUI 每帧赋值是必要的，就是它的机制设计；UGUI只在需要转移数据时才赋值，不是每帧。</strong></p><h1>GUI都有哪些控件</h1><ul><li>Button 在用户点击按钮**（按下并抬起）**时，GUILayout.Button 返回 true</li><li>RepeatButton 在用户按住按钮时，GUILayout.RepeatButton 每帧都返回 true。</li><li>Label</li><li>TextArea</li><li>Toggle</li><li>Box</li></ul><h1>GUIStyleState</h1><h1>GUIContent</h1><p>看一下源码就可以发现, 当我们调用<code>GUI.Label(&quot;Hello&quot;)</code>这样的接口时, GUI内部都是将传入的字符串专成一个GUIContent. 这是一种便捷的写法</p><p>GUIContent决定渲染什么<br>GUIStyle决定如何渲染</p><h1>GUIStyle</h1><p>Style</p><p>有一些代表状态的字段 这些状态是给固定的控件使用的.</p><ul><li>active Button</li><li>onHover</li></ul><p>GUIStyle像是一个上下文, 或者状态机里面的Blackboard, 所有的UI控件, 能够呈现的样式, GUIStyle中的字段全部包含, 一个UI控件能表现的效果所需要的字段, 只是GUIStyle的子集.</p><p>比如GUI.Label</p><h1>布局对齐有两种范畴</h1><p>第一是一个组件内 比如Box组件内部的Text和Icon 使用GUIStyle的alignment来对齐, 第二是整个Box组件在窗口中的对齐方式, 使用GUILayout.FlexibleSpace() + GUILayout.BeginHorizontal()来实现布局</p><h1>GUI、EditorGUI、GUILayout、EditorGUILayout、EditorGUIUtility、GUIUtility</h1><p>GUI附带的还有GUIGroup、GUIStyle等 EditorGUI好像没有?<br>在UnityEditor开发中下面这些类型都是可以用的<br><a href="https://docs.unity3d.com/ScriptReference/GUI.html">https://docs.unity3d.com/ScriptReference/GUI.html</a><br><a href="https://docs.unity3d.com/ScriptReference/GUIContent.html">https://docs.unity3d.com/ScriptReference/GUIContent.html</a><br><a href="https://docs.unity3d.com/ScriptReference/GUISkin.html">https://docs.unity3d.com/ScriptReference/GUISkin.html</a><br><a href="https://docs.unity3d.com/ScriptReference/GUIStyle.html">https://docs.unity3d.com/ScriptReference/GUIStyle.html</a><br><a href="https://docs.unity3d.com/ScriptReference/EditorGUI.html">https://docs.unity3d.com/ScriptReference/EditorGUI.html</a><br><a href="https://docs.unity3d.com/ScriptReference/EditorStyles.html">https://docs.unity3d.com/ScriptReference/EditorStyles.html</a></p><h1>EditorToolBar</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;何为IMGUI&lt;/h1&gt;
&lt;p&gt;IMGUI即Immediate Mode GUI&lt;/p&gt;
&lt;h1&gt;一些疑问&lt;/h1&gt;
&lt;h1&gt;1. Editor GUI（OnGUI）模式&lt;/h1&gt;
&lt;p&gt;Unity 的 Editor 扩展（EditorWindow、Editor、Cust</summary>
      
    
    
    
    <category term="UnityEditor" scheme="https://soincredible.github.io/categories/UnityEditor/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityEditor下异步的设计</title>
    <link href="https://soincredible.github.io/posts/1302a241/"/>
    <id>https://soincredible.github.io/posts/1302a241/</id>
    <published>2025-09-09T00:27:17.000Z</published>
    <updated>2025-09-09T10:30:20.760Z</updated>
    
    <content type="html"><![CDATA[<p>参考框架: FigmaConvertToUnity、FindReference2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考框架: FigmaConvertToUnity、FindReference2&lt;/p&gt;
</summary>
      
    
    
    
    <category term="UnityEditor" scheme="https://soincredible.github.io/categories/UnityEditor/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity插件合集</title>
    <link href="https://soincredible.github.io/posts/3248703d/"/>
    <id>https://soincredible.github.io/posts/3248703d/</id>
    <published>2025-09-05T01:12:08.000Z</published>
    <updated>2025-09-05T01:49:03.509Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://assetstore.unity.com/packages/tools/utilities/vfolders-2-255470">vFolders 2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://assetstore.unity.com/packages/tools/utilities/vfolders-2-255470&quot;&gt;vFolders 2&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity渲染合集</title>
    <link href="https://soincredible.github.io/posts/b20b7f63/"/>
    <id>https://soincredible.github.io/posts/b20b7f63/</id>
    <published>2025-09-05T01:10:15.000Z</published>
    <updated>2025-09-05T01:43:31.410Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——日本经济洞察</title>
    <link href="https://soincredible.github.io/posts/1d74c8db/"/>
    <id>https://soincredible.github.io/posts/1d74c8db/</id>
    <published>2025-09-02T08:36:09.000Z</published>
    <updated>2025-09-09T06:17:13.868Z</updated>
    
    <content type="html"><![CDATA[<h1>1985年广场协议</h1><p>日本经济泡沫破裂发生在20世纪90年代, 自1975年石油危机之后日本进入高速发展.</p><h1>日本“窗边族”文化</h1><p>日本社会价值观与欧美不同, 企业是终生雇佣制度, 企业对于员工来说是第二个家, 因此企业裁员倒闭 不被日本主流价值观所接受</p><h1>日本政府为什么要保老员工 而放弃刚毕业大学生</h1><p>因为老员工身上背负着巨额的房贷, 如果让老员工失业, 银行将有大量的坏账, 现在企业端已经有太多爆雷了, 因此不能再让居民端出现问题, 否则日本银行业将尸骨无存</p><h1>住专公司问题</h1><h1>基于日本的历史 推测东大的历史轨迹 机遇在哪里? 以后的社会会是怎样的社会?</h1><h1>参考资料</h1><p><a href="https://weread.qq.com/web/reader/77d32440813aba4e2g01644a">以日为鉴</a><br><a href="">时势</a><br><a href="">大衰退 经济学圣杯</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1985年广场协议&lt;/h1&gt;
&lt;p&gt;日本经济泡沫破裂发生在20世纪90年代, 自1975年石油危机之后日本进入高速发展.&lt;/p&gt;
&lt;h1&gt;日本“窗边族”文化&lt;/h1&gt;
&lt;p&gt;日本社会价值观与欧美不同, 企业是终生雇佣制度, 企业对于员工来说是第二个家, 因此企业裁员倒闭 </summary>
      
    
    
    
    <category term="迷思" scheme="https://soincredible.github.io/categories/%E8%BF%B7%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>迷思——不要老是想着装逼</title>
    <link href="https://soincredible.github.io/posts/d649707a/"/>
    <id>https://soincredible.github.io/posts/d649707a/</id>
    <published>2025-09-02T07:30:36.000Z</published>
    <updated>2025-09-09T01:40:46.689Z</updated>
    
    <content type="html"><![CDATA[<h1>对近期工作的反思</h1><p>Figma Convert Unity插件, 明知道有说明文档, 却就是不看, 或者说到手一个插件或者某一个Unity库, 因为是自己不属于的领域, 就算没有说明文档, 也要先尽量去找说明文档, 而不是先去看代码</p><p>整个流程是<br>先看说明文档-&gt;根据说明文档实操-&gt;根据操作的流程以这条线为脉络看代码-&gt;抽象这个库的设计思路和架构-&gt;思考化为己用、考虑如何扩展.</p><p>这个流程不能变, 不论是在任何情况下都是这样, 要做的是要提高自己阅读文档、梳理代码的速度, 指导方针来自于《程序员超强大脑这本书》, 如果时间不紧急的话可以通过画UML图和时序图的方式熟悉代码, 如果时间紧急, 需要找一个更高效的方法.</p><h1>行动方针</h1><p>如果一个插件有说明文档, 先好好地看一遍说明文档, 不要一上来先看代码, 避免重复造轮子, 想要装逼, 占有欲很强, 希望自己修改过的代码就完全变成自己的. 这种思想不可取, 但目前我还没有找到能说服我的新思想.</p><h1>如何看Log</h1><p>不要觉得Log多, 出现问题的时候这些Log能帮你<br>看的不只是自己打的Log, 别人打的Log也会帮助你<br>每条Log中的每个数据都有其含义<br>通过看Log排查bug就像是当侦探 拼凑线索 还原案发现场.</p><h1>以微信营销平台上的配置为例子</h1><p>在获得新角色的时候, 会在本地截图, 不会用营销平台上配置的图片, 因此需要和后台定义一个标识, 当这个<br>但是由于config是引用类型, 如果一个玩家在一个Session内多次触发获得角色的分享, 那么在第一次分享之后, 这套配置中的图片就会被写入并覆盖, 导致和后端定义的标识被破坏了, 新的角色截图也不会被写入</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;对近期工作的反思&lt;/h1&gt;
&lt;p&gt;Figma Convert Unity插件, 明知道有说明文档, 却就是不看, 或者说到手一个插件或者某一个Unity库, 因为是自己不属于的领域, 就算没有说明文档, 也要先尽量去找说明文档, 而不是先去看代码&lt;/p&gt;
&lt;p&gt;整个流程是</summary>
      
    
    
    
    <category term="迷思" scheme="https://soincredible.github.io/categories/%E8%BF%B7%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>UnitySourceCode——bindings</title>
    <link href="https://soincredible.github.io/posts/958d72fd/"/>
    <id>https://soincredible.github.io/posts/958d72fd/</id>
    <published>2025-08-27T02:30:47.000Z</published>
    <updated>2025-08-27T02:31:28.955Z</updated>
    
    <content type="html"><![CDATA[<p>Unity中有一种<code>.bindings </code>格式的文件, 这类文件经过某种处理会转换为C#文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">C++RAW</span><br><span class="line"></span><br><span class="line">#include &quot;UnityPrefix.h&quot;</span><br><span class="line">#include &quot;Configuration/UnityConfigure.h&quot;</span><br><span class="line">#include &quot;Runtime/Mono/MonoBehaviour.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/Canvas.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/UIStructs.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/BatchGenerator.h&quot;</span><br><span class="line"></span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">#include &quot;Modules/Profiler/Public/ProfilerImpl.h&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">CSRAW</span><br><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using Object = UnityEngine.Object;</span><br><span class="line"></span><br><span class="line">namespace UnityEngine</span><br><span class="line">&#123;</span><br><span class="line">    ENUM RenderMode</span><br><span class="line">        ScreenSpaceOverlay = 0,</span><br><span class="line">        ScreenSpaceCamera = 1,</span><br><span class="line">        WorldSpace = 2</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    [Flags]</span><br><span class="line">    ENUM AdditionalCanvasShaderChannels</span><br><span class="line">        None = 0,</span><br><span class="line">        TexCoord1 = 1 &lt;&lt; 0,</span><br><span class="line">        TexCoord2 = 1 &lt;&lt; 1,</span><br><span class="line">        TexCoord3 = 1 &lt;&lt; 2,</span><br><span class="line">        Normal = 1 &lt;&lt; 3,</span><br><span class="line">        Tangent = 1 &lt;&lt; 4,</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    // CanvasRenderer is the C++ rendering backend for the UI system.</span><br><span class="line">    [RequireComponent(typeof(RectTransform))]</span><br><span class="line">    [NativeClass(&quot;UI::Canvas&quot;)]</span><br><span class="line">    CLASS Canvas : Behaviour</span><br><span class="line"></span><br><span class="line">        AUTO_PROP RenderMode renderMode GetRenderMode SetRenderMode</span><br><span class="line">        AUTO_PROP bool isRootCanvas GetIsRootCanvas</span><br><span class="line">        AUTO_PTR_PROP Camera worldCamera GetCamera SetCamera</span><br><span class="line">        AUTO_PROP Rect pixelRect GetPixelRect</span><br><span class="line">        AUTO_PROP float scaleFactor GetScaleFactor SetScaleFactor</span><br><span class="line">        AUTO_PROP float referencePixelsPerUnit GetReferencePixelsPerUnit SetReferencePixelsPerUnit</span><br><span class="line">        AUTO_PROP bool overridePixelPerfect GetOverridePixelPerfect SetOverridePixelPerfect</span><br><span class="line">        AUTO_PROP bool pixelPerfect GetPixelPerfect SetPixelPerfect</span><br><span class="line">        AUTO_PROP float planeDistance GetPlaneDistance SetPlaneDistance</span><br><span class="line"></span><br><span class="line">        AUTO_PROP int renderOrder GetRenderOrder</span><br><span class="line"></span><br><span class="line">        AUTO_PROP bool overrideSorting GetOverrideSorting SetOverrideSorting</span><br><span class="line">        AUTO_PROP int sortingOrder GetSortingOrder SetSortingOrder</span><br><span class="line">        AUTO_PROP int targetDisplay GetTargetDisplay SetTargetDisplay</span><br><span class="line"></span><br><span class="line">        OBSOLETE warning Setting normalizedSize via a int is not supported. Please use normalizedSortingGridSize</span><br><span class="line">        AUTO_PROP int sortingGridNormalizedSize GetSortingBucketNormalizedSize SetSortingBucketNormalizedSize</span><br><span class="line"></span><br><span class="line">        AUTO_PROP float normalizedSortingGridSize GetSortingBucketNormalizedSize SetSortingBucketNormalizedSize</span><br><span class="line"></span><br><span class="line">        AUTO_PROP int sortingLayerID GetSortingLayerID SetSortingLayerID</span><br><span class="line">        AUTO_PROP int cachedSortingLayerValue GetCachedSortingLayerValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AUTO_PROP AdditionalCanvasShaderChannels additionalShaderChannels GetAdditionalShaderChannels SetAdditionalShaderChannels</span><br><span class="line"></span><br><span class="line">        CUSTOM_PROP string sortingLayerName</span><br><span class="line">        &#123;</span><br><span class="line">            return scripting_string_new(self-&gt;GetSortingLayerName());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            self-&gt;SetSortingLayerName(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM_PROP Canvas rootCanvas</span><br><span class="line">        &#123;</span><br><span class="line">            UI::Canvas* root = self-&gt;GetRootCanvas();</span><br><span class="line">            return Scripting::ScriptingWrapperFor(root == NULL ? self : root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static Material GetDefaultCanvasMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetDefaultUIMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static Material GetETC1SupportedCanvasMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetETC1SupportedCanvasMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OBSOLETE warning Shared default material now used for text and general UI elements, call Canvas.GetDefaultCanvasMaterial()</span><br><span class="line">        CUSTOM static Material GetDefaultCanvasTextMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetDefaultUIMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CSRAW</span><br><span class="line">        public delegate void WillRenderCanvases();</span><br><span class="line">        public static event WillRenderCanvases willRenderCanvases;</span><br><span class="line">        [RequiredByNativeCode]</span><br><span class="line">        private static void SendWillRenderCanvases() &#123; if (willRenderCanvases != null) willRenderCanvases(); &#125;</span><br><span class="line">        public static void ForceUpdateCanvases() &#123; SendWillRenderCanvases(); &#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    CLASS UISystemProfilerApi</span><br><span class="line">        C++RAW</span><br><span class="line">        enum SampleType &#123; Layout, Render &#125;;</span><br><span class="line">        ENUM SampleType</span><br><span class="line">            Layout,</span><br><span class="line">            Render,</span><br><span class="line">        END</span><br><span class="line">        CUSTOM static public void BeginSample(SampleType type)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">            if (UnityProfilerPerThread::ms_InstanceTLS != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                ProfilerInformation&amp; profilerInfo = *profiler_get_info_for_name(type == Layout ? &quot;Layout&quot; : &quot;Render&quot;, type == Layout ? kProfilerUISystemLayout : kProfilerUISystemRender);</span><br><span class="line">                PROFILER_BEGIN(profilerInfo, NULL);</span><br><span class="line">            &#125;</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static public void EndSample(SampleType type)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">            if (UnityProfilerPerThread::ms_InstanceTLS != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                ProfilerInformation&amp; profilerInfo = *profiler_get_info_for_name(type == Layout ? &quot;Layout&quot; : &quot;Render&quot;, type == Layout ? kProfilerUISystemLayout : kProfilerUISystemRender);</span><br><span class="line">                PROFILER_END(profilerInfo);</span><br><span class="line">            &#125;</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static public void AddMarker(string name, Object obj)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER &amp;&amp; UNITY_EDITOR</span><br><span class="line">            InstanceID instanceID = InstanceID_None;</span><br><span class="line">            std::string nameStr(name);</span><br><span class="line">            if (!obj.IsNull() &amp;&amp; Thread::CurrentThreadIsMainThread())</span><br><span class="line">            &#123;</span><br><span class="line">                instanceID =  obj-&gt;GetInstanceID();</span><br><span class="line">                nameStr += &quot; &quot;;</span><br><span class="line">                nameStr += obj-&gt;GetName();</span><br><span class="line">            &#125;</span><br><span class="line">            UI::GetCanvasManager().AddMarker(nameStr.c_str(), instanceID);</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    CSRAW</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Unity中有一种&lt;code&gt;.bindings &lt;/code&gt;格式的文件, 这类文件经过某种处理会转换为C#文件&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnitySourceCode——Jobs</title>
    <link href="https://soincredible.github.io/posts/9e38ed66/"/>
    <id>https://soincredible.github.io/posts/9e38ed66/</id>
    <published>2025-08-27T02:30:03.000Z</published>
    <updated>2025-08-27T02:31:28.954Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——如何利用AI提升知识吸收和开发效率</title>
    <link href="https://soincredible.github.io/posts/79d0ad57/"/>
    <id>https://soincredible.github.io/posts/79d0ad57/</id>
    <published>2025-08-26T13:48:52.000Z</published>
    <updated>2025-09-09T01:40:46.690Z</updated>
    
    <content type="html"><![CDATA[<p>早些时间之前, 笔者尝试从零做一个RPG游戏, 现在要拾起来, 但是在整个过程中加入AI, 是用Cursor或者ChatGPT其实没那么重要.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;早些时间之前, 笔者尝试从零做一个RPG游戏, 现在要拾起来, 但是在整个过程中加入AI, 是用Cursor或者ChatGPT其实没那么重要.&lt;/p&gt;
</summary>
      
    
    
    
    <category term="迷思" scheme="https://soincredible.github.io/categories/%E8%BF%B7%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>资产清理工作流</title>
    <link href="https://soincredible.github.io/posts/bab9e6d9/"/>
    <id>https://soincredible.github.io/posts/bab9e6d9/</id>
    <published>2025-08-26T03:59:47.000Z</published>
    <updated>2025-08-28T12:10:56.096Z</updated>
    
    <content type="html"><![CDATA[<p>依赖YooAsset的BuildReport 查看那些资源被误打进了包内, 尝试将这些资源剔除掉<br>配合FR2插件</p><ol><li>清理底包资源(被标记为MainTag的资源)</li><li>清理包外资源, 加快Bundle构建流程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;依赖YooAsset的BuildReport 查看那些资源被误打进了包内, 尝试将这些资源剔除掉&lt;br&gt;
配合FR2插件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;清理底包资源(被标记为MainTag的资源)&lt;/li&gt;
&lt;li&gt;清理包外资源, 加快Bundle构建流程&lt;/li&gt;
&lt;/ol&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++合集</title>
    <link href="https://soincredible.github.io/posts/e78f9514/"/>
    <id>https://soincredible.github.io/posts/e78f9514/</id>
    <published>2025-08-23T08:21:10.000Z</published>
    <updated>2025-08-26T01:37:03.680Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/happenlee/p/13278640.html">奇特的递归模板模式 (Curiously Recurring Template Pattern) 是 C++ 的一种看起来很怪异的模板编程技巧</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/happenlee/p/13278640.html&quot;&gt;奇特的递归模板模式 (Curiously Recurring Template Pattern) 是 C++ 的一种看起来很怪异的模板编程技巧&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityRenderPipeline</title>
    <link href="https://soincredible.github.io/posts/d1e0d4f0/"/>
    <id>https://soincredible.github.io/posts/d1e0d4f0/</id>
    <published>2025-08-22T16:25:44.000Z</published>
    <updated>2025-08-26T01:37:03.681Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.html">看完Unity 官方Graphics文档</a></p><h1>Render中的概念</h1><ul><li><p>RenderPipeline</p></li><li><p>Graphics tiers</p></li><li><p>frustum culling</p></li><li><p>occlusion culling</p></li><li><p>reflection probe</p></li><li><p>rendering path</p></li></ul><h1>RenderPipeline就干三件事情</h1><p>剔除 分为视锥体提出(frustum culling)和遮挡剔除(occlusion culling)</p><p>Preventing wasted rendering operations can save on both CPU and GPU time. Unity’s built-in occlusion culling performs runtime calculations on the CPU, which can offset the CPU time that it saves. Occlusion culling is therefore most likely to result in performance improvements when a Project is GPU-bound due to overdraw. Unity官方文档中对于Occlusion Culling的叙述我没明白, 为什么GPU瓶颈的情况 通过使用OcclusionCulling操作可以提高性能? 那它说的Unity’s built-in occlusion culling performs runtime calculations on the CPU, which can offset the CPU time that it saves. 这句话又是什么意思?<br>非常好的问题！你引用的这段Unity官方文档确实点出了 occlusion culling 的一个核心权衡。我们来把它拆解清楚。</p><p>核心问题：为什么GPU瓶颈时，使用OC能提高性能？<br>简单回答：因为 OC从根本上解决的是“过度绘制（Overdraw）”问题，而过度绘制是GPU的主要负担之一。</p><p>让我们详细解释一下：</p><p>什么是过度绘制（Overdraw）？</p><p>它指的是GPU在同一帧中，对屏幕上的同一个像素进行了多次绘制。</p><p>例如，一堵墙前面有一棵树。当相机渲染时，GPU会先绘制远处的墙（像素颜色被设置为“墙”），然后绘制近处的树（像素颜色被覆盖为“树”）。对于被树挡住的墙的部分像素，GPU进行了两次绘制，但最终只有树的颜色是有效的。第一次绘制墙的操作就是“浪费”的渲染，即过度绘制。</p><p>GPU瓶颈与过度绘制的关系：</p><p>当你的游戏是 GPU瓶颈（GPU-Bound） 时，意味着每一帧的渲染速度主要受限于GPU的处理能力。GPU已经满负荷工作，而CPU还有空闲。</p><p>过度绘制会极大地增加GPU的工作量。如果场景复杂，一个像素被绘制5次、10次甚至更多，GPU就需要处理数倍于最终屏幕像素数量的计算（着色、光照、纹理采样等），这直接导致了帧率下降。</p><p>Occlusion Culling（遮挡剔除）如何解决这个问题？</p><p>OC的工作就是在CPU上预先判断：“从相机的视角看，哪些物体被其他物体完全挡住了（即不可见）？”</p><p>判断完成后，CPU会形成一个“最终可见物体列表”并交给GPU。</p><p>GPU只会渲染这个列表里的物体，而那些被完全挡住的物体（例如，房间外的物体、被墙挡住的家具等）根本不会进入渲染管线。</p><p>结果就是：GPU需要处理的物体数量大大减少，过度绘制被极大降低。 GPU的工作负担减轻了，帧率自然就上去了。这就是为什么在GPU瓶颈时，OC能带来显著的性能提升。</p><p>第二句话：“Unity’s built-in occlusion culling performs runtime calculations on the CPU, which can offset the CPU time that it saves.” 是什么意思？<br>这句话描述的是OC的成本或副作用。它意思是：</p><p>“Unity自带的遮挡剔除功能需要在运行时由CPU进行计算，这个计算本身会消耗CPU时间，从而可能抵消掉它（通过减少渲染）为CPU节省下来的时间。”</p><p>我们来分解一下：</p><p>“performs runtime calculations on the CPU”：OC不是一个简单的开关。它需要CPU每帧（或在一定频率下）进行视锥体剔除（Frustum Culling，剔除相机视野外的物体）和更复杂的遮挡剔除计算（使用预先烘焙的数据或运行时算法判断物体之间的遮挡关系）。这些计算是需要消耗CPU计算资源的。</p><p>“offset the CPU time that it saves”：</p><p>OC本来也能为CPU节省时间：因为CPU需要准备渲染数据并提交给GPU（称为Draw Call）。如果OC成功剔除了一半的物体，CPU需要准备和提交的Draw Call也就减少了一半，这部分工作是节省了的。</p><p>但是，进行OC计算本身也需要花费CPU时间。</p><p>如果 OC计算本身消耗的CPU时间 &gt; 因减少Draw Call而节省的CPU时间，那么总体上，CPU的负担反而加重了。</p><p>举个例子：<br>假设没有OC时，CPU一帧需要花 5ms 来提交所有Draw Call。<br>开启OC后：</p><p>CPU需要花 3ms 来执行OC计算。</p><p>由于OC剔除了很多物体，CPU现在只需要花 1ms 来提交剩下的Draw Call。</p><p>CPU总耗时 = 3ms + 1ms = 4ms。 这比之前的5ms要少，性能提升。</p><p>但换一个场景：</p><p>CPU执行复杂的OC计算花了 6ms。</p><p>剔除后，提交Draw Call花了 1ms。</p><p>CPU总耗时 = 6ms + 1ms = 7ms。 这比不开OC时的5ms更糟，性能下降。</p><p>总结与结论<br>对GPU的好处（核心价值）：OC通过减少渲染对象数量，直接降低了GPU的过度绘制，这在GPU瓶颈时效果极佳。</p><p>对CPU的双刃剑效应：OC会带来CPU的额外计算开销。它节省了提交Draw Call的时间，但增加了剔除计算的时间。</p><p>在CPU瓶颈（CPU-Bound）的项目中：如果OC计算本身很重，它很可能得不偿失，导致整体帧率下降。</p><p>在GPU瓶颈或CPU/GPU平衡的项目中：OC节省的GPU时间远大于它带来的CPU开销，从而大幅提升帧率。</p><p>因此，Unity文档的那段话是在教你如何正确地使用这个功能：</p><p>不要无脑地开启Occlusion Culling。你应该先使用Unity Profiler分析你的游戏，确定瓶颈到底是CPU还是GPU。如果主要是GPU瓶颈且由过度绘制引起，那么开启OC很可能带来收益。如果已经是CPU瓶颈了，开启OC可能会让情况恶化。</p><p>所以这是一个此消彼长的过程是吧<br>完全正确！这就是一个非常经典的“此消彼长”或者说“权衡（Trade-off）”的过程。</p><p>你用这个词来形容，非常精准地抓住了 occlusion culling 乃至很多游戏优化技术的核心思想。</p><p>我们可以把这个过程清晰地画出来：</p><img src="/posts/d1e0d4f0/deepseek_mermaid_20250822_5ebda0.png" class=""><p>就像上图展示的，这完全是一个系统性的平衡艺术。优化从来不是免费的，用一个地方的资源（CPU时间）去换取另一个地方的资源（GPU时间）。</p><p>成功的优化就是确保：</p><p>你付出的代价（CPU计算）小于你得到的收益（GPU时间减少）。</p><p>你换取的资源正好是系统最缺的那个（即缓解了系统的瓶颈）。</p><p>所以，Unity 官方文档的那段话，本质上就是在提醒你：不要盲目使用优化技术。一定要先分析（Profile），找到真正的瓶颈（Bottleneck），然后再有针对性地进行优化，否则很可能适得其反。</p><p>You can use occlusion culling to occlude Dynamic GameObjects, but Dynamic GameObjects cannot occlude other GameObjects. If your Project generates Scene geometry at runtime, then Unity’s built-in occlusion culling is not suitable for your Project. Dynamic Gameobject是什么 是我动态加载实例化的东西吗?<br>说得非常对！你的理解基本正确，但我们可以更精确地定义一下。</p><p>什么是 Dynamic GameObject（动态游戏对象）？<br>在Unity occlusion culling（遮挡剔除）的上下文中，Dynamic GameObject 主要指的是在运行时移动、旋转或缩放的物体，而不是指“动态加载实例化”这个动作。</p><p>更准确的区分如下：</p><p>静态遮挡物（Static Occluder）：</p><p>在场景中永远不会移动、旋转或缩放的物体。</p><p>你需要在其Inspector窗口中将 Occluder Static 复选框勾选。</p><p>作用：只有被标记为 Occluder Static 的物体才能在烘焙（Bake）时被计入遮挡数据，从而能够遮挡其他物体。</p><p>例子：场景中的地形、建筑、不会移动的墙壁、大型岩石等。</p><p>动态游戏对象（Dynamic GameObject）：</p><p>在运行时会移动、旋转或缩放的物体。</p><p>或者，即使它不移动，但也没有被标记为 Occluder Static。</p><p>作用（局限性）：</p><p>它可以被静态遮挡物遮挡（例如，一个移动的角色走到墙后面，会被墙遮挡而剔除）。</p><p>但它自身无法作为遮挡物去遮挡其他物体（例如，一辆移动的大卡车开过去，它无法遮挡它后面的房子或树，即使从相机角度看它确实挡住了）。</p><p>例子：玩家角色、敌人、NPC、可移动的车辆、可被拾取的物品、由代码实例化并会移动的对象等。</p><p>针对你提到的两种情况：<br>“是我动态加载实例化的东西吗？”</p><p>你动态实例化（Instantiate）出来的一个物体，如果它在生成后一动不动，并且你将其标记为了 Occluder Static，那么它可以作为遮挡物。（但这种情况很少见，因为通常静态物体直接放在场景里就好，没必要运行时实例化）。</p><p>你动态实例化出来的物体，如果会移动或者没有标记为Static，那它就是Dynamic GameObject。它只能被遮挡，不能遮挡别人。</p><p>“如果您的项目在运行时生成场景几何体，那么Unity的内置遮挡剔除不适合您的项目。”</p><p>这句话的意思是：如果你的游戏关卡、地形、房间布局等主要几何结构是在运行时随机生成或动态加载的（例如程序化生成的地牢、随机地图的沙盒游戏），那么就不适合使用Unity内置的烘焙式 occlusion culling。</p><p>原因：Unity的 occlusion culling 需要预先烘焙（Precompute/Bake）。烘焙过程会基于那些标记为 Occluder Static 的物体来计算它们之间的遮挡关系，并将结果保存成数据。运行时只是查询这些预计算的数据。</p><p>如果场景结构是运行时才确定的，那么就无法进行预先烘焙，这个系统也就失效了。</p><p>总结<br>对象类型能否移动？能否被遮挡？能否作为遮挡物？例子<br>静态遮挡物 (Occluder Static)不能可以（但没必要）可以地形、静态建筑<br>动态游戏对象 (Dynamic GameObject)可以可以不可以角色、车辆、子弹<br>所以，如果你的游戏有很多大型的、会移动的物体（比如巨型机器人、移动的堡垒），你希望它们也能遮挡其身后的东西，Unity内置的OC就无法满足需求了。这种情况下，开发者通常会寻求基于软件光栅化（Software Rasterization）的实时遮挡剔除系统（如Umbra、PVSporta等第三方解决方案，或Unity的Entitiy组件系统ECS下的一些新方法）。</p><p>运行时 动态加载实例化一些预制体出来 Unity也没有什么接口能让我在运行时给这些物体设置静态的操作吗?<br>非常好的问题！这触及了Unity静态系统的一个核心限制。</p><p>简单直接的回答是：没有。Unity 没有提供在运行时（Runtime）通过代码将 GameObject 设置为“静态”（包括 Occluder Static）并使其生效的接口。</p><p>详细解释<br>为什么不行？</p><p>烘焙（Baking）是一个编辑器（Editor-Time）过程：静态标记的真正意义在于，它告诉Unity的光照系统（GI）、遮挡剔除系统（Occlusion Culling） 和导航系统（Navigation） 等，这些物体是静止的，可以针对它们进行预计算。</p><p>这个预计算过程（我们常说的“Bake灯光”、“Bake Occlusion”）非常耗时，它需要分析场景中所有静态物体的几何关系、UV、材质属性等，并生成相应的数据（如光照贴图、遮挡数据、导航网格）。这个过程绝不可能在游戏运行时实时完成，否则会卡住游戏好几秒甚至几分钟。</p><p>gameObject.isStatic 属性存在，但它是“陷阱”<br>你确实能在代码中找到 gameObject.isStatic 这个属性，并且可以设置它。但是！</p><p>它只改变标识，不触发烘焙。你可以在运行时将一个物体 isStatic = true，但这只是一个“标签”。光照、遮挡等系统所使用的预计算数据是在编辑器阶段就生成好的，运行时不会因为你这个标记的改变而重新计算。</p><p>结果是无效的。你把它标记为静态，但它并不会因此就能遮挡其他物体，也不会参与全局光照。它的作用微乎其微，几乎只是为了查询。</p><p>运行时实例化的物体如何参与遮挡？<br>虽然不能成为“遮挡物”，但你动态实例化的物体仍然可以作为“被遮挡者”，这是自动的，无需任何设置。</p><p>流程是这样的：</p><p>你在编辑器烘焙Occlusion Data时，场景里那些标记为 Occluder Static 的墙壁、山体等生成了遮挡数据。</p><p>运行时，你实例化了一个角色（动态物体）。</p><p>Unity的摄像机每帧都会进行视锥体剔除和遮挡查询。</p><p>它会判断你这个角色的包围盒是否被那些预计算好的静态遮挡物挡住。</p><p>如果被挡住，Unity就不会渲染这个角色。</p><p>所以，动态物体享受到了被静态遮挡物剔除的好处，但它自己不能贡献遮挡。</p><p>替代方案与解决方案<br>如果你的项目确实需要在运行时动态生成关卡，并且希望这些新生成的墙体等能作为有效的遮挡物，你有几个选择：</p><p>使用第三方实时遮挡剔除解决方案：</p><p>例如 Umbra（很多3A大作在用）、PVS Studio 等。</p><p>它们的工作原理不同，通常基于软件光栅化等技术，在CPU上实时计算遮挡关系，不依赖预烘焙的数据，因此非常适合动态环境。但这些都是付费插件，并且需要一定的集成和学习成本。</p><p>自己实现简单的遮挡剔除：</p><p>对于简单需求，你可以自己写逻辑。例如：</p><p>距离剔除：如果物体离相机很远，直接隐藏。</p><p>手动区域管理（Room System）：将动态生成的关卡分成多个房间（Room），当相机在一个房间内时，只启用这个房间内的物体，禁用其他所有房间的物体。这是一种粗粒度的“遮挡”。</p><p>设计上的规避：</p><p>这是最常用的方法。既然知道动态生成的物体不能遮挡，就在设计关卡时避免出现“需要一个动态生成的大物体去遮挡大量其他动态物体”的情况。</p><p>确保主要的、大型的遮挡物（如外围城墙、主要建筑结构）是场景中预先放置好并烘焙好的静态物体。而动态生成的部分只是内部的可移动细节。</p><p>结论<br>你不能在运行时创建真正的“静态”物体。Unity的静态系统是一个为编辑器预计算服务的系统。</p><p>对于遮挡剔除：运行时实例化的物体只能是被遮挡者，无法成为遮挡物。</p><p>如果你的项目严重依赖运行时生成几何体并需要它们遮挡，你需要寻求不依赖预烘焙的实时剔除方案，而不是试图去设置静态标志。</p><p>那比如说 场景中有一个被标记为static的物体 我在运行时通过脚本获取到了这个物体 然后用代码去移动这个物体 会有什么问题吗?<br>千万不要这样做！ 这是一个非常错误的操作，会导致一系列问题，但Unity并不会阻止你这么做。</p><p>移动一个在编辑器中被标记为 Static 的物体，会导致“静态”系统的假设完全失效，从而引发各种渲染和逻辑错误。</p><p>会产生的问题：<br>渲染错误（最主要的问题）：</p><p>光照错误（Lighting Artifacts）：静态物体参与了全局光照（GI） 和光照贴图（Lightmapping） 的烘焙。光照贴图上的光线、阴影和反弹光信息都是基于该物体原始的位置、旋转和缩放计算并“烤”在纹理上的。如果你移动了物体，它的模型顶点和光照贴图上的信息就错位了，会导致奇怪的阴影、错误的光照甚至模型变黑。</p><p>遮挡剔除失效（Broken Occlusion Culling）：遮挡数据是基于物体静态时的位置预计算的。你移动它之后，它可能还在原地遮挡着实际上已经可见的物体，或者它本该在新位置遮挡物体却没能起到作用。这会导致本应被剔除的物体被渲染（性能下降） 或本应被渲染的物体被错误剔除（物体消失）。</p><p>性能问题：</p><p>虽然你移动了它，但Unity的许多系统（如GI、OC）仍然会把它当作静态物体来处理，使用那份已经失效的预计算数据。这会导致CPU和GPU在做无用功，甚至比直接使用一个动态物体的性能还要差。</p><p>导航系统问题（如果标记了 Navigation Static）：</p><p>如果这个静态物体还参与了导航网格（NavMesh）的烘焙，那么AI会依然认为它在旧的位置上，从而撞向空气墙（因为物体实际已经移走了）或者穿墙而过（因为物体移动到了一个原本可通行的区域）。</p><p>正确的做法是什么？<br>如果你需要一个物体在游戏开始时是静态的（参与烘焙），但运行时又需要移动它，你必须遵循以下流程：</p><p>在运行时取消其静态标记：在移动它之前，通过代码将其 isStatic 属性设置为 false。</p><p>通知相关系统更新：告诉Unity的各个系统，这个物体的状态已经改变了。</p><p>对于渲染器（Renderer）：通常需要强制刷新或重新计算一些数据，但在Unity中，简单地取消静态标记后，渲染器会将其视为动态物体，使用实时光照而不是光照贴图。这可能会导致视觉效果突变（例如从有烘焙光变到只有实时光）。</p><p>对于导航（Navigation）：如果你移动了一个曾经是导航静态的物体，你可能需要重新烘焙导航网格（NavMesh） 或使用 NavMesh Obstacle 组件来动态阻挡AI。运行时烘焙NavMesh是一个开销很大的操作，需要谨慎使用。</p><p>示例代码：</p><p>csharp<br>public class MoveStaticObject : MonoBehaviour<br>{<br>public GameObject staticObject; // 赋值那个静态物体<br>public Vector3 targetPosition;</p><pre><code>void Start()&#123;    // 1. 在移动前，取消它的静态标记！    staticObject.isStatic = false;    // 2. （可选但重要）通知渲染器等相关组件    // 例如，强制它使用实时光照，停止尝试使用光照贴图    var renderer = staticObject.GetComponent&lt;Renderer&gt;();    if (renderer != null)    &#123;        renderer.lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.BlendProbes; // 使用光照探针        // renderer.reflectionProbeUsage = ...; // 可能需要设置反射探针    &#125;    // 3. 现在可以移动它了    staticObject.transform.position = targetPosition;    // 注意：对于导航，处理起来更复杂，需要添加NavMeshObstacle或RebakeNavMesh。&#125;</code></pre><p>}<br>总结<br>静态标记是一个“契约”：你向Unity承诺这个物体在运行时永远不会变换（移动、旋转、缩放），Unity则通过耗时的预计算来为你优化光照和性能。</p><p>如果你在运行时打破了这份契约（移动了静态物体），Unity基于承诺所进行的优化就会全部出错。 因此，最佳实践是：任何需要在运行时变换的物体，都不要在编辑器里标记为 Static。 如果它最初是静态的，移动前务必先取消其静态标记。</p><p>Camera -&gt; DynamicA -&gt; DynamicB -&gt; Static C -&gt; Dynamic D -&gt; Static E 这个位置关系中, D 、E实际上是不会渲染的, 剩下的A B C 都渲染<br>非常好！你给出的这个例子非常经典，完美地说明了Unity遮挡剔除（Occlusion Culling）的工作原理。</p><p>你的理解是完全正确的。</p><p>在这个位置关系 Camera -&gt; DynamicA -&gt; DynamicB -&gt; Static C -&gt; Dynamic D -&gt; Static E 中，最终的渲染结果很可能是：Dynamic A, Dynamic B, Static C 被渲染，而 Dynamic D 和 Static E 不会被渲染。</p><p>原理逐步分析：<br>让我们一步步分析相机渲染时发生了什么：</p><p>视锥体剔除（Frustum Culling）：</p><p>首先，相机会进行视锥体剔除。我们假设所有物体（A, B, C, D, E）都在相机的视野范围内，所以这一步它们全部通过。</p><p>遮挡查询（Occlusion Query）：</p><p>接下来，Unity的遮挡剔除系统开始工作。它会使用在编辑器里预先烘焙好的遮挡数据（由 Static C 和 Static E 这些静态遮挡物生成）来判断物体之间的可见性。</p><p>它的判断逻辑是从近到远（或者按某种顺序），但核心是：如果一个物体被一个已知的、不透明的遮挡物完全挡住，它就会被剔除。</p><p>具体到你的例子：</p><p>Dynamic A：离相机最近，没有任何东西挡住它。（渲染）</p><p>Dynamic B：它可能在A的后面，但Dynamic物体不能作为遮挡物，所以系统会认为A没有挡住B。B是否被渲染取决于它有没有被静态遮挡物挡住。假设没有，（渲染）</p><p>Static C：它是一个强大的静态遮挡物。系统会检查它是否可见。因为前面的A和B都是动态物，不遮挡它，所以它是可见的。（渲染）</p><p>Dynamic D：系统会检查D的包围盒（Bounds）。由于 Static C 是一个有效的静态遮挡物，并且从相机视角看，D完全在C的后面，因此Unity会判定D被C完全遮挡。（剔除，不渲染）</p><p>Static E：系统同样会检查E的包围盒。它不仅在C的后面，还在D的后面。但判断遮挡时，只要有一个不透明的静态遮挡物（C）挡住了它，它就会被剔除。不需要关心它前面还有一个Dynamic D。（剔除，不渲染）</p><p>核心要点总结：<br>遮挡物的权威性：只有被标记为 Occluder Static 的物体（如你的C和E）才能在遮挡查询中起到遮挡作用。动态物体（A, B, D）即使看起来很大，也完全不会影响遮挡计算。</p><p>查询逻辑：遮挡查询并不关心物体之间的“父子关系”或“逻辑关系”，它只关心它们的世界坐标下的包围盒和从相机出发的射线是否被静态遮挡物阻断。</p><p>性能增益：正是因为这个机制，Static C 成功地将它身后的整个区域（包括D和E）都剔除了，为GPU节省了大量的渲染工作量（避免了overdraw）。这就是 occlusion culling 在GPU瓶颈场景中提升性能的关键。</p><p>所以，你的判断非常准确！这个例子清晰地展示了为何将重要的、大的场景结构标记为 Occluder Static 是如此重要。</p><p>如果场景中没有物体被标记为Static 那么开启摄像机的OcclusionCulling有什么作用呢?<br>这是一个非常好的问题，它触及了Unity occlusion culling 系统的一个关键前提。</p><p>简单直接的回答是：如果场景中没有任何物体被标记为 Occluder Static，那么开启摄像机的 Occlusion Culling 功能几乎没有任何作用，只会白白浪费一点CPU性能。</p><p>详细解释<br>Occlusion Culling 系统的工作分为两个核心阶段：</p><p>预计算阶段（烘焙，Baking）：</p><p>在编辑器里，你点击“Bake”按钮时，Unity会遍历场景中所有标记了 Occluder Static 的物体。</p><p>它会将这些物体的几何信息（简化后的）分解成一个个小块（ cells），并计算它们之间的相互遮挡关系，然后将这些关系保存成一个遮挡数据文件（OcclusionCullingData.asset）。</p><p>如果没有物体被标记为 Occluder Static，这个烘焙过程就无法生成任何有效的遮挡数据。 结果就是一个空的或者无效的遮挡数据文件。</p><p>运行时阶段（查询）：</p><p>在游戏运行时，开启Occlusion Culling的摄像机会查询第一步中生成的预计算数据。</p><p>它会根据相机的位置和视角，快速地从数据中查出：“在这个视角下，哪些静态遮挡物是可见的？哪些区域被它们完全挡住了？”</p><p>然后，它会将那些位于被挡住区域内的物体（无论是静态还是动态）从渲染队列中剔除。</p><p>如果没有预计算的遮挡数据（因为没标记静态物体），这个查询就无数据可查，系统也就无法知道任何遮挡关系。</p><p>那么，开启后还有什么效果？<br>即使没有静态遮挡物，开启Occlusion Culling可能还会有以下极其有限的效果，但这些效果并不依赖它：</p><p>视锥体剔除（Frustum Culling）：</p><p>这是所有摄像机默认永远开启的核心功能，与你是否开启Occlusion Culling无关。</p><p>它的作用是只渲染相机视锥体（视野范围）内的物体。视野外的物体本来就不会渲染。</p><p>你开不开OC，视锥体剔除都在工作。所以这不是OC的功劳。</p><p>非常微弱的动态物体处理：</p><p>理论上，Unity的OC系统可能仍会为动态物体执行一些最基本的包围盒检查。但由于没有静态遮挡物作为参考，它无法判断一个动态物体是否被另一个动态物体挡住（因为动态物体不能作为遮挡物）。</p><p>因此，所有动态物体只要在视野内，就都会被渲染，哪怕它们堆叠在一起。这会导致严重的过度绘制（Overdraw）。</p><p>结论与比喻<br>你可以把这个过程想象成一个捉迷藏游戏：</p><p>静态遮挡物（Occluder Static）：就像是房间里预先把家具、墙壁的位置和大小画好的藏宝图。</p><p>烘焙（Baking）：就是绘制这张藏宝图的过程。</p><p>运行时Occlusion Culling：就是“鬼”看着这张藏宝图，直接知道哪些地方藏了人（被遮挡），不用一个个角落去翻找（渲染）。</p><p>如果你的场景里没有标记任何静态物体，就相当于：</p><p>你告诉“鬼”：“我们玩捉迷藏吧！”，然后递给他一张白纸（空的遮挡数据）。“鬼”拿着这张白纸，依然需要翻遍房间的每一个角落（渲染所有视野内的物体），因为他没有任何信息能帮他排除任何位置。</p><p>因此，开启摄像机的Occlusion Culling功能，但又不提供任何静态遮挡物，是完全没有意义的优化策略。 正确的做法是：将场景中永远不会移动的大型物体（地形、建筑、山体）标记为 Occluder Static，并进行烘焙，这样才能真正发挥OC的强大威力。</p><p>这个Bake操作 是每次打包前必须我自己处理吗? 还是自动处理<br>这是一个非常关键的工作流问题。</p><p>答案是：Bake操作必须由你在Unity编辑器中手动执行。它不会在打包时自动处理，也不会在运行时自动完成。</p><p>详细解释<br>为什么不是自动的？</p><p>极其耗时：烘焙光照（GI）和遮挡剔除（Occlusion Culling）是非常消耗计算资源的进程，可能需要几分钟到几小时不等，取决于场景的复杂度和你的电脑配置。如果每次打包前都自动执行一次，整个开发流程会变得无法忍受的缓慢。</p><p>需要人工审核：烘焙结果常常需要开发者用眼睛去检查。比如光照贴图是否有瑕疵、漏光？遮挡剔除是否正确，有没有不该被剔除的物体被剔除了？这些都需要人工在编辑器里查看和调整参数后重新烘焙，无法全自动完成。</p><p>基于编辑器状态：烘焙过程依赖于物体在编辑器场景（Scene） 中的状态（位置、静态标记、光照参数等）。打包（Build）过程只是将编辑器的最终成果（包括烘焙好的数据文件）打包成一个游戏应用程序。</p><p>烘焙的数据去哪了？<br>当你点击Bake按钮后，Unity会在你的项目资产（Assets） 文件夹中生成对应的数据文件：</p><p>光照烘焙（Lighting Bake）：会在场景文件所在的同级目录生成一个名为 LightingData 的文件夹，里面包含 .exr, .lighting 等光照贴图和数据文件。</p><p>遮挡剔除烘焙（Occlusion Culling Bake）：会在场景文件所在的同级目录生成一个 OcclusionCullingData.asset 文件。</p><p>打包（Build）时，这些数据文件会和场景、模型、纹理等资源一起被包含到最终的游戏包（.apk, .exe等）中。运行时直接读取这些预计算好的数据。</p><p>正确的工作流程<br>你的工作流程应该是这样的，特别是在项目后期：</p><p>在编辑器中进行最终调整：布置好场景中的所有静态物体，设置好灯光参数、 occlusion culling 参数。</p><p>手动执行烘焙：在 Window &gt; Rendering &gt; Lighting 和 Window &gt; Rendering &gt; Occlusion Culling 面板中，点击 Generate Lighting 和 Bake 按钮。</p><p>等待并检查结果：等待烘焙完成，在场景视图中检查烘焙效果是否正确。如果有问题，调整参数后回到第2步重新烘焙。</p><p>保存场景和项目：确保烘焙生成的数据文件已经保存。</p><p>打包（Build）：现在你可以点击 File &gt; Build Settings… &gt; Build 进行打包了。打包器会自动包含所有当前已经烘焙好的数据文件。</p><p>非常重要的注意事项<br>版本控制（Version Control）：烘焙生成的数据文件（光照贴图、OcclusionCullingData.asset）是必须提交到版本控制系统（如Git, SVN） 的文件。这样能保证所有团队成员和构建服务器（CI/CD）拿到项目后，看到的画面和性能是一致的，而无需自己重新烘焙。</p><p>构建服务器（CI/CD）：在自动化的构建流水线上，通常不会执行烘焙操作。构建脚本会直接打包已经由开发者在本机烘焙好并提交到版本库的数据。如果需要在服务器上烘焙，需要专门配置，但这会极大地增加构建时间。</p><p>动态修改：如果你在运行时通过代码实例化或移动了物体，这些变动完全不会影响已经烘焙好的数据。这也是为什么移动静态物体会导致渲染错误的原因。</p><p>总结一句话：Bake 是你在编辑器里为游戏“预处理”数据的创作过程，而 Build 只是将这些处理好的成果“打包发货”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.html&quot;&gt;看完Unity 官方Graphics文档&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Render中的概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——尽信书不如无书</title>
    <link href="https://soincredible.github.io/posts/75ed80d8/"/>
    <id>https://soincredible.github.io/posts/75ed80d8/</id>
    <published>2025-08-22T07:44:50.000Z</published>
    <updated>2025-09-09T01:40:46.690Z</updated>
    
    <content type="html"><![CDATA[<h1>到底该如何阅读</h1><p>马上要看一本书, 就叫《如何阅读一本书》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;到底该如何阅读&lt;/h1&gt;
&lt;p&gt;马上要看一本书, 就叫《如何阅读一本书》&lt;/p&gt;
</summary>
      
    
    
    
    <category term="迷思" scheme="https://soincredible.github.io/categories/%E8%BF%B7%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>迷思——哪有什么岁月静好,都是有人替你负重前行</title>
    <link href="https://soincredible.github.io/posts/4d82216e/"/>
    <id>https://soincredible.github.io/posts/4d82216e/</id>
    <published>2025-08-20T17:36:58.000Z</published>
    <updated>2025-09-09T01:54:46.495Z</updated>
    
    <content type="html"><![CDATA[<h1>当你在享受某种设计模式带给你的便利时, 你应该思考设计模式是如何给你带来便利的</h1><p>起因是, 笔者想要在Unity中实现一些基于UGUI的拖拽效果, 于是开始去思考UGUI是如何实现响应输入的, 接着了解到Unity的EventSystem和一系列EventHandler接口(IPointerClickHandler、 IDragHandler等)来驱动整个System的运转. 笔者在这篇博客中并非是要讨论EventSystem的具体实现. 而是想陈述自己对EventHandler这些接口在UGUI体系中扮演角色的一些迷思. 作为UGUI的使用者, 我只关心如何实现自己想要的功能. 如果我想让一个UI元素可以响应点击, 那我就要创建一个继承自MonoBehaviour的脚本, 挂载到这个UI元素上, 再实现IPointerClickHandler接口, ok, 到此我就已经让这个UI元素可点击了, 我下面只需要专注于开发这个UI元素被点击后会发生什么就好了. 至于这背后究竟是怎样运转的, 答案在UGUI的EventSystem源码中, 但我可以不关心.</p><p>我将上面的表述再进行一下抽象: <strong>使用者</strong>只负责接口行为的定义, <strong>使用者</strong>并不关心接口如何被调用.</p><p>由于我经常以<strong>使用者</strong>的身份在写代码, 也没有阅读过诸如EventSystem的源码, 导致我的<strong>设计思维</strong>十分薄弱. 也就是说, 当我要做类似EventSystem类型的开发时, 我既要将自己代入<strong>使用者</strong>的视角, 也要代入<strong>设计者</strong>的视角, 此时我不再是享受岁月静好的人, 我就是那个负重前行的人. 我开始意识到阅读源码的重要性, 粗略阅读过UGUI的源码后, 我对于框架要实现的效果有了一个模糊的概念: <strong>框架外部定义行为, 框架内部控制流程</strong>. Unity协程、C#的Task也能套用这句话, 这两者都可以用来处理异步任务, 我无需关心它们的内部流程, 我只专注于我要处理的异步任务本身就可以. 笔者在阅读UGUI代码时反复体验到恍然大悟的感觉, 希望之后能分出精力搞清楚协程和Task的执行流程.</p><p>于是有一段时间我经常会遇到这种处境: 在业务的开发中发现一些类型中能抽象出一部分行为封装成接口, 但有可能这些类根本就不是同一个概念下的东西, 或者, 正是由于这种 只考考虑抽离行为 而不考虑接口调用时机和接口持有者的数据组织格式, 导致绝大部分抽离行为封装接口的操作都十分多余.</p><p>接口的行为不止于此 我记得在刚入行的时候, 一个程序员前辈跟我说, 写代码是一个十分繁琐的过程, 但如果你觉得某一部分代码写起来好像不用那么繁琐就能实现你的功能, 那有可能是有人在你不知道的地方帮你做了很多事情. 我上面举的EventSystem就是这样一个例子, UGUI系统通过对外暴露EventHandler接口的方式, 在内部有能够持有接口实例的方法, 你不需要去关心UGUI系统内部是如何持有接口实例的. YooAsset自定义打包Step也是类似的思想, 二者都是通过某种方式持有了外部的对象实例, Unity是通过运行时持有并遍历所有的GameObject, 找到上面的EventHandler来持有它们, 而YooAsset则是在Init时将需要的buildstep实例注册到YooAsset内部去.</p><h1>对IMGUI和UGUI实现机制的思考</h1><p>当你习惯了使用UGUI这一套东西时, 让你用IMGUI, 你会特别不舒服, 感觉用起来会很别扭. 原因是: IMGUI既要操心交互逻辑是什么, 还要在OnGUI方法里自己去写UI组件触发的检测逻辑. 而UGUI则只需要操心交互的逻辑是什么, 不需要操心如何做检测的.</p><p>但是从实现方案上看, IMGUI这套完全可以用UGUI那一套的思想, UGUI用了一套EventSystem作为 触发交互的检测逻辑放在同一个地方集中处理. UGUI使用的输入的封装是<code>Input</code>, 将Input中得到的屏幕输入信息传递给<code>EventSystem</code>, 通过Raycaster模块得到 Input中的屏幕输入位置得到射线触碰到了哪个物体<code>GameObject</code>, 然后去获取到这个物体上面所有UGUI体系中的EventHandler, 根据Input中传来的触碰信息(按下、拖拽等)去触发相关的Handler, 如果这个GameObject上有相关的组件的话.</p><p>IMGUI这一套的UI组件不是以组件的方式组织的, 是以<code>Rect</code>为结构组织的, <code>IMGUI</code>使用的输入的封装是<code>Event</code>, IMGUI这一套, 不是通过什么按钮组件之类的去判断的, 所有的组件都是一个Rect, 对外暴露方法, 比如Button或者Toggle, 然后在OnGUI中 就相当于Update方法, 去查询所有的Rect区域, 首先判断一下鼠标在不在这个区域里面, 如果这个区域你是作为按钮去使用的, 那么继续去看<code>Event</code>中<code>EventType</code>字段表示鼠标是不是按下了, 如果按下了, 则返回True, 那么在OnGUI的逻辑里面就拿到了返回值是true, 代表这个按钮被按下了, 就可以去执行按钮点击的逻辑了. 去判断当前鼠标的位置, 以及鼠标的状态 比如是点击、持续点击、拖拽等等, 然后直接在这个方法内, 根据数据的数据做对应的逻辑和表现.</p><h1>制定规范、制定设计模式的时候是最麻烦的, 就像是开发UGUI的EventSystem绝对不是什么轻松的工作, 但是确实一定程度上实现了“一劳永逸”</h1><h2 id="搭建一个框架-真的很痛苦">搭建一个框架 真的很痛苦</h2><h3 id="严重的代码洁癖-出现设计考虑之外的情况-容易动摇-想要推倒重做">严重的代码洁癖, 出现设计考虑之外的情况 容易动摇 想要推倒重做</h3><h3 id="搭建一个框架-普适性是个问题-不确定能否应对之后的业务场景">搭建一个框架 普适性是个问题 不确定能否应对之后的业务场景</h3><h3 id="缺少耐心">缺少耐心</h3><h2 id="要真的去写-才能知道是不是真的能抽象">要真的去写 才能知道是不是真的能抽象</h2><p>最近笔者想要给项目的换皮活动也做一个类似的, 一个活动换皮要有下面几个固定的步骤 导入资源、更新配置表, 定义一个IStep接口, 接口内有一个Action行为, 调用方可以实现多个继承IStep接口的类, 比如导入资源类、更新配置表类, 然后在Action行为中就可以实现是如何导入资源的、如何更新配置表的. 然后将导入资源类和更新配置表类再注册到一个序列化的数据结构或者硬编码的脚本中, 在执行换皮的时候就是从序列化数据或者硬编码脚本中拿到这一套流程信息 传入到 我这套换皮框架中, 外部不用管我内部是如何驱动这套流程信息运转的, 这样的模式和上面举的UGUI、YooAsset的例子大同小异.</p><p>我有段时间看了大量讲述C#Task的文章, 现在再去回想其实还是不甚理解, 多去想想</p><p>定义接口的目的, 让一些类型具有某些行为, 并且可以通过声明接口类型, 来持有接口的实例, 一个实例的对象既可以是该实例的class类型, 也可以是其实现的任意一个接口的类型.<br>下面列举了笔者在开发过程中遇到的</p><ol><li><p>C#中的非托管资源在使用的时候可以实现IDisposable接口, 在Dispose接口中, 给了开发者比较统一便捷的方式对不同的非托管资源进行释放的一个点, 另外其中</p></li><li><p>语法糖foreach, 有一个IEnumerable和IEnumerator, 使用IEnumerable标识一个类型的身份,</p></li></ol><p>因此 接口在设计隔离性、统一操作、标识统一身份等场景下能发挥作用.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;当你在享受某种设计模式带给你的便利时, 你应该思考设计模式是如何给你带来便利的&lt;/h1&gt;
&lt;p&gt;起因是, 笔者想要在Unity中实现一些基于UGUI的拖拽效果, 于是开始去思考UGUI是如何实现响应输入的, 接着了解到Unity的EventSystem和一系列EventH</summary>
      
    
    
    
    <category term="迷思" scheme="https://soincredible.github.io/categories/%E8%BF%B7%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>RPG游戏开发记录(四)：网络通信</title>
    <link href="https://soincredible.github.io/posts/e255a10a/"/>
    <id>https://soincredible.github.io/posts/e255a10a/</id>
    <published>2025-08-20T16:42:31.000Z</published>
    <updated>2025-09-09T10:29:54.855Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV19d4y1678X/?vd_source=83f4165825ce9df46cf4fd576ccb1102">Skynet入门</a></p><h1>路由器的概念</h1><h1>端口</h1><h1>IP地址</h1><h1>C# Socket编程</h1><h1>什么是Socket</h1><p>一个Socket连接的流程<br>客户端发起</p><p>需要注意的是, 可以多次发起连接请求, 这样就会建立多个Socket, 存在风险</p><h2 id="Socket分为两种">Socket分为两种</h2><p>第一种是监听Socket</p><p>第二种是会话Socket</p><p>你的理解很准确，确实<strong>服务端会有两个不同用途的Socket对象</strong>：</p><ol><li><p><strong>监听 Socket</strong>（称为 <code>listenSocket</code>），职责是：</p><ul><li>绑定端口，用于侦听新的连接请求（<code>Bind</code> + <code>Listen</code>）。</li></ul></li><li><p><strong>会话 Socket</strong>（每连一个客户端，对应一个），职责是：</p><ul><li>和某个客户端具体收发数据（<code>Accept</code> 的返回值）。</li></ul></li></ol><hr><h2 id="为什么要这样分开？为什么不能直接用监听socket和客户端通信？">为什么要这样分开？为什么不能直接用监听socket和客户端通信？</h2><h3 id="一、协议-设计层面的原因">一、协议/设计层面的原因</h3><ol><li><p><strong>监听Socket只负责接收连接请求</strong></p><ul><li>监听socket在TCP层维护了一个“正在监听端口、等待连接”的队列（backlog）。</li><li>它不能用来真正收发数据，只能等待新连接，然后通过<code>Accept</code>产生一个新的会话socket。</li><li>TCP协议里，监听socket和会话socket拥有不同的状态。</li></ul></li><li><p><strong>每个客户端要有独立的socket对象</strong></p><ul><li>这样服务端才能同时和多个客户端通信（每个连接一个独立文件描述符），互不干扰。</li><li>如果直接用监听socket收发数据，就无法区分哪个客户端发来的数据，也无法并发处理，直接崩溃！</li><li><code>Accept</code> 会为每个客户端分配一个新的 socket，底层内核分配新的资源、端点，服务端逻辑才能独立管理。</li></ul></li><li><p><strong>多路复用、并发模型需要会话socket</strong></p><ul><li>服务端通常有几十万个连接，如果全部抢占同一个监听socket，相互干扰，严重影响并发性能。</li><li>新的socket会与客户端唯一绑定，方便后续select/epoll/IOCP或线程池单独处理。</li></ul></li><li><p><strong>监听socket和会话socket的状态不一样</strong></p><ul><li>监听socket是“LISTEN”状态，只能等待连接。</li><li>接受后的会话socket进入“ESTABLISHED”状态，才能双向收发数据。</li></ul></li></ol><h3 id="二、操作系统实现原因">二、操作系统实现原因</h3><ul><li><p><strong>Linux/Windows的内核管理：</strong></p><ul><li>监听socket分配backlog（等待区），只用于管理连接请求队列；</li><li>收到客户端请求，内核分配一个新socket fd（会话socket），维护与对方的TCP会话状态。</li><li>只有这个fd才能安全读写数据，监听socket的fd不能用来读写，只能accept。</li></ul></li><li><p><strong>安全/隔离：</strong></p><ul><li>监听socket本身不能被污染——收发数据万一断了会影响整个服务器socket监听。</li><li>每个连接单独分配资源，有问题只会影响单个连接，容易控制和管理。</li></ul></li></ul><hr><h3 id="图示理解（伪代码）：">图示理解（伪代码）：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Server Socket Life Cycle</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建监听Socket</span></span><br><span class="line">Socket listenSocket = <span class="keyword">new</span> Socket(...);</span><br><span class="line"><span class="comment">// 2. 绑定端口</span></span><br><span class="line">listenSocket.Bind(...);</span><br><span class="line"><span class="comment">// 3. 进入监听</span></span><br><span class="line">listenSocket.Listen(...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. 每有一个新连接, Accept会分配一个新的会话Socket</span></span><br><span class="line">    Socket conn = listenSocket.Accept();</span><br><span class="line">    <span class="comment">// 5. 后续和客户端的所有收发数据，都用conn这个socket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>listenSocket</code> 只负责新增连接。</li><li><code>conn</code> 负责和某个客户端通信。</li><li>有n个客户端，就有n个会话Socket，<strong>只有一个监听Socket</strong>。</li></ul><hr><h2 id="举个实际例子">举个实际例子</h2><ul><li><strong>Web服务器（比如IIS/Apache/nginx）</strong><ul><li>监听端口80，只用监听socket握手接收新用户连接请求。</li><li>每有新请求，生成一个会话socket，和该连接通信，互不干扰。</li><li>如果用同一个监听socket收发数据，所有人混流，无法区别谁是谁。</li></ul></li></ul><hr><h2 id="小结">小结</h2><ul><li><strong>监听socket</strong>：只负责侦听和接受新连接，不能收发数据。</li><li><strong>会话socket（Accept出来的）</strong>：和某个客户端具体通信，收发数据。</li><li>这样设计是操作系统/协议规定的，<strong>能确保高效并发、安全隔离和稳定运行</strong>。</li></ul><hr><blockquote><p><strong>“监听socket是连接的大门，只用来看谁想进来；会话socket是进入之后，与某个人的密室专线，对每个身份都有独立沟通渠道。只有分开，管理和性能才能做好。”</strong></p></blockquote><hr><p>如需更底层协议细节，可以补充TCP状态转移图/源码！</p><p>你的两个问题很专业，下面逐条详细说明：</p><hr><h2 id="1-创建监听-Socket-和会话-Socket-的流程一样吗？">1. 创建监听 Socket 和会话 Socket 的流程一样吗？</h2><h3 id="在-Socket-编程（比如-C-）里：">在 Socket 编程（比如 C#）里：</h3><ul><li><strong>监听 Socket</strong> (<code>listenSocket</code>)<ul><li>你得主动创建：<code>new Socket(...)</code></li><li>然后 Bind 到某端口：<code>.Bind(...)</code></li><li>然后开启侦听：<code>.Listen(backlog)</code></li></ul></li><li><strong>会话 Socket</strong> (<code>connSocket</code>)<ul><li><strong>不是你主动创建的</strong>。它是 listener 调用 <code>.Accept()</code> 时由系统自动生成、返回的对象。</li><li>你不用再手动 Bind/Listen，它一出生就“已连上”，通信双方已确定（对端IP:Port 本地IP:Port等）。</li></ul></li></ul><h3 id="流程总结">流程总结</h3><ul><li>监听 Socket 需要 显式 创建-绑定-监听</li><li>会话 Socket 是通过监听 Socket 的 <code>.Accept()</code> 生成</li><li>你不需要对会话 Socket 进行 Bind/Listen（如果你再次Bind会报错）</li></ul><blockquote><p><strong>流程不一样：监听Socket手动创建配置，连接Socket自动生成，只要收数据即可。</strong></p></blockquote><hr><h2 id="2-两者的数据内容构成上有什么区别？">2. 两者的数据内容构成上有什么区别？</h2><h3 id="监听-Socket">监听 Socket</h3><ul><li>包含内容：<ul><li>本地端口/IP（Bind 过的地址，如 0.0.0.0:8000）</li><li>一个监听队列（backlog）——new连接排队用</li><li>Socket类型(TCP/UDP)，协议族等</li></ul></li><li><strong>没有“远端”信息，也没有TCP序列号等通信状态</strong></li><li>不能直接收发应用数据，只能收到新连接请求。</li></ul><h3 id="会话-Socket">会话 Socket</h3><ul><li>包含内容：<ul><li>本地端口/IP（一般是监听Socket的端口）</li><li><strong>远端客户端IP/端口</strong></li><li>当前TCP连接状态、序列号、缓冲区等</li><li>发送和接收缓冲区</li><li>TCP协议维护的连接控制块（TCP state machine、TCP窗口、拥塞控制等）</li></ul></li><li>可以直接收发数据</li><li>维护与唯一远端的连接状态、收发缓冲、数据包</li></ul><h4 id="举个例子：">举个例子：</h4><p>监听Socket的数据结构只包含“我负责管理这个端口和连接队列”；<br>会话Socket的数据结构包含“我和这个客户端的连线状态、数据缓冲、包顺序等详细内容”。</p><h3 id="表格对比">表格对比</h3><table><thead><tr><th>项目</th><th>监听Socket</th><th>会话Socket</th></tr></thead><tbody><tr><td>本地地址/端口</td><td>有</td><td>有</td></tr><tr><td>远端地址/端口</td><td>无</td><td>有</td></tr><tr><td>TCP连接状态</td><td>LISTEN</td><td>ESTABLISHED</td></tr><tr><td>连接队列</td><td>backlog连接请求队列</td><td>无</td></tr><tr><td>应用层数据通信</td><td>不行</td><td>可以</td></tr><tr><td>缓冲区</td><td>没有数据缓冲</td><td>有发送/接收缓冲区</td></tr><tr><td>唯一性</td><td>只一个（主动建）</td><td>客户端连接一个生成一个</td></tr></tbody></table><hr><h2 id="结论">结论</h2><p><strong>创建流程：</strong></p><ul><li>监听Socket要先创建、bind、listen，主动准备好；会话Socket通过accept由内核自动生成（你调accept方法就有了）。</li></ul><p><strong>内容区别：</strong></p><ul><li>监听Socket缺失“远端”数据，只管新连接请求；会话Socket则包含详细通信双方信息和全部TCP连接细节及缓冲区、序列号等。</li></ul><blockquote><p><strong>监听Socket专注于“新连接排队、接收”，会话Socket专注于“具体数据传输”——角色完全不同。</strong></p></blockquote><hr><p>如果想看更底层源码（比如Linux内核的<code>struct sock</code>、<code>struct tcp_sock</code>），可以补充！</p><h1>Socket中如何判断一个连接断开?</h1><h1>一定要注意 Socket的执行不一定在主线程上, 可千万不要在非主线程上操作MonoBehaviour中的数据, 比如UI</h1><h2 id="客户端">客户端</h2><p>Send方法返回只代表成功将数据放到发送缓存区中, 对方可能还没收到数据</p><h2 id="服务端">服务端</h2><p>Accept是建立连接用<br>Receive是接受消息用</p><p>Accept -&gt; Receive</p><p>结合GPT 使用C#使用一个Actor模型</p><p>非常好的问题！<br>我们来详细分析下：</p><hr><h2 id="问题重述">问题重述</h2><p>假设你有<strong>一批 Socket</strong>（比如100个连接），你要定期检测哪些“可读”，方式有两种：</p><ol><li>用 <code>foreach</code>，对每个 socket 调用 <code>.Poll(...)</code>。</li><li>用 <code>Socket.Select(...)</code>，一次性把所有 socket 放进列表，检查谁可读。</li></ol><p><strong>哪种开销大？为什么？性能代价在哪里？</strong></p><hr><h2 id="1-分析-Poll（对每个Socket单独轮询）">1. 分析 Poll（对每个Socket单独轮询）</h2><ul><li>你对每个 Socket 都调用一次 Poll。</li><li>Poll 的本质：.NET 框架会为每个 socket 调用一次底层API（可能是 poll/select/epoll/kqueue，视平台而定），每个 socket 都要进入内核态、做一次查询，并等待指定超时时间。</li><li>100个Socket你就要进入内核态100次。</li><li>用户态和内核态的切换非常昂贵，尤其你每次只查单个Socket，无法利用系统批量检测优化。</li><li>结果，你的检测总时间 ≈ 100 次 Poll 耗时总和。大量重复系统调用，<strong>内核态资源消耗大，性能低</strong>。</li></ul><hr><h2 id="2-分析-Select（一次性批量查询）">2. 分析 Select（一次性批量查询）</h2><ul><li>你把所有Socket批量传给一次Select调用。</li><li>内部只进入内核态<strong>一次</strong>，内核态代码在本地 for（或者epoll也许是红黑树遍历等）判断这一批socket的状态，把可读/socket事件状况都批量告诉你的应用。</li><li>这样<strong>调用一次系统接口</strong>，拿回所有结果。</li><li>和Poll做100次系统调用比，Select只做一次系统调用+本地循环。</li></ul><hr><h2 id="3-结果对比">3. 结果对比</h2><table><thead><tr><th>方案</th><th>内核切换次数</th><th>系统调用次数</th><th>主要瓶颈</th></tr></thead><tbody><tr><td>多次Poll</td><td>N(100次)</td><td>N(100次)</td><td>用户态&lt;-&gt;内核态,多余切换</td></tr><tr><td>一次Select</td><td>1</td><td>1</td><td>内核批量查找更高效</td></tr></tbody></table><ul><li><strong>开销主要在“内核切换+系统调用次数”！</strong><ul><li>多次 Poll 开销主要是：大量的系统调用 &amp; 频繁的用户态/内核态切换。</li><li>Select 只需一次调用，数据结构拷贝也一次，不会反复切换内核，而且能一次性处理所有。</li></ul></li><li>另外，Poll 如果你用长超时或阻塞方式，遍历所有socket总耗时会变得很长（等待多个socket轮流各自超时）。</li></ul><hr><h2 id="4-结论">4. 结论</h2><ul><li><strong>Select 明显效率更高，开销更低。</strong></li><li>Poll 在N多socket时几乎不可接受，只有少数socket（比如客户端）才推荐这么写。</li><li>在高并发服务器场景，多路复用总是推荐批量Select（或更优的epoll/IOCP/SocketAsyncEventArgs）。</li></ul><hr><h2 id="总结（标准面试答案）">总结（标准面试答案）</h2><blockquote><p><em>“遍历多个socket分别Poll，相比一次Select批量检测，最大的额外开销在于多次进行系统调用和用户/内核态切换。在socket数量增多时，这种切换会极大增加CPU和内核资源消耗。而Select可以一次性批量检测所有socket状态，大幅减少系统调用次数和切换负载，因此效率远高于多次Poll。”</em></p></blockquote><hr><p><strong>结论：有多个socket（&gt;10），推荐用<code>Select</code>。<br>只用单个socket/客户端可偶尔用<code>Poll</code>。</strong></p><h1>什么是粘包分包 为什么会有线程冲突的问题</h1><p><strong>是的，你遇到的正是“粘包”问题！</strong></p><hr><h3 id="原因简述">原因简述</h3><p>在TCP编程中，<strong>粘包</strong>和<strong>拆包</strong>问题很常见，因为TCP是面向字节流的，没有消息边界。<br>你可能一次Send两条消息，服务器一次Receive就粘到一起收了（粘包）；<br>也可能一条消息分两次才收完（拆包/半包）。</p><hr><h3 id="在你的场景下">在你的场景下</h3><p>你的客户端连续Send（比如<code>Enter|...</code>和<code>List|</code>），<br>服务端的Receive有时会一次性收到<code>Enter|...List|</code><br>或其他没对齐的内容，这就是粘包！</p><hr><h3 id="解决方案">解决方案</h3><p>你需要<strong>实现协议分包逻辑</strong>，典型做法是：</p><ul><li>每个消息后面加分隔符（常用<code>\n</code>或特殊字符，如<code>&quot;|&quot;</code>或<code>&quot;\r\n&quot;</code>），</li><li>服务端维护一个消息缓存字符串，循环切分出完整消息进行解析。</li></ul><hr><h3 id="总结">总结</h3><blockquote><p><strong>你遇到的问题就是“TCP粘包”问题。必须自己在应用层解决，通过协议分隔符（如<code>\n</code>）、长度头等方式保正服务器能正确切分每条消息。</strong></p></blockquote><p>如需具体怎么写切分消息的代码，随时问我！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV19d4y1678X/?vd_source=83f4165825ce9df46cf4fd576ccb1102&quot;&gt;Skynet入门&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;路由器的概念&lt;/h1&gt;
&lt;h1&gt;端口</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnrealEngine源码</title>
    <link href="https://soincredible.github.io/posts/43a309b5/"/>
    <id>https://soincredible.github.io/posts/43a309b5/</id>
    <published>2025-08-16T09:39:38.000Z</published>
    <updated>2025-08-27T02:33:09.827Z</updated>
    
    <content type="html"><![CDATA[<p>虚幻引擎的代码使用的是古早版本的C++, 跟现代的C++有些脱节了, 所以可以把虚幻引擎的源代码理解为是C++的一个变种</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚幻引擎的代码使用的是古早版本的C++, 跟现代的C++有些脱节了, 所以可以把虚幻引擎的源代码理解为是C++的一个变种&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在Unity中实现拖拽物体的功能</title>
    <link href="https://soincredible.github.io/posts/aa328bbc/"/>
    <id>https://soincredible.github.io/posts/aa328bbc/</id>
    <published>2025-08-10T08:33:19.000Z</published>
    <updated>2025-08-11T03:35:33.789Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DraggableObj</span> : <span class="title">MonoBehaviour</span>, </span><br><span class="line">        <span class="title">IDragHandler</span>, <span class="title">IBeginDragHandler</span>, <span class="title">IEndDragHandler</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">enum</span> DragState</span><br><span class="line">        &#123;</span><br><span class="line">            None,</span><br><span class="line">            Idle,</span><br><span class="line">            Dragging,</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> DragState dragState = DragState.None;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;拖拽中...&quot;</span>);</span><br><span class="line">            RectTransformUtility.ScreenPointToLocalPointInRectangle(transform.parent.transform <span class="keyword">as</span> RectTransform, eventData.position, Camera.main, <span class="keyword">out</span> Vector2 point);</span><br><span class="line">            transform.localPosition = point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;开始拖拽&quot;</span>);</span><br><span class="line">            transform.localScale = Vector3.one * <span class="number">1.5f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;拖拽结束...&quot;</span>);</span><br><span class="line">            transform.localScale = Vector3.one;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将上面的逻辑进一步抽象一下, 把每个接口内的行为抽离出来, 作为一个action, 在合适的时机传进去.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FigmaAPI阅读</title>
    <link href="https://soincredible.github.io/posts/8d32db40/"/>
    <id>https://soincredible.github.io/posts/8d32db40/</id>
    <published>2025-08-10T08:29:45.000Z</published>
    <updated>2025-08-11T03:35:33.787Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.figma.com/developers/api#intro">https://www.figma.com/developers/api#intro</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.figma.com/developers/api#intro&quot;&gt;https://www.figma.com/developers/api#intro&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
