<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EddieLee</title>
  
  <subtitle>to infinity and beyond✨🛸.</subtitle>
  <link href="https://soincredible.github.io/atom.xml" rel="self"/>
  
  <link href="https://soincredible.github.io/"/>
  <updated>2025-08-22T07:45:04.443Z</updated>
  <id>https://soincredible.github.io/</id>
  
  <author>
    <name>Eddie Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>迷思——尽信书不如无书</title>
    <link href="https://soincredible.github.io/posts/75ed80d8/"/>
    <id>https://soincredible.github.io/posts/75ed80d8/</id>
    <published>2025-08-22T07:44:50.000Z</published>
    <updated>2025-08-22T07:45:04.443Z</updated>
    
    <content type="html"><![CDATA[<h1>到底该如何阅读</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;到底该如何阅读&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——哪有什么岁月静好,都是有人替你负重前行</title>
    <link href="https://soincredible.github.io/posts/4d82216e/"/>
    <id>https://soincredible.github.io/posts/4d82216e/</id>
    <published>2025-08-20T17:36:58.000Z</published>
    <updated>2025-08-22T03:50:02.171Z</updated>
    
    <content type="html"><![CDATA[<p>起因是, 笔者想要在Unity中实现一些基于UGUI的拖拽效果, 于是开始去思考UGUI是如何实现响应输入的, 接着了解到Unity的EventSystem和一系列EventHandler接口(IPointerClickHandler、 IDragHandler等)来驱动整个System的运转. 笔者在这篇博客中并非是要讨论EventSystem的具体实现. 而是想陈述自己对EventHandler这些接口在UGUI体系中扮演角色的一些迷思. 作为UGUI的使用者, 我只关心如何实现自己想要的功能. 如果我想让一个UI元素可以响应点击, 那我就要创建一个继承自MonoBehaviour的脚本, 挂载到这个UI元素上, 并且还要实现IPointerClickHandler接口, 这样就结束了, 至于怎么样在运行时获取到这个UI元素上的脚本实例, 以及如何触发接口中的方法, 我不关心, Unity会帮我处理. 这就是我对接口最初的理解, <strong>我</strong>只负责接口行为的定义, 我不负责接口行为的调用. 于是有一段时间我经常会遇到这种处境: 在业务的开发中发现一些类型中能抽象出一部分行为封装成接口, 但有可能这些类根本就不是同一个概念下的东西, 或者, 正是由于这种 只考考虑抽离行为 而不考虑接口调用时机和接口持有者的数据组织格式, 导致绝大部分抽离行为封装接口的操作都十分多余.</p><p>接口的行为不止于此 我记得在刚入行的时候, 一个程序员前辈跟我说, 写代码是一个十分繁琐的过程, 但如果你觉得某一部分代码写起来好像不用那么繁琐就能实现你的功能, 那有可能是有人在你不知道的地方帮你做了很多事情. 我上面举的EventSystem就是这样一个例子, UGUI系统通过对外暴露EventHandler接口的方式, 在内部有能够持有接口实例的方法, 你不需要去关心UGUI系统内部是如何持有接口示例的. YooAsset自定义打包Step也是类似的思想, 二者都是通过某种方式持有了外部的对象实例, Unity是通过运行时持有并遍历所有的GameObject, 找到上面的EventHandler来持有它们, 而YooAsset则是在Init时将需要的buildstep实例注册到YooAsset内部去. 两者的思想或许可以表述如下: <strong>外部定义行为, 内部控制流程</strong>.</p><p>最近笔者想要给项目的换皮活动也做一个类似的, 一个活动换皮要有下面几个固定的步骤 导入资源、更新配置表, 定义一个IStep接口, 接口内有一个Action行为, 调用方可以实现多个继承IStep接口的类, 比如导入资源类、更新配置表类, 然后在Action行为中就可以实现是如何导入资源的、如何更新配置表的. 然后将导入资源类和更新配置表类再注册到一个序列化的数据结构或者硬编码的脚本中, 在执行换皮的时候就是从序列化数据或者硬编码脚本中拿到这一套流程信息 传入到 我这套换皮框架中, 外部不用管我内部是如何驱动这套流程信息运转的, 这样的模式和上面举的UGUI、YooAsset的例子大同小异.</p><p>Unity协程、C#的Task也是如此, 只因我被“保护”得太好了, Unity的协程和Task都很好用, 丢进去一个异步的任务, 让他自己在那里执行就好了, 可是异步任务本质上是怎么执行的呢? Unity协程依赖于MonoBehaviour的Update机制, Task依赖于C#内部的线程池. 背后都会有一个间隔一定时间轮询的逻辑, 只是我不需要关心这段逻辑罢了</p><p>我有段时间看了大量讲述C#Task的文章, 现在再去回想其实还是不甚理解, 多去想想</p><p>定义接口的目的, 让一些类型具有某些行为, 并且可以通过声明接口类型, 来持有接口的实例, 一个实例的对象既可以是该实例的class类型, 也可以是其实现的任意一个接口的类型.<br>下面列举了笔者在开发过程中遇到的</p><ol><li><p>C#中的非托管资源在使用的时候可以实现IDisposable接口, 在Dispose接口中, 给了开发者比较统一便捷的方式对不同的非托管资源进行释放的一个点, 另外其中</p></li><li><p>语法糖foreach, 有一个IEnumerable和IEnumerator, 使用IEnumerable标识一个类型的身份,</p></li></ol><p>因此 接口在设计隔离性、统一操作、标识统一身份等场景下能发挥作用.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;起因是, 笔者想要在Unity中实现一些基于UGUI的拖拽效果, 于是开始去思考UGUI是如何实现响应输入的, 接着了解到Unity的EventSystem和一系列EventHandler接口(IPointerClickHandler、 IDragHandler等)来驱动整</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://soincredible.github.io/posts/e255a10a/"/>
    <id>https://soincredible.github.io/posts/e255a10a/</id>
    <published>2025-08-20T16:42:31.000Z</published>
    <updated>2025-08-21T02:00:59.991Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UnrealEngine源码</title>
    <link href="https://soincredible.github.io/posts/43a309b5/"/>
    <id>https://soincredible.github.io/posts/43a309b5/</id>
    <published>2025-08-16T09:39:38.000Z</published>
    <updated>2025-08-20T13:49:18.324Z</updated>
    
    <content type="html"><![CDATA[<p>虚幻引擎的代码使用的是古早版本的C++, 跟现代的C++有些脱节了, 所以可以把虚幻引擎的源代码理解为是C++的一个变种</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚幻引擎的代码使用的是古早版本的C++, 跟现代的C++有些脱节了, 所以可以把虚幻引擎的源代码理解为是C++的一个变种&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在Unity中实现拖拽物体的功能</title>
    <link href="https://soincredible.github.io/posts/aa328bbc/"/>
    <id>https://soincredible.github.io/posts/aa328bbc/</id>
    <published>2025-08-10T08:33:19.000Z</published>
    <updated>2025-08-11T03:35:33.789Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DraggableObj</span> : <span class="title">MonoBehaviour</span>, </span><br><span class="line">        <span class="title">IDragHandler</span>, <span class="title">IBeginDragHandler</span>, <span class="title">IEndDragHandler</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">enum</span> DragState</span><br><span class="line">        &#123;</span><br><span class="line">            None,</span><br><span class="line">            Idle,</span><br><span class="line">            Dragging,</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> DragState dragState = DragState.None;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;拖拽中...&quot;</span>);</span><br><span class="line">            RectTransformUtility.ScreenPointToLocalPointInRectangle(transform.parent.transform <span class="keyword">as</span> RectTransform, eventData.position, Camera.main, <span class="keyword">out</span> Vector2 point);</span><br><span class="line">            transform.localPosition = point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;开始拖拽&quot;</span>);</span><br><span class="line">            transform.localScale = Vector3.one * <span class="number">1.5f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;拖拽结束...&quot;</span>);</span><br><span class="line">            transform.localScale = Vector3.one;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将上面的逻辑进一步抽象一下, 把每个接口内的行为抽离出来, 作为一个action, 在合适的时机传进去.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FigmaAPI阅读</title>
    <link href="https://soincredible.github.io/posts/8d32db40/"/>
    <id>https://soincredible.github.io/posts/8d32db40/</id>
    <published>2025-08-10T08:29:45.000Z</published>
    <updated>2025-08-11T03:35:33.787Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.figma.com/developers/api#intro">https://www.figma.com/developers/api#intro</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.figma.com/developers/api#intro&quot;&gt;https://www.figma.com/developers/api#intro&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity源码阅读</title>
    <link href="https://soincredible.github.io/posts/4d404b8c/"/>
    <id>https://soincredible.github.io/posts/4d404b8c/</id>
    <published>2025-08-10T02:11:30.000Z</published>
    <updated>2025-08-11T03:35:33.789Z</updated>
    
    <content type="html"><![CDATA[<p>Unity中有一种<code>.bindings </code>格式的文件, 这类文件经过某种处理会转换为C#文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">C++RAW</span><br><span class="line"></span><br><span class="line">#include &quot;UnityPrefix.h&quot;</span><br><span class="line">#include &quot;Configuration/UnityConfigure.h&quot;</span><br><span class="line">#include &quot;Runtime/Mono/MonoBehaviour.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/Canvas.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/UIStructs.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/BatchGenerator.h&quot;</span><br><span class="line"></span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">#include &quot;Modules/Profiler/Public/ProfilerImpl.h&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">CSRAW</span><br><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using Object = UnityEngine.Object;</span><br><span class="line"></span><br><span class="line">namespace UnityEngine</span><br><span class="line">&#123;</span><br><span class="line">    ENUM RenderMode</span><br><span class="line">        ScreenSpaceOverlay = 0,</span><br><span class="line">        ScreenSpaceCamera = 1,</span><br><span class="line">        WorldSpace = 2</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    [Flags]</span><br><span class="line">    ENUM AdditionalCanvasShaderChannels</span><br><span class="line">        None = 0,</span><br><span class="line">        TexCoord1 = 1 &lt;&lt; 0,</span><br><span class="line">        TexCoord2 = 1 &lt;&lt; 1,</span><br><span class="line">        TexCoord3 = 1 &lt;&lt; 2,</span><br><span class="line">        Normal = 1 &lt;&lt; 3,</span><br><span class="line">        Tangent = 1 &lt;&lt; 4,</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    // CanvasRenderer is the C++ rendering backend for the UI system.</span><br><span class="line">    [RequireComponent(typeof(RectTransform))]</span><br><span class="line">    [NativeClass(&quot;UI::Canvas&quot;)]</span><br><span class="line">    CLASS Canvas : Behaviour</span><br><span class="line"></span><br><span class="line">        AUTO_PROP RenderMode renderMode GetRenderMode SetRenderMode</span><br><span class="line">        AUTO_PROP bool isRootCanvas GetIsRootCanvas</span><br><span class="line">        AUTO_PTR_PROP Camera worldCamera GetCamera SetCamera</span><br><span class="line">        AUTO_PROP Rect pixelRect GetPixelRect</span><br><span class="line">        AUTO_PROP float scaleFactor GetScaleFactor SetScaleFactor</span><br><span class="line">        AUTO_PROP float referencePixelsPerUnit GetReferencePixelsPerUnit SetReferencePixelsPerUnit</span><br><span class="line">        AUTO_PROP bool overridePixelPerfect GetOverridePixelPerfect SetOverridePixelPerfect</span><br><span class="line">        AUTO_PROP bool pixelPerfect GetPixelPerfect SetPixelPerfect</span><br><span class="line">        AUTO_PROP float planeDistance GetPlaneDistance SetPlaneDistance</span><br><span class="line"></span><br><span class="line">        AUTO_PROP int renderOrder GetRenderOrder</span><br><span class="line"></span><br><span class="line">        AUTO_PROP bool overrideSorting GetOverrideSorting SetOverrideSorting</span><br><span class="line">        AUTO_PROP int sortingOrder GetSortingOrder SetSortingOrder</span><br><span class="line">        AUTO_PROP int targetDisplay GetTargetDisplay SetTargetDisplay</span><br><span class="line"></span><br><span class="line">        OBSOLETE warning Setting normalizedSize via a int is not supported. Please use normalizedSortingGridSize</span><br><span class="line">        AUTO_PROP int sortingGridNormalizedSize GetSortingBucketNormalizedSize SetSortingBucketNormalizedSize</span><br><span class="line"></span><br><span class="line">        AUTO_PROP float normalizedSortingGridSize GetSortingBucketNormalizedSize SetSortingBucketNormalizedSize</span><br><span class="line"></span><br><span class="line">        AUTO_PROP int sortingLayerID GetSortingLayerID SetSortingLayerID</span><br><span class="line">        AUTO_PROP int cachedSortingLayerValue GetCachedSortingLayerValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AUTO_PROP AdditionalCanvasShaderChannels additionalShaderChannels GetAdditionalShaderChannels SetAdditionalShaderChannels</span><br><span class="line"></span><br><span class="line">        CUSTOM_PROP string sortingLayerName</span><br><span class="line">        &#123;</span><br><span class="line">            return scripting_string_new(self-&gt;GetSortingLayerName());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            self-&gt;SetSortingLayerName(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM_PROP Canvas rootCanvas</span><br><span class="line">        &#123;</span><br><span class="line">            UI::Canvas* root = self-&gt;GetRootCanvas();</span><br><span class="line">            return Scripting::ScriptingWrapperFor(root == NULL ? self : root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static Material GetDefaultCanvasMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetDefaultUIMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static Material GetETC1SupportedCanvasMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetETC1SupportedCanvasMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OBSOLETE warning Shared default material now used for text and general UI elements, call Canvas.GetDefaultCanvasMaterial()</span><br><span class="line">        CUSTOM static Material GetDefaultCanvasTextMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetDefaultUIMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CSRAW</span><br><span class="line">        public delegate void WillRenderCanvases();</span><br><span class="line">        public static event WillRenderCanvases willRenderCanvases;</span><br><span class="line">        [RequiredByNativeCode]</span><br><span class="line">        private static void SendWillRenderCanvases() &#123; if (willRenderCanvases != null) willRenderCanvases(); &#125;</span><br><span class="line">        public static void ForceUpdateCanvases() &#123; SendWillRenderCanvases(); &#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    CLASS UISystemProfilerApi</span><br><span class="line">        C++RAW</span><br><span class="line">        enum SampleType &#123; Layout, Render &#125;;</span><br><span class="line">        ENUM SampleType</span><br><span class="line">            Layout,</span><br><span class="line">            Render,</span><br><span class="line">        END</span><br><span class="line">        CUSTOM static public void BeginSample(SampleType type)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">            if (UnityProfilerPerThread::ms_InstanceTLS != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                ProfilerInformation&amp; profilerInfo = *profiler_get_info_for_name(type == Layout ? &quot;Layout&quot; : &quot;Render&quot;, type == Layout ? kProfilerUISystemLayout : kProfilerUISystemRender);</span><br><span class="line">                PROFILER_BEGIN(profilerInfo, NULL);</span><br><span class="line">            &#125;</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static public void EndSample(SampleType type)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">            if (UnityProfilerPerThread::ms_InstanceTLS != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                ProfilerInformation&amp; profilerInfo = *profiler_get_info_for_name(type == Layout ? &quot;Layout&quot; : &quot;Render&quot;, type == Layout ? kProfilerUISystemLayout : kProfilerUISystemRender);</span><br><span class="line">                PROFILER_END(profilerInfo);</span><br><span class="line">            &#125;</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static public void AddMarker(string name, Object obj)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER &amp;&amp; UNITY_EDITOR</span><br><span class="line">            InstanceID instanceID = InstanceID_None;</span><br><span class="line">            std::string nameStr(name);</span><br><span class="line">            if (!obj.IsNull() &amp;&amp; Thread::CurrentThreadIsMainThread())</span><br><span class="line">            &#123;</span><br><span class="line">                instanceID =  obj-&gt;GetInstanceID();</span><br><span class="line">                nameStr += &quot; &quot;;</span><br><span class="line">                nameStr += obj-&gt;GetName();</span><br><span class="line">            &#125;</span><br><span class="line">            UI::GetCanvasManager().AddMarker(nameStr.c_str(), instanceID);</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    CSRAW</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Unity中有一种&lt;code&gt;.bindings &lt;/code&gt;格式的文件, 这类文件经过某种处理会转换为C#文件&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUGUI解构(二)-EventSystem</title>
    <link href="https://soincredible.github.io/posts/28d70de0/"/>
    <id>https://soincredible.github.io/posts/28d70de0/</id>
    <published>2025-08-10T00:42:26.000Z</published>
    <updated>2025-08-20T13:53:56.093Z</updated>
    
    <content type="html"><![CDATA[<h1>GraphicRaycaster</h1><p>为什么在创建Canvas节点的时候, 都要GrapihcRaycaster会自动创建<br>GrapihcRaycaster组件不是必须的, 删除掉之后这个Canvas就不能响应点击了.</p><p>要看明白下面这段逻辑是在干什么</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">Raycast</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isActiveAndEnabled)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t = transform;</span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> ignoreParentGroups = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">bool</span> continueTraversal = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t.GetComponents(components);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> canvas = components[i] <span class="keyword">as</span> Canvas;</span><br><span class="line">            <span class="keyword">if</span> (canvas != <span class="literal">null</span> &amp;&amp; canvas.overrideSorting)</span><br><span class="line">                continueTraversal = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> filter = components[i] <span class="keyword">as</span> ICanvasRaycastFilter;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filter == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> raycastValid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">group</span> = components[i] <span class="keyword">as</span> CanvasGroup;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">group</span> != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">group</span>.enabled)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ignoreParentGroups == <span class="literal">false</span> &amp;&amp; <span class="keyword">group</span>.ignoreParentGroups)</span><br><span class="line">                &#123;</span><br><span class="line">                    ignoreParentGroups = <span class="literal">true</span>;</span><br><span class="line">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!ignoreParentGroups)</span><br><span class="line">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!raycastValid)</span><br><span class="line">            &#123;</span><br><span class="line">                ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = continueTraversal ? t.parent : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>EventSystem的触发机理</h1><p>依赖Raycast给的一些数据, 用这些数据找到Raycast命中的gameobject, 找到这些gameObject上的Handler组件, 触发这些Handler.</p><p>不管市面上的UnityUI的方案(比如FGUI)多炫酷, 最终到Unity中都是要走UGUI的底层</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;GraphicRaycaster&lt;/h1&gt;
&lt;p&gt;为什么在创建Canvas节点的时候, 都要GrapihcRaycaster会自动创建&lt;br&gt;
GrapihcRaycaster组件不是必须的, 删除掉之后这个Canvas就不能响应点击了.&lt;/p&gt;
&lt;p&gt;要看明白下面这段逻</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Actor模型</title>
    <link href="https://soincredible.github.io/posts/d6fe94a3/"/>
    <id>https://soincredible.github.io/posts/d6fe94a3/</id>
    <published>2025-07-29T00:59:18.000Z</published>
    <updated>2025-08-11T03:35:33.787Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——欲速则不达</title>
    <link href="https://soincredible.github.io/posts/5b1bb5d7/"/>
    <id>https://soincredible.github.io/posts/5b1bb5d7/</id>
    <published>2025-07-26T01:00:24.000Z</published>
    <updated>2025-08-22T10:05:44.458Z</updated>
    
    <content type="html"><![CDATA[<h1>坚持下去 总会有成效的</h1><p>短期内看不到成效<br>看代码也是 画UML图 画着画着 画到一定规模 YooAsset的架构就豁然开朗了</p><h1>学吉他</h1><p>缺少耐心了</p><h1>要吃屎</h1><p>对一些业务不感兴趣 不行 要硬着头皮去做一些不想做的事情</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;坚持下去 总会有成效的&lt;/h1&gt;
&lt;p&gt;短期内看不到成效&lt;br&gt;
看代码也是 画UML图 画着画着 画到一定规模 YooAsset的架构就豁然开朗了&lt;/p&gt;
&lt;h1&gt;学吉他&lt;/h1&gt;
&lt;p&gt;缺少耐心了&lt;/p&gt;
&lt;h1&gt;要吃屎&lt;/h1&gt;
&lt;p&gt;对一些业务不感兴趣 不行 要硬</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUGUI解构(一)——RectTransform</title>
    <link href="https://soincredible.github.io/posts/67d7d086/"/>
    <id>https://soincredible.github.io/posts/67d7d086/</id>
    <published>2025-07-15T13:56:01.000Z</published>
    <updated>2025-08-11T03:35:33.788Z</updated>
    
    <content type="html"><![CDATA[<p>RectTransform继承自Transform, 并没有包含在UGUI体系里面, 但是RectTransform的字段绝大多数情况下只在UGUI体系中才有意义.  因此我们可以将RectTransform看作是Unity UGUI的一部分, 并且将其作为UGUI系列中首个分析的对象.</p><h1>锚点(Anchor)与中心点(Pivot)</h1><h2 id="锚点Anchor">锚点Anchor</h2><p>这个Anchor并不是直接参与位置信息运算的数据, Unity会先根据这个信息计算出一个anchorReferencePosition, 再用这个值进行其他的运算.<br>在Unity中 锚点是可以至多被分成四个角的, 并不是一个点. 而在计算一个RectTransform中的一些属性时需要把锚点作为一个&quot;点&quot; 参与运算, 作为四个角不重合的情况, 需要有一个Anchor Reference Position来作为锚点,<br>Anchor Reference Position的计算公式如下:<br>$$ AnchorReferencePosition_x = (1 - pivot_x) \times x_0 + pivot_x \times x_1 $$<br>$$ AnchorReferencePosition_y = (1 - pivot_y) \times y_0 + pivot_y \times y_1 $$<br>其中 (x0, y0)代表的是AnchorMin在该RectTransform的父节点中的位置, (x1, y1)代表的是AnchorMax在该RectTransform的父节点中的位置, (pivotx, pivoty)指的是中心点的归一化位置坐标</p><p>有一个概念叫AnchoredPosition, 这个值的含义是Pivot点相对于<code>Anchor Reference Position</code>的距离, 当锚点的四个角没有重合在一点时, 我们可能会以为Anchor Reference Position</p><p>AnchoredPosition和Local Position的区别是什么?<br>在Transform(非RectTransform)体系中, 子物体的localPosition只能通过调整其和父物体的相对位置来实现变化, 在RectTransform体系下, 子物体的localPosition除了受相对位置的影响, 还与父物体的width、子物体本身的pivot有关</p><h1>RectTransform中的字段</h1><blockquote><p>💡本文我们只讨论RectTransform中有而Transform中没有的字段</p></blockquote><ul><li>rect Rect 注意RectTransform中的rect成员不支持直接修改注意以上字段都是不可以通过RectTransform操作其值的., 因为没有set属性, 外部没有对它的访问权限<ul><li>xMin, 代表的是rect围成矩形区域的左下角的横坐标值, 坐标系原点是这个rect围成的矩形区域的中心点,</li><li>yMin, 代表的是rect围成矩形区域的左下角的纵坐标值, 坐标系原点是这个rect围成的矩形区域的中心点,</li><li>mHeight, 这个rect围成矩形的高</li><li>mWidth, 这个rect围成矩形的宽</li></ul></li><li>anchorMin Vector2 以当前RectTransform的父节点的rect的左下角为坐标原点, 锚点左下角的归一化位置坐标</li><li>anchorMax Vector2 以当前RectTransform的父节点的rect的左下角为坐标原点, 锚点右上角的归一化位置坐标</li><li>sizeDelta Vector2 当锚点四角重合时, sizeDelta.x=rect.width=(offsetMax-offsetMin).x, sizeDelta.y=rect.height=(offsetMax-offsetMin).y 当不重合时 sizeDelta.x=(offsetMax-offsetMin).x, sizeDelta.y=(offsetMax-offsetMin).y</li><li>offsetMin Vector2 指锚点左下角与rect的左下角的偏移值 以当前RectTransform的父节点的rect的左下角为坐标原点</li><li>offsetMax Vector2  指锚点右上角与rect的右上角的偏移值 以当前RectTransform的父节点的rect的左下角为坐标原点</li><li>anchoredPosition Vector2</li><li>anchoredPosition3D Vector3 包含anchoredPosition的xy分量, 增加了z分量 一般用不到<br>localPosition的含义是当前RectTransform的pivot相对于该RectTransform的父节点rect的中心点的位置, 由于可以调整父节点的rect, 所以可以间接影响子物体的localPosition属性, 而我也可以让rect的绝对位置不变 通过改变pivot的位置来影响localPosition的值, 这在Transform(非RectTransform)体系下是不太可能做到的,</li></ul><p>锚点(Anchor)描述的是当前UI节点和其父节点的位置关系, 锚点虽然叫点, 但是会存在锚点的四个角没有重合的情况. 只不过锚点的四角重合时anchor reference position和该点重合了而已 unity会计算出一个anchor reference point, 和pivot做运算得到anchored position<br>中心点(Pivot)描述的是当前UI节点的轴心位置 与父节点无关</p><h1>IDragHandler</h1><p>在此猜测 , IDragHandler的生效逻辑是什么</p><p>每一帧 Unity都会从摄像机出发生成一个射线 由你的pointer投射到场景中的gameObject上, 每一帧你都会拿到这些信息 拿到这些物体, 查看这些物体上挂载的组件有没有实现IDragHandler接口, 如果有, 出发这个IDragHnader的fafa</p><p>在Unity源码中 搜 localIdentifierInFile</p><p>BuildSerialization.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConvertSceneObjectsToInstanceIDBuildRemap</span><span class="params">(<span class="type">const</span> core::string&amp; path, <span class="type">const</span> WriteDataArray&amp; sceneObjects, InstanceIDBuildRemap&amp; output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pathIndex = <span class="built_in">GetPersistentManager</span>().<span class="built_in">GetSerializedFileIndexFromPath</span>(path);</span><br><span class="line"></span><br><span class="line">    output.<span class="built_in">reserve</span>(output.<span class="built_in">size</span>() + sceneObjects.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (WriteDataArray::const_iterator i = sceneObjects.<span class="built_in">begin</span>(); i != sceneObjects.<span class="built_in">end</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Assert</span>(i-&gt;localIdentifierInFile != <span class="number">0</span>);</span><br><span class="line">        output.<span class="built_in">push_unsorted</span>(i-&gt;instanceID, <span class="built_in">SerializedObjectIdentifier</span>(pathIndex, i-&gt;localIdentifierInFile));</span><br><span class="line">    &#125;</span><br><span class="line">    output.<span class="built_in">sort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResourceManager.cpp中的void BuiltinResourceManager::InitializeResources()方法</p><p>下面这段代码, 推测应该是Unity给资产生成FileId的逻辑<br>明天验证一下 对于大部分的FBX中的mesh资源, 他们应该都是叫同样的名字, 又因为他们都是mesh, 所以传入的参数一样, 所以在meta文件中, 你可以看到, 即便是引用了不同的fbx的mesh, 变的只有guid, fileid都是一样了<br>明天验证一下, 两个mesh名不一样的fbx, 应该fileId就会不一样, 而且改了mesh的名字, fileId的名字也就会跟着变</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RectTransform继承自Transform, 并没有包含在UGUI体系里面, 但是RectTransform的字段绝大多数情况下只在UGUI体系中才有意义.  因此我们可以将RectTransform看作是Unity UGUI的一部分, 并且将其作为UGUI系列中首</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSharp合集</title>
    <link href="https://soincredible.github.io/posts/d97e22f1/"/>
    <id>https://soincredible.github.io/posts/d97e22f1/</id>
    <published>2025-07-15T13:43:56.000Z</published>
    <updated>2025-07-15T13:47:59.495Z</updated>
    
    <content type="html"><![CDATA[<p>CSharp问题杂记<br><a href="20505312">CSharp前传</a><br>CSharp中的委托<br>CSharp中的CancellationToken<br>CSharp中的Task<br>Dissecting-the-async-methods-in-CSharp<br>Extending-the-asynce-methods-in-CSharp-译</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CSharp问题杂记&lt;br&gt;
&lt;a href=&quot;20505312&quot;&gt;CSharp前传&lt;/a&gt;&lt;br&gt;
CSharp中的委托&lt;br&gt;
CSharp中的CancellationToken&lt;br&gt;
CSharp中的Task&lt;br&gt;
Dissecting-the-async-met</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>代码热更新合集</title>
    <link href="https://soincredible.github.io/posts/99b1bffa/"/>
    <id>https://soincredible.github.io/posts/99b1bffa/</id>
    <published>2025-06-23T11:07:40.000Z</published>
    <updated>2025-07-28T06:44:13.278Z</updated>
    
    <content type="html"><![CDATA[<h1>XLua、ILRuntime、HybridCLR热更原理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;XLua、ILRuntime、HybridCLR热更原理&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSharp前传</title>
    <link href="https://soincredible.github.io/posts/20505312/"/>
    <id>https://soincredible.github.io/posts/20505312/</id>
    <published>2025-06-22T00:31:38.000Z</published>
    <updated>2025-07-15T13:47:59.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《CLR via C#》这本书帮助读者建立起了C#的知识框架, 是笔者职业生涯中功不可没的好书, 不过本书的作者Jeffrey <a href="http://xn--Richter-oc5k144o.Net">Richter是以.Net</a> Framework框架在Windows平台进行开发的视角上介绍.Net的一些特性的, 而笔者作为一个Unity入门C#的半吊子在最初阅读本书的很长一段时间内是没有真正理解.Net的核心特性的. 在本篇博客中, 笔者尝试基于这本书, 加上笔者对Unity的理解, 站在Unity开发者的视角上, 诠释.Net中的一些关键性概念.</p></blockquote><h1>.NET往事</h1><p>在《CLR via C#》<a href="http://xn--1jq840bfog6d140aln3a9iqxvd2rli4epa472o.Net">这本书里面并没有详细解释.Net</a>、.NetCore、.Net Standard、.Net Framework一系列的概念, 之所以有这么多的概念, 也是有历史原因的, 了解.Net的发展史能帮我们更好地理解这些概念、<br>.Net是.Net C#是C#, .Net是一套支持C#代码运行的框架体系, 除此之外.Net还支持F#、VB等语言</p><p>.Net Framework、 .NetCore、 .Net这三者是对同一个对象在不同发展时期的不同称谓, 这一对象在不同发展时期具有不同的特点.<br>他们是同种概念的不同形态</p><h2 id="Net-Framework时期">.Net Framework时期</h2><p>早期的.Net只能运行在<br>此时的.Net只能够运行在Windows上, 而且C#代码的运行方式是JIT模式</p><h2 id="Mono的出现">Mono的出现</h2><p>由于.Net完全闭源, 有一群人从零手搓了一个, 使用体验跟.Net一模一样的Mono, 而且还支持跨平台, 就跟汉堡王和肯德基一样, 都是汉堡薯条, 吃起来大同小异, 但是做法原料可能完全不同, 也就是说, Mono和.Net可能底层实现不一样, 但是上层要实现的功能是完全一样的: 为C#(笔者这里就只说C#了)提供一套能够正确运行的环境, 知道这个就行了.</p><h2 id="Net-Core是啥">.Net Core是啥</h2><p>.Net Core在原来.NetFramework的基础上, 增加了对于跨平台的支持</p><h2 id="Net-是啥">.Net 是啥</h2><p><a href="http://xn--6kqv66j.Net">至于.Net</a>, 是目前的大一统状态, 里面</p><p>经过一段时间的演变, .Net <a href="http://xn--Core-ts5fw5zn9ou7k.Net">Core就变成了.Net</a></p><table><thead><tr><th>组件名称</th><th>作用</th><th>说明</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>CoreCLR / .NET Runtime</td><td>托管运行时/虚拟机，负责执行IL，中间语言JIT，GC</td><td><a href="https://github.com/dotnet/runtime%EF%BC%88%E5%B7%B2%E5%BC%80%E6%BA%90%EF%BC%89">https://github.com/dotnet/runtime（已开源）</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CoreFX / 基类库（Base Class Library, BCL）</td><td>常用系统API：IO、网络、集合、字符串等</td><td>现代叫runtime中的“libraries”</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="http://ASP.NET">ASP.NET</a> Core</td><td>Web开发框架</td><td>支持Web服务器、API、MVC、Blazor、SignalR、gRPC等平台</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Entity Framework Core</td><td>对象关系映射（ORM）数据库组件</td><td>支持SQLServer、SQLite、MySQL等主流数据库</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>WinForms、WPF（Windows Only）</td><td>桌面GUI开发</td><td>.NET 5+支持基本移植，但仅限Windows</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MSBuild</td><td>构建系统</td><td>dotnet build 就是用的这个</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Roslyn</td><td>C#、VB.NET编译器和代码分析器</td><td><a href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>NuGet</td><td>包管理工具</td><td>在线/本地包管理</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CLI</td><td>命令行工具（dotnet）</td><td>包括dotnet、dotnet build、dotnet run等基础命令</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="Mono是啥">Mono是啥</h2><p>Mono 项目始于 2001 年，由 Ximian 公司的创始人 Miguel de Icaza 领导。Ximian 是一家专注于 Linux 和开源软件的公司。Miguel de Icaza <a href="http://xn--4gqvd70lutrsxi5wc1t2biya.NET">的目标是创建一个.NET</a> 框架的开源实现，以便在 Linux 上运行。</p><p>.NET 框架最初由微软开发，主要用于构建 Windows 应用程序。<a href="http://xn--6kqu55g.NET">由于.NET</a> 框架的闭源性，它无法直接在其他操作系统上运行。Mono 项目的出现打破了这一限制，<a href="http://xn--2rq350b.NET">使得.NET</a> 开发者的代码能够在多种平台上运行。</p><p>随着时间的推移，Mono 项目得到了广泛的社区支持，并且不断发展和完善。它支持多种编程语言，包括 C#、Visual <a href="http://Basic.NET">Basic.NET</a> 和 F#，<a href="http://xn--phqsk73ztrc71ev35bpf9a.NET">并且实现了许多.NET</a> 框架的功能。Mono <a href="http://xn--fiqqezet6cs0gs0ag5r80qxpgh48a7jsgeb81q2u9fc90a.NET">项目在开源社区中的成功也促进了.NET</a> 技术在非 Windows 平台上的普及。</p><p><a href="http://xn--xft85uwsaj08j.xn--Net-6g3ei87f2r7a.Net">还有就是.Net升级是.Net</a> C# language升级是language<br>一般来说, 先是C#的语言有更新, 必须新增了某种语法或者语言特性 那么配套的.Net中就需要支持能够识别并驱动这些语法, 因此一般C#有新特性增加对应的.Net也有新的升级</p><p>说白了 .Net、.NetCore、.NetFramework、Mono每一个都是一套让C#代码能够运行跑起来的平台. 这就好比各家虚拟机平台, 而C#就像是你在微软官网上下载的Windows操作系统的镜像文件, 你可以将这个镜像文件挂载在VMWare平台上, 也可以挂载在Parallel Desktop平台上, 即便平台的底层实现不同, 但是因为它们都遵循同样的规范, 因此同样的一操作系统镜像文件可以跑在不同的虚拟机平台上, 这些平台遵循的规范, 类比到.Net中也就是<code>.Net Standard</code></p><h2 id="Net-Standard">.Net Standard</h2><p>.Net Standard 是针对多个 .Net实现推出的一套正式的.Net API规范. 推出.NetStandard的背后动机是要提高.Net生态系统中的一致性.<br>由上面的陈述可知, .Net有很多的实现, 为了能够让不同实现的.Net能够协同工作, .Net Standard出现了. 比如在Unity开发中, 你需要使用一个托管的dll, 这个dll使用.Net环境开发, 而Unity是Mono环境, 为了让dll中的代码能够和Unity中的代码正确协同, <a href="http://xn--Unitydll-b50n2ky0c413fdixom8b6r7cmhhzivd30a.Net">只需要让Unity和dll遵循同样的.Net</a> Standard版本就可以了. 在Unity的BuildSettings中的APICompatibilityLevel就是这个作用, 不同的Unity版本可以对标的.Net版本也不太一样. 比如在<code>2020.3.48</code>版本中, <code>API Compatibility Level</code>的选项是<code>.Net 4.X</code>和<code>.Net Standard 2.0</code>, 而在<code>2022.3.15</code>版本中, <code>API Compatibility Level</code>的选项则变成了<code>.Net Standard 2.1</code>和<code>.Net Framework</code>. 所以这么一看你所使用的插件必须要有<code>API Compatibility Level</code>相对应的版本才能够在Unity中使用.<br><a href="http://xn--zbs584j.Net">说回.Net</a>, .Net5采用的不同的方法来建立一致性, <a href="http://xn--ghqe42iv2dxrl2vvsdhtrtvcvrs3cu50i0xyjnofs9cchveoes67a.Net">这种新方法在很多情况下都不需要使用到.Net</a> Standard.</p><p>你的Unity工程，允许代码能用（兼容）的 .NET（或Mono）API集合的标准程度。</p><p>Unity的脚本运行环境（Scripting Backend）是基于Mono（或IL2CPP）来实现C#环境的；<br>但Mono和微软官方.NET实现的API/标准并不是完全一致的，有新有旧、有全有残；<br>API Compatibility Level，就是让你指定用哪一套标准的API接口子集：<br>比如：.NET 2.0 Subset<br>又比如：.NET 4.x / .NET Standard 2.0<br>或者更高（随着Unity版本演进而变化）<br>这些选项，<a href="http://xn--Unity-fg1hjcs88bgjegyy9a11h01wpp1glkcu71cohh804h.NET">实际上背后对应着一组Unity定制的.NET</a> Base Class Library (BCL)，决定你在C#脚本里能不能引用、编译、反射、调用某些标准库功能。</p><p>新项目：优先选“.NET 4.x”或“.NET Standard 2.0”。<br>项目中有现代C#语法（如async/await、LINQ等）：必须选新标准。<br>做插件/SDK跨Unity兼容：优先考虑“.NET Standard 2.0”。<br>有老DLL、Asset Store资产只支持2.0，且不想升级：临时用“.NET 2.0”。<br>手机版本极度精简、追求最小包体：用Subset，但很少有这种极端需求。</p><h1>一个C#工程使用的.Net版本怎么看?</h1><p>注意.Net版本和C#LanguageVersion是两个东西,<br>对于使用Rider创建的C#项目,</p><p>Unity的.NetVersion能不能改?</p><h1>一个C#工程使用的.Net版本怎么修改?</h1><h1>C#项目的组织结构</h1><h1>Unity项目的代码组织结构</h1><h2 id="sln-csproj-dll-asmdef-pdb的区别和联系">.sln .csproj .dll .asmdef .pdb的区别和联系</h2><h2 id="dll">.dll</h2><p>如果你的C#项目选择的是ClassLibrary, 那么构建这个C#项目的时候, 构建结果就是.dll,<br><a href="https://github.com/shimat/opencvsharp/releases">这是C#版本的OpenCV库</a>, 下载他的release你会发现,里面还带一个pdb文件.<br>.sln 是<br>.csproj 一个sln下会有多个csproj<br>.asmdef 这是Unity中的一个概念, 每创建一个asmdef, Unity都会自动生成这个asmdef对应的csproj<br>.dll dll一般有两种: 使用C#编译生成的dll, 这类dll属于托管类dll, 导入Unity能够直接被Unity编译器识别; 还有一类是使用c/c++等非托管类语言编译生成的dll, 这类dll需要C#具有能够调用原生(native)代码的能力, 需要使用<code>[DLLImport]</code>属性来导入方法</p><p>对于简单的项目 完全没必要创建sln 但是像Rider、Visual Studio这些IDE是没有提供只创建csproj的选项的, 这就有点大材小用了 我们可以通过使用命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dotnet new console</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建后是一个dll</span></span><br><span class="line">dotnet new classlib</span><br></pre></td></tr></table></figure><p>这种方式只创建csproj, 然后使用Rider或者VS打开这个csproj, 就可以绕过生成sln文件<br>.sln（Solution）文件是 Visual Studio/VS Code/Coderush Rider 等IDE用来管理一组相关项目（.csproj）的容器。比如你要做大型架构、包括多个类库、应用，以及单元测试项目时，.sln文件可以统一管理它们的依赖与结构。<br>但是，小项目、单个项目时，完全可以不建 .sln，只用一个 csproj 文件照样编译、运行、开发（如命令行下dotnet build XX.csproj，VS Code 也能直接打开）。<br>实例1：你在任意文件夹里新建dotnet new console，它会创建Program.cs和XX.csproj，没有.sln，也能正常dotnet run/build。<br>只有需要管理多个项目（比如引用类库或测试工程等），用.sln会更方便。</p><p>pdb 文件是什么？</p><p>PDB（Program Database）是Windows/Visual Studio环境下的“程序数据库”文件。<br>内容：主要存储了可执行文件（exe/dll等）的调试信息，如：<br>源文件名/路径<br>行号<br>局部变量、函数参数名<br>类型信息<br>符号表、断点等信息<br>目的是：进行调试时，IDE/调试器能还原源代码对应关系、栈、变量名等，是“调试辅助文件”。<br>3. dll 和 pdb 的关系</p><p>当你用 Visual Studio 编译一个 dll 时（Debug 模式），通常会生成同名的 pdb 文件。<br>这个 dll 文件是真正的动态库，pdb 文件不给程序加载，只在调试/分析时让开发者用。<br>没有 pdb，发布的 dll 依然可以运行，只是调试难度大。</p><h1>C#代码是怎么跑起来的?</h1><p>在《CLR via C#》中, 作者只提及了JIT, 因为AOT方式是在2022年在.Net7发布的, 本书的成书时间应该是2014年, 没有提及AOT也是很正常的</p><h2 id="JIT模式">JIT模式</h2><p>在Unity中, 这对应的就是Mono的构建方式</p><p>JIT方式打包, 在打包阶段, 我们编写的C#代码会被编译成IL, 打入一个.dll的文件, 这就是Mono的打包方式, 使用这种方式打的包, 包体小, 但是由于其代码不是原生的, 所以运行时需要依赖CLR将IL代码编译成原生代码执行, 比起AOT方式 在启动时间上会久一点, 因为需要编译, 但是只要编译了一次之后, 执行效率和AOT是没什么区别的</p><p>笔者认为在一开始.Net可能就只支持JIT的方式执行C#代码, 而AOT和解释器方式则是跨平台的概念引入到.Net中后, 才出现的概念.</p><p>随着.Net支持跨平台. 想要在MacOS、iOS上运行.Net程序, 使用JIT的方式就不行了, 因为苹果是不允许程序运行时动态加载代码的, 所有代码必须被编译成机器码原生地执行. 这就是AOT模式</p><h2 id="AOT模式">AOT模式</h2><p>微软是在.Net7版本中实现了AOT功能.</p><p>在Unity中, 这对应的就是IL2CPP的构建方式</p><p>我们就拿Unity开发举例子, 如果使用AOT的方式打包, 那么在打包阶段, 我们编写的C#代码就会全部被编译成机器码, 也就是.so文件, 这种代码就是原生的代码, 丢到机器上就就能立刻运行, 不需要编译, 但是机器码都是01, 存储效率低, 由我们的C#脚本转成机器码会造成代码膨胀, 听起来是不是很像IL2CPP?</p><p>那在AOT推出之前, Unity是怎么实现在iOS平台上发布的呢? Mono是专门提供了</p><h1>代码热更</h1><h2 id="Interpreter模式">Interpreter模式</h2><p>解释器, 笔者第一次看到这个概念出现在C#中时, 是非常疑惑的, 因为笔者理解的解释器, 是像Python那种解释型语言才会使用到的东西, 而C#作为一个编译型语言, 其实C#并不是传统意义上的编译型语言, 因为C#是先编译成IL中间语言, 然后在运行时通过JITCompiler将中间语言编译成机器码执行的方式.</p><p>也就是, C#不解释型语言那样直接解释源代码执行, 也不像C++那样一次性把源代码编译成机器码执行.</p><p>解释器模式可以理解为是在Unity开发中代码热更新场景下, 业内开发者为了能够执行热更代码(dll)而开发的一种迷你版的CLR(虚拟机).<br>我再理解一下解释器的角色, 解释器就是在AOT打包方式下, 主包的.Net的虚拟机被剔除丧失了解析编译IL(dll)的能力, 需要一个迷你版的虚拟机(也就是解释器)来执行IL代码</p><h1>JIT和解释器的区别是啥呢? 不都是运行时编译代码嘛?</h1><p>JIT方式是有完整的Mono或者CLR虚拟机的机制, 而解释器则是一种针对Unity热更场景下的迷你版虚拟机机制.</p><h2 id="Lua、XLua">Lua、XLua</h2><h2 id="ILRuntime">ILRuntime</h2><h2 id="HybridCLR">HybridCLR</h2><h1>C#的执行机制</h1><p>C#代码会被编译成IL语言, 在运行的时候, 通过一个Interpreter(解释器)逐行解释IL指令运行<br>在IOS上, 是不允许JIT的方式运行代码的, 只能使用AOT的方式运行<br>在Android等其他设备上AOT和JIT都是可以的</p><h1>如今行业内主流的热更方案究竟是怎么形成的?</h1><ul><li>由于IOS对于JIT的限制, 导致主包必须使用AOT的方式打包, <a href="http://xn--AOT-0y9d42pwx1aclan9eb47e78s.Net">而AOT打包会直接把.Net</a> Mono虚拟机剔除掉, 将C#直接转成C++原生代码. 这就会导致主包不具备识别dll能力</li><li>接着, 由于各个操作系统平台对于原生代码的动态加载是有限制的（比如 dlopen 加新 so/dll）, 所以想要在运行时动态的加载一段逻辑进来, 只能使用非原生代码, 于是热更通常选择DLL（IL）</li><li>要让底包能认识和运行“热更dll”里的 C# 代码，就得有.NET虚拟机。但AOT打包让虚拟机相关能力被移除/阉割，不认dll。 但是虚拟机在AOT打包的时候已经几乎被完全剔除掉了, 因此我们必须让它恢复识别dll的功能,</li><li>要想恢复识别dll的能力，就得集成新的虚拟机或解释能力（比如ILRuntime/HybridCLR）。HybridCLR的意义就是让AOT包恢复充分甚至很大程度原生的DLL识别/运行能力。这就是HybridCLR所做的事情在AOT打包模式剔除掉Mono虚拟机识别dll代码能力的情况下, 重写AOT的打包方式, 让其保留能够识别dll代码的能力.</li></ul><h1>代码热更新</h1><p>为什么代码热更新都选择使用JIT(将热更代码编译成dll)的方式, 而不选择AOT原生方式呢?</p><h1>热更的代码和热更的资源 哪个应该先加载?</h1><p>热更代码的调用方式<br>有一种很取巧的方式加载热更代码, 那就是把热更代码挂载到某一个预制体上, 通过Unity的Awake方法调用热更代码的入口<br>AOT程序集 就是底包程序集 AOT是一种代码编译方式 它会</p><p>什么是streaming path? 什么是persistent path?</p><h1>一些Unity中无法内置的dll的处理</h1><p><a href="https://blog.csdn.net/lanchunhui/article/details/53239441">https://blog.csdn.net/lanchunhui/article/details/53239441</a></p><p><a href="https://zh.wikipedia.org/zh-hans/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83">https://zh.wikipedia.org/zh-hans/正态分布</a></p><p><a href="https://blog.csdn.net/qq_17347313/article/details/106995687">https://blog.csdn.net/qq_17347313/article/details/106995687</a><br>C#中正态分布的第三方库</p><h1>正态分布</h1><h2 id="标准正态分布">标准正态分布</h2><h1>正偏态分布</h1><h1>累积分布函数</h1><h1>参考</h1><ul><li><a href="https://www.cnblogs.com/SunSpring/p/15047424.html">.net 温故知新：【2】 .Net Framework 、.Net 、 .NET Standard的概念与区别</a></li><li><a href="https://blog.csdn.net/codywangziham01/article/details/123689658">AOT 和 JIT、 IL2CPP和Mono、 CLR、 ILRuntime热更新原理</a></li><li><a href="https://www.cnblogs.com/fly-100/p/4594380.html">Unity跨平台原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/88692056">Unity从发布到流行经历了什么重大变化（2）</a></li><li><a href="https://blog.csdn.net/gz_huangzl/article/details/52486255">Unity将来时：IL2CPP是什么？有了Mono为什么还需要IL2CPP?</a></li><li><a href="https://blog.csdn.net/Funniyuan/article/details/136002603">.NET 发展历程与未来</a></li><li><a href="https://my.oschina.net/emacs_9244658/blog/18230886">Mono 软件发展历程详解</a></li><li><a href="https://www.cnblogs.com/willick/p/15038133.html">.NET 的发展简史</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;《CLR via C#》这本书帮助读者建立起了C#的知识框架, 是笔者职业生涯中功不可没的好书, 不过本书的作者Jeffrey &lt;a href=&quot;http://xn--Richter-oc5k144o.Net&quot;&gt;Richter是以.Net&lt;/a&gt; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>人性的弱点</title>
    <link href="https://soincredible.github.io/posts/109e75d5/"/>
    <id>https://soincredible.github.io/posts/109e75d5/</id>
    <published>2025-06-18T10:58:23.000Z</published>
    <updated>2025-06-23T13:51:07.889Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityEditor开发中Singleton的设计</title>
    <link href="https://soincredible.github.io/posts/1477ebaf/"/>
    <id>https://soincredible.github.io/posts/1477ebaf/</id>
    <published>2025-06-11T08:14:28.000Z</published>
    <updated>2025-06-23T02:20:26.329Z</updated>
    
    <content type="html"><![CDATA[<h1>在Editor下创建单例</h1><p>灵感来自Unity的<a href="https://sites.google.com/view/monkey-user-guide/getting-started">MonKey插件</a></p><h2 id="使用场景">使用场景</h2><p>我有一些由<code>ScriptableObject</code>、<code>json</code>或者别的格式组织的一组数据, 我希望在Editor模式下开发一套工具, 能让我对这一组数据进行增删改查, 根据MVC架构的思想, 必须有一个<code>Manager</code>来维护这一组数据的增删改查, 并且该<code>Manager</code>的生命周期需要和Unity Editor的生命周期保持一致.</p><h2 id="关键角色">关键角色</h2><ul><li><a href="https://docs.unity3d.com/ScriptReference/InitializeOnLoadAttribute.html"><code>InitializeOnLoad</code></a>属性, 根据官方的描述, 该属性会在UnityEditor打开和代码重新编译的时候初始化Editor脚本. 你需要给这个Editor脚本提供一个静态的构造函数, <strong>注意</strong> 官方提到了 应该避免在InitialzeOnLoad中进行资产加载的操作, 因为InitialzeOnLoad是在资产导入完成前被调用的, 该操作有可能会导致资产加载失败. 要在需要进行资产操作的域重载后进行初始化, 可以使用<code>AssetPostprocessor.OnPostprocessAllAssets</code>回调. 但Unity2020版本中是没有这个接口的, 该回调支持所有资产操作, 并有一个参数提示是否进行了域重载. Unity不能保证 因此使用懒汉模式, 将在初始化操作中不能加载资源的操作变为了在初始化的过程中不能访问Instance的操作, 将加载资源的操作放在首次访问Instance之后 对于一个Editor单例, 如果该单例需要做一些加载操作, 那么就让这个单例实现IAssetProcess接口,</li></ul><p>EditorSingleton的实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;在Editor下创建单例&lt;/h1&gt;
&lt;p&gt;灵感来自Unity的&lt;a href=&quot;https://sites.google.com/view/monkey-user-guide/getting-started&quot;&gt;MonKey插件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;</summary>
      
    
    
    
    <category term="UnityEditor开发" scheme="https://soincredible.github.io/categories/UnityEditor%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityUGUIText实现描边</title>
    <link href="https://soincredible.github.io/posts/9125ebdc/"/>
    <id>https://soincredible.github.io/posts/9125ebdc/</id>
    <published>2025-05-27T15:41:18.000Z</published>
    <updated>2025-06-25T08:21:13.783Z</updated>
    
    <content type="html"><![CDATA[<h1>通过顶点方式实现描边</h1><h2 id="UGUI中自带的Outline">UGUI中自带的Outline</h2><h1>通过Shader方式实现描边</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;通过顶点方式实现描边&lt;/h1&gt;
&lt;h2 id=&quot;UGUI中自带的Outline&quot;&gt;UGUI中自带的Outline&lt;/h2&gt;
&lt;h1&gt;通过Shader方式实现描边&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUGUI解构</title>
    <link href="https://soincredible.github.io/posts/e0e34b4b/"/>
    <id>https://soincredible.github.io/posts/e0e34b4b/</id>
    <published>2025-05-27T07:55:46.000Z</published>
    <updated>2025-07-15T13:47:59.496Z</updated>
    
    <content type="html"><![CDATA[<h1>引子——UGUI中的Text如何被绘制到屏幕上?</h1><p>参与绘制Text的角色:</p><ul><li>VertexHelper</li><li>TextGenerator</li><li>Font和FontData</li><li>BaseMeshEffect</li></ul><p>这是字体使用的Shader</p><figure class="highlight plaintext"><figcaption><span>Shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)</span><br><span class="line"></span><br><span class="line">Shader &quot;GUI/Text Shader&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Font Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Text Color&quot;, Color) = (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line"></span><br><span class="line">        Tags &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;PreviewType&quot;=&quot;Plane&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Lighting Off Cull Off ZTest Always ZWrite Off</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma multi_compile _ UNITY_SINGLE_PASS_STEREO STEREO_INSTANCING_ON STEREO_MULTIVIEW_ON</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata_t &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                fixed4 color : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                fixed4 color : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            uniform float4 _MainTex_ST;</span><br><span class="line">            uniform fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_t v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.color = v.color * _Color;</span><br><span class="line">                o.texcoord = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 col = i.color;</span><br><span class="line">                col.a *= tex2D(_MainTex, i.texcoord).a;</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是所有的UGUI默认使用的Shader</p><figure class="highlight plaintext"><figcaption><span>Shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)</span><br><span class="line"></span><br><span class="line">Shader &quot;UI/Default&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line"></span><br><span class="line">        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8</span><br><span class="line">        _Stencil (&quot;Stencil ID&quot;, Float) = 0</span><br><span class="line">        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0</span><br><span class="line">        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255</span><br><span class="line">        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255</span><br><span class="line"></span><br><span class="line">        _ColorMask (&quot;Color Mask&quot;, Float) = 15</span><br><span class="line"></span><br><span class="line">        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;PreviewType&quot;=&quot;Plane&quot;</span><br><span class="line">            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stencil</span><br><span class="line">        &#123;</span><br><span class="line">            Ref [_Stencil]</span><br><span class="line">            Comp [_StencilComp]</span><br><span class="line">            Pass [_StencilOp]</span><br><span class="line">            ReadMask [_StencilReadMask]</span><br><span class="line">            WriteMask [_StencilWriteMask]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cull Off</span><br><span class="line">        Lighting Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest [unity_GUIZTestMode]</span><br><span class="line">        Blend One OneMinusSrcAlpha</span><br><span class="line">        ColorMask [_ColorMask]</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name &quot;Default&quot;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma target 2.0</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;UnityUI.cginc&quot;</span><br><span class="line"></span><br><span class="line">            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT</span><br><span class="line">            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP</span><br><span class="line"></span><br><span class="line">            struct appdata_t</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : POSITION;</span><br><span class="line">                float4 color    : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : SV_POSITION;</span><br><span class="line">                fixed4 color    : COLOR;</span><br><span class="line">                float2 texcoord  : TEXCOORD0;</span><br><span class="line">                float4 worldPosition : TEXCOORD1;</span><br><span class="line">                float4  mask : TEXCOORD2;</span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _TextureSampleAdd;</span><br><span class="line">            float4 _ClipRect;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float _UIMaskSoftnessX;</span><br><span class="line">            float _UIMaskSoftnessY;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_t v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f OUT;</span><br><span class="line">                UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);</span><br><span class="line">                float4 vPosition = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                OUT.worldPosition = v.vertex;</span><br><span class="line">                OUT.vertex = vPosition;</span><br><span class="line"></span><br><span class="line">                float2 pixelSize = vPosition.w;</span><br><span class="line">                pixelSize /= float2(1, 1) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));</span><br><span class="line"></span><br><span class="line">                float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);</span><br><span class="line">                float2 maskUV = (v.vertex.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);</span><br><span class="line">                OUT.texcoord = TRANSFORM_TEX(v.texcoord.xy, _MainTex);</span><br><span class="line">                OUT.mask = float4(v.vertex.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * half2(_UIMaskSoftnessX, _UIMaskSoftnessY) + abs(pixelSize.xy)));</span><br><span class="line"></span><br><span class="line">                OUT.color = v.color * _Color;</span><br><span class="line">                return OUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f IN) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half4 color = IN.color * (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd);</span><br><span class="line"></span><br><span class="line">                #ifdef UNITY_UI_CLIP_RECT</span><br><span class="line">                half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(IN.mask.xy)) * IN.mask.zw);</span><br><span class="line">                color.a *= m.x * m.y;</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                #ifdef UNITY_UI_ALPHACLIP</span><br><span class="line">                clip (color.a - 0.001);</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                color.rgb *= color.a;</span><br><span class="line"></span><br><span class="line">                return color;</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>参考资料</h1><ul><li><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/TextGenerator.html">Unity TextGenerator API</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;引子——UGUI中的Text如何被绘制到屏幕上?&lt;/h1&gt;
&lt;p&gt;参与绘制Text的角色:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VertexHelper&lt;/li&gt;
&lt;li&gt;TextGenerator&lt;/li&gt;
&lt;li&gt;Font和FontData&lt;/li&gt;
&lt;li&gt;BaseMeshE</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线性代数在游戏开发中的应用</title>
    <link href="https://soincredible.github.io/posts/fd0318d/"/>
    <id>https://soincredible.github.io/posts/fd0318d/</id>
    <published>2025-05-27T03:38:12.000Z</published>
    <updated>2025-06-23T02:20:26.330Z</updated>
    
    <content type="html"><![CDATA[<h1>判断一个向量与坐标轴的重合度</h1><p>向量与每个坐标轴向量进行点积, 注意这里要求参与运算的所有向量都是归一化的, 点积结果会得到一个常数, 对这个常数取绝对值, 结果越大代表与该周向量越重合, 常数的正负代表的是与坐标轴的正方向还是负方向重合度更高.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;判断一个向量与坐标轴的重合度&lt;/h1&gt;
&lt;p&gt;向量与每个坐标轴向量进行点积, 注意这里要求参与运算的所有向量都是归一化的, 点积结果会得到一个常数, 对这个常数取绝对值, 结果越大代表与该周向量越重合, 常数的正负代表的是与坐标轴的正方向还是负方向重合度更高.&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSharp中的CancellationToken</title>
    <link href="https://soincredible.github.io/posts/7331d0f1/"/>
    <id>https://soincredible.github.io/posts/7331d0f1/</id>
    <published>2025-05-24T01:08:07.000Z</published>
    <updated>2025-05-27T01:40:32.452Z</updated>
    
    <content type="html"><![CDATA[<h1>参考资料</h1><p><a href="https://medium.com/@mitesh_shah/a-deep-dive-into-c-s-cancellationtoken-44bc7664555f">A Deep Dive into C#’s CancellationToken</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@mitesh_shah/a-deep-dive-into-c-s-cancellationtoken-44bc7664555f&quot;&gt;A Deep Dive into C#’s Cancell</summary>
      
    
    
    
    
  </entry>
  
</feed>
