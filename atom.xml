<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EddieLee</title>
  
  <subtitle>to infinity and beyond✨🛸.</subtitle>
  <link href="https://soincredible.github.io/atom.xml" rel="self"/>
  
  <link href="https://soincredible.github.io/"/>
  <updated>2025-08-27T02:31:28.955Z</updated>
  <id>https://soincredible.github.io/</id>
  
  <author>
    <name>Eddie Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UnitySourceCode——bindings</title>
    <link href="https://soincredible.github.io/posts/958d72fd/"/>
    <id>https://soincredible.github.io/posts/958d72fd/</id>
    <published>2025-08-27T02:30:47.000Z</published>
    <updated>2025-08-27T02:31:28.955Z</updated>
    
    <content type="html"><![CDATA[<p>Unity中有一种<code>.bindings </code>格式的文件, 这类文件经过某种处理会转换为C#文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">C++RAW</span><br><span class="line"></span><br><span class="line">#include &quot;UnityPrefix.h&quot;</span><br><span class="line">#include &quot;Configuration/UnityConfigure.h&quot;</span><br><span class="line">#include &quot;Runtime/Mono/MonoBehaviour.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/Canvas.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/UIStructs.h&quot;</span><br><span class="line">#include &quot;Runtime/UI/BatchGenerator.h&quot;</span><br><span class="line"></span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">#include &quot;Modules/Profiler/Public/ProfilerImpl.h&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">CSRAW</span><br><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using Object = UnityEngine.Object;</span><br><span class="line"></span><br><span class="line">namespace UnityEngine</span><br><span class="line">&#123;</span><br><span class="line">    ENUM RenderMode</span><br><span class="line">        ScreenSpaceOverlay = 0,</span><br><span class="line">        ScreenSpaceCamera = 1,</span><br><span class="line">        WorldSpace = 2</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    [Flags]</span><br><span class="line">    ENUM AdditionalCanvasShaderChannels</span><br><span class="line">        None = 0,</span><br><span class="line">        TexCoord1 = 1 &lt;&lt; 0,</span><br><span class="line">        TexCoord2 = 1 &lt;&lt; 1,</span><br><span class="line">        TexCoord3 = 1 &lt;&lt; 2,</span><br><span class="line">        Normal = 1 &lt;&lt; 3,</span><br><span class="line">        Tangent = 1 &lt;&lt; 4,</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    // CanvasRenderer is the C++ rendering backend for the UI system.</span><br><span class="line">    [RequireComponent(typeof(RectTransform))]</span><br><span class="line">    [NativeClass(&quot;UI::Canvas&quot;)]</span><br><span class="line">    CLASS Canvas : Behaviour</span><br><span class="line"></span><br><span class="line">        AUTO_PROP RenderMode renderMode GetRenderMode SetRenderMode</span><br><span class="line">        AUTO_PROP bool isRootCanvas GetIsRootCanvas</span><br><span class="line">        AUTO_PTR_PROP Camera worldCamera GetCamera SetCamera</span><br><span class="line">        AUTO_PROP Rect pixelRect GetPixelRect</span><br><span class="line">        AUTO_PROP float scaleFactor GetScaleFactor SetScaleFactor</span><br><span class="line">        AUTO_PROP float referencePixelsPerUnit GetReferencePixelsPerUnit SetReferencePixelsPerUnit</span><br><span class="line">        AUTO_PROP bool overridePixelPerfect GetOverridePixelPerfect SetOverridePixelPerfect</span><br><span class="line">        AUTO_PROP bool pixelPerfect GetPixelPerfect SetPixelPerfect</span><br><span class="line">        AUTO_PROP float planeDistance GetPlaneDistance SetPlaneDistance</span><br><span class="line"></span><br><span class="line">        AUTO_PROP int renderOrder GetRenderOrder</span><br><span class="line"></span><br><span class="line">        AUTO_PROP bool overrideSorting GetOverrideSorting SetOverrideSorting</span><br><span class="line">        AUTO_PROP int sortingOrder GetSortingOrder SetSortingOrder</span><br><span class="line">        AUTO_PROP int targetDisplay GetTargetDisplay SetTargetDisplay</span><br><span class="line"></span><br><span class="line">        OBSOLETE warning Setting normalizedSize via a int is not supported. Please use normalizedSortingGridSize</span><br><span class="line">        AUTO_PROP int sortingGridNormalizedSize GetSortingBucketNormalizedSize SetSortingBucketNormalizedSize</span><br><span class="line"></span><br><span class="line">        AUTO_PROP float normalizedSortingGridSize GetSortingBucketNormalizedSize SetSortingBucketNormalizedSize</span><br><span class="line"></span><br><span class="line">        AUTO_PROP int sortingLayerID GetSortingLayerID SetSortingLayerID</span><br><span class="line">        AUTO_PROP int cachedSortingLayerValue GetCachedSortingLayerValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AUTO_PROP AdditionalCanvasShaderChannels additionalShaderChannels GetAdditionalShaderChannels SetAdditionalShaderChannels</span><br><span class="line"></span><br><span class="line">        CUSTOM_PROP string sortingLayerName</span><br><span class="line">        &#123;</span><br><span class="line">            return scripting_string_new(self-&gt;GetSortingLayerName());</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            self-&gt;SetSortingLayerName(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM_PROP Canvas rootCanvas</span><br><span class="line">        &#123;</span><br><span class="line">            UI::Canvas* root = self-&gt;GetRootCanvas();</span><br><span class="line">            return Scripting::ScriptingWrapperFor(root == NULL ? self : root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static Material GetDefaultCanvasMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetDefaultUIMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static Material GetETC1SupportedCanvasMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetETC1SupportedCanvasMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OBSOLETE warning Shared default material now used for text and general UI elements, call Canvas.GetDefaultCanvasMaterial()</span><br><span class="line">        CUSTOM static Material GetDefaultCanvasTextMaterial()</span><br><span class="line">        &#123;</span><br><span class="line">            return Scripting::ScriptingWrapperFor(UI::GetDefaultUIMaterial());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CSRAW</span><br><span class="line">        public delegate void WillRenderCanvases();</span><br><span class="line">        public static event WillRenderCanvases willRenderCanvases;</span><br><span class="line">        [RequiredByNativeCode]</span><br><span class="line">        private static void SendWillRenderCanvases() &#123; if (willRenderCanvases != null) willRenderCanvases(); &#125;</span><br><span class="line">        public static void ForceUpdateCanvases() &#123; SendWillRenderCanvases(); &#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    CLASS UISystemProfilerApi</span><br><span class="line">        C++RAW</span><br><span class="line">        enum SampleType &#123; Layout, Render &#125;;</span><br><span class="line">        ENUM SampleType</span><br><span class="line">            Layout,</span><br><span class="line">            Render,</span><br><span class="line">        END</span><br><span class="line">        CUSTOM static public void BeginSample(SampleType type)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">            if (UnityProfilerPerThread::ms_InstanceTLS != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                ProfilerInformation&amp; profilerInfo = *profiler_get_info_for_name(type == Layout ? &quot;Layout&quot; : &quot;Render&quot;, type == Layout ? kProfilerUISystemLayout : kProfilerUISystemRender);</span><br><span class="line">                PROFILER_BEGIN(profilerInfo, NULL);</span><br><span class="line">            &#125;</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static public void EndSample(SampleType type)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER</span><br><span class="line">            if (UnityProfilerPerThread::ms_InstanceTLS != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                ProfilerInformation&amp; profilerInfo = *profiler_get_info_for_name(type == Layout ? &quot;Layout&quot; : &quot;Render&quot;, type == Layout ? kProfilerUISystemLayout : kProfilerUISystemRender);</span><br><span class="line">                PROFILER_END(profilerInfo);</span><br><span class="line">            &#125;</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CUSTOM static public void AddMarker(string name, Object obj)</span><br><span class="line">        &#123;</span><br><span class="line">#if ENABLE_PROFILER &amp;&amp; UNITY_EDITOR</span><br><span class="line">            InstanceID instanceID = InstanceID_None;</span><br><span class="line">            std::string nameStr(name);</span><br><span class="line">            if (!obj.IsNull() &amp;&amp; Thread::CurrentThreadIsMainThread())</span><br><span class="line">            &#123;</span><br><span class="line">                instanceID =  obj-&gt;GetInstanceID();</span><br><span class="line">                nameStr += &quot; &quot;;</span><br><span class="line">                nameStr += obj-&gt;GetName();</span><br><span class="line">            &#125;</span><br><span class="line">            UI::GetCanvasManager().AddMarker(nameStr.c_str(), instanceID);</span><br><span class="line">#endif // ENABLE_PROFILER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">    CSRAW</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Unity中有一种&lt;code&gt;.bindings &lt;/code&gt;格式的文件, 这类文件经过某种处理会转换为C#文件&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnitySourceCode——Jobs</title>
    <link href="https://soincredible.github.io/posts/9e38ed66/"/>
    <id>https://soincredible.github.io/posts/9e38ed66/</id>
    <published>2025-08-27T02:30:03.000Z</published>
    <updated>2025-08-27T02:31:28.954Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——如何利用AI提升知识吸收和开发效率</title>
    <link href="https://soincredible.github.io/posts/79d0ad57/"/>
    <id>https://soincredible.github.io/posts/79d0ad57/</id>
    <published>2025-08-26T13:48:52.000Z</published>
    <updated>2025-08-27T02:31:28.956Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>资产清理工作流</title>
    <link href="https://soincredible.github.io/posts/bab9e6d9/"/>
    <id>https://soincredible.github.io/posts/bab9e6d9/</id>
    <published>2025-08-26T03:59:47.000Z</published>
    <updated>2025-08-28T12:10:56.096Z</updated>
    
    <content type="html"><![CDATA[<p>依赖YooAsset的BuildReport 查看那些资源被误打进了包内, 尝试将这些资源剔除掉<br>配合FR2插件</p><ol><li>清理底包资源(被标记为MainTag的资源)</li><li>清理包外资源, 加快Bundle构建流程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;依赖YooAsset的BuildReport 查看那些资源被误打进了包内, 尝试将这些资源剔除掉&lt;br&gt;
配合FR2插件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;清理底包资源(被标记为MainTag的资源)&lt;/li&gt;
&lt;li&gt;清理包外资源, 加快Bundle构建流程&lt;/li&gt;
&lt;/ol&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++合集</title>
    <link href="https://soincredible.github.io/posts/e78f9514/"/>
    <id>https://soincredible.github.io/posts/e78f9514/</id>
    <published>2025-08-23T08:21:10.000Z</published>
    <updated>2025-08-26T01:37:03.680Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/happenlee/p/13278640.html">奇特的递归模板模式 (Curiously Recurring Template Pattern) 是 C++ 的一种看起来很怪异的模板编程技巧</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/happenlee/p/13278640.html&quot;&gt;奇特的递归模板模式 (Curiously Recurring Template Pattern) 是 C++ 的一种看起来很怪异的模板编程技巧&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityRenderPipeline</title>
    <link href="https://soincredible.github.io/posts/d1e0d4f0/"/>
    <id>https://soincredible.github.io/posts/d1e0d4f0/</id>
    <published>2025-08-22T16:25:44.000Z</published>
    <updated>2025-08-26T01:37:03.681Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.html">看完Unity 官方Graphics文档</a></p><h1>Render中的概念</h1><ul><li><p>RenderPipeline</p></li><li><p>Graphics tiers</p></li><li><p>frustum culling</p></li><li><p>occlusion culling</p></li><li><p>reflection probe</p></li><li><p>rendering path</p></li></ul><h1>RenderPipeline就干三件事情</h1><p>剔除 分为视锥体提出(frustum culling)和遮挡剔除(occlusion culling)</p><p>Preventing wasted rendering operations can save on both CPU and GPU time. Unity’s built-in occlusion culling performs runtime calculations on the CPU, which can offset the CPU time that it saves. Occlusion culling is therefore most likely to result in performance improvements when a Project is GPU-bound due to overdraw. Unity官方文档中对于Occlusion Culling的叙述我没明白, 为什么GPU瓶颈的情况 通过使用OcclusionCulling操作可以提高性能? 那它说的Unity’s built-in occlusion culling performs runtime calculations on the CPU, which can offset the CPU time that it saves. 这句话又是什么意思?<br>非常好的问题！你引用的这段Unity官方文档确实点出了 occlusion culling 的一个核心权衡。我们来把它拆解清楚。</p><p>核心问题：为什么GPU瓶颈时，使用OC能提高性能？<br>简单回答：因为 OC从根本上解决的是“过度绘制（Overdraw）”问题，而过度绘制是GPU的主要负担之一。</p><p>让我们详细解释一下：</p><p>什么是过度绘制（Overdraw）？</p><p>它指的是GPU在同一帧中，对屏幕上的同一个像素进行了多次绘制。</p><p>例如，一堵墙前面有一棵树。当相机渲染时，GPU会先绘制远处的墙（像素颜色被设置为“墙”），然后绘制近处的树（像素颜色被覆盖为“树”）。对于被树挡住的墙的部分像素，GPU进行了两次绘制，但最终只有树的颜色是有效的。第一次绘制墙的操作就是“浪费”的渲染，即过度绘制。</p><p>GPU瓶颈与过度绘制的关系：</p><p>当你的游戏是 GPU瓶颈（GPU-Bound） 时，意味着每一帧的渲染速度主要受限于GPU的处理能力。GPU已经满负荷工作，而CPU还有空闲。</p><p>过度绘制会极大地增加GPU的工作量。如果场景复杂，一个像素被绘制5次、10次甚至更多，GPU就需要处理数倍于最终屏幕像素数量的计算（着色、光照、纹理采样等），这直接导致了帧率下降。</p><p>Occlusion Culling（遮挡剔除）如何解决这个问题？</p><p>OC的工作就是在CPU上预先判断：“从相机的视角看，哪些物体被其他物体完全挡住了（即不可见）？”</p><p>判断完成后，CPU会形成一个“最终可见物体列表”并交给GPU。</p><p>GPU只会渲染这个列表里的物体，而那些被完全挡住的物体（例如，房间外的物体、被墙挡住的家具等）根本不会进入渲染管线。</p><p>结果就是：GPU需要处理的物体数量大大减少，过度绘制被极大降低。 GPU的工作负担减轻了，帧率自然就上去了。这就是为什么在GPU瓶颈时，OC能带来显著的性能提升。</p><p>第二句话：“Unity’s built-in occlusion culling performs runtime calculations on the CPU, which can offset the CPU time that it saves.” 是什么意思？<br>这句话描述的是OC的成本或副作用。它意思是：</p><p>“Unity自带的遮挡剔除功能需要在运行时由CPU进行计算，这个计算本身会消耗CPU时间，从而可能抵消掉它（通过减少渲染）为CPU节省下来的时间。”</p><p>我们来分解一下：</p><p>“performs runtime calculations on the CPU”：OC不是一个简单的开关。它需要CPU每帧（或在一定频率下）进行视锥体剔除（Frustum Culling，剔除相机视野外的物体）和更复杂的遮挡剔除计算（使用预先烘焙的数据或运行时算法判断物体之间的遮挡关系）。这些计算是需要消耗CPU计算资源的。</p><p>“offset the CPU time that it saves”：</p><p>OC本来也能为CPU节省时间：因为CPU需要准备渲染数据并提交给GPU（称为Draw Call）。如果OC成功剔除了一半的物体，CPU需要准备和提交的Draw Call也就减少了一半，这部分工作是节省了的。</p><p>但是，进行OC计算本身也需要花费CPU时间。</p><p>如果 OC计算本身消耗的CPU时间 &gt; 因减少Draw Call而节省的CPU时间，那么总体上，CPU的负担反而加重了。</p><p>举个例子：<br>假设没有OC时，CPU一帧需要花 5ms 来提交所有Draw Call。<br>开启OC后：</p><p>CPU需要花 3ms 来执行OC计算。</p><p>由于OC剔除了很多物体，CPU现在只需要花 1ms 来提交剩下的Draw Call。</p><p>CPU总耗时 = 3ms + 1ms = 4ms。 这比之前的5ms要少，性能提升。</p><p>但换一个场景：</p><p>CPU执行复杂的OC计算花了 6ms。</p><p>剔除后，提交Draw Call花了 1ms。</p><p>CPU总耗时 = 6ms + 1ms = 7ms。 这比不开OC时的5ms更糟，性能下降。</p><p>总结与结论<br>对GPU的好处（核心价值）：OC通过减少渲染对象数量，直接降低了GPU的过度绘制，这在GPU瓶颈时效果极佳。</p><p>对CPU的双刃剑效应：OC会带来CPU的额外计算开销。它节省了提交Draw Call的时间，但增加了剔除计算的时间。</p><p>在CPU瓶颈（CPU-Bound）的项目中：如果OC计算本身很重，它很可能得不偿失，导致整体帧率下降。</p><p>在GPU瓶颈或CPU/GPU平衡的项目中：OC节省的GPU时间远大于它带来的CPU开销，从而大幅提升帧率。</p><p>因此，Unity文档的那段话是在教你如何正确地使用这个功能：</p><p>不要无脑地开启Occlusion Culling。你应该先使用Unity Profiler分析你的游戏，确定瓶颈到底是CPU还是GPU。如果主要是GPU瓶颈且由过度绘制引起，那么开启OC很可能带来收益。如果已经是CPU瓶颈了，开启OC可能会让情况恶化。</p><p>所以这是一个此消彼长的过程是吧<br>完全正确！这就是一个非常经典的“此消彼长”或者说“权衡（Trade-off）”的过程。</p><p>你用这个词来形容，非常精准地抓住了 occlusion culling 乃至很多游戏优化技术的核心思想。</p><p>我们可以把这个过程清晰地画出来：</p><img src="/posts/d1e0d4f0/deepseek_mermaid_20250822_5ebda0.png" class=""><p>就像上图展示的，这完全是一个系统性的平衡艺术。优化从来不是免费的，用一个地方的资源（CPU时间）去换取另一个地方的资源（GPU时间）。</p><p>成功的优化就是确保：</p><p>你付出的代价（CPU计算）小于你得到的收益（GPU时间减少）。</p><p>你换取的资源正好是系统最缺的那个（即缓解了系统的瓶颈）。</p><p>所以，Unity 官方文档的那段话，本质上就是在提醒你：不要盲目使用优化技术。一定要先分析（Profile），找到真正的瓶颈（Bottleneck），然后再有针对性地进行优化，否则很可能适得其反。</p><p>You can use occlusion culling to occlude Dynamic GameObjects, but Dynamic GameObjects cannot occlude other GameObjects. If your Project generates Scene geometry at runtime, then Unity’s built-in occlusion culling is not suitable for your Project. Dynamic Gameobject是什么 是我动态加载实例化的东西吗?<br>说得非常对！你的理解基本正确，但我们可以更精确地定义一下。</p><p>什么是 Dynamic GameObject（动态游戏对象）？<br>在Unity occlusion culling（遮挡剔除）的上下文中，Dynamic GameObject 主要指的是在运行时移动、旋转或缩放的物体，而不是指“动态加载实例化”这个动作。</p><p>更准确的区分如下：</p><p>静态遮挡物（Static Occluder）：</p><p>在场景中永远不会移动、旋转或缩放的物体。</p><p>你需要在其Inspector窗口中将 Occluder Static 复选框勾选。</p><p>作用：只有被标记为 Occluder Static 的物体才能在烘焙（Bake）时被计入遮挡数据，从而能够遮挡其他物体。</p><p>例子：场景中的地形、建筑、不会移动的墙壁、大型岩石等。</p><p>动态游戏对象（Dynamic GameObject）：</p><p>在运行时会移动、旋转或缩放的物体。</p><p>或者，即使它不移动，但也没有被标记为 Occluder Static。</p><p>作用（局限性）：</p><p>它可以被静态遮挡物遮挡（例如，一个移动的角色走到墙后面，会被墙遮挡而剔除）。</p><p>但它自身无法作为遮挡物去遮挡其他物体（例如，一辆移动的大卡车开过去，它无法遮挡它后面的房子或树，即使从相机角度看它确实挡住了）。</p><p>例子：玩家角色、敌人、NPC、可移动的车辆、可被拾取的物品、由代码实例化并会移动的对象等。</p><p>针对你提到的两种情况：<br>“是我动态加载实例化的东西吗？”</p><p>你动态实例化（Instantiate）出来的一个物体，如果它在生成后一动不动，并且你将其标记为了 Occluder Static，那么它可以作为遮挡物。（但这种情况很少见，因为通常静态物体直接放在场景里就好，没必要运行时实例化）。</p><p>你动态实例化出来的物体，如果会移动或者没有标记为Static，那它就是Dynamic GameObject。它只能被遮挡，不能遮挡别人。</p><p>“如果您的项目在运行时生成场景几何体，那么Unity的内置遮挡剔除不适合您的项目。”</p><p>这句话的意思是：如果你的游戏关卡、地形、房间布局等主要几何结构是在运行时随机生成或动态加载的（例如程序化生成的地牢、随机地图的沙盒游戏），那么就不适合使用Unity内置的烘焙式 occlusion culling。</p><p>原因：Unity的 occlusion culling 需要预先烘焙（Precompute/Bake）。烘焙过程会基于那些标记为 Occluder Static 的物体来计算它们之间的遮挡关系，并将结果保存成数据。运行时只是查询这些预计算的数据。</p><p>如果场景结构是运行时才确定的，那么就无法进行预先烘焙，这个系统也就失效了。</p><p>总结<br>对象类型能否移动？能否被遮挡？能否作为遮挡物？例子<br>静态遮挡物 (Occluder Static)不能可以（但没必要）可以地形、静态建筑<br>动态游戏对象 (Dynamic GameObject)可以可以不可以角色、车辆、子弹<br>所以，如果你的游戏有很多大型的、会移动的物体（比如巨型机器人、移动的堡垒），你希望它们也能遮挡其身后的东西，Unity内置的OC就无法满足需求了。这种情况下，开发者通常会寻求基于软件光栅化（Software Rasterization）的实时遮挡剔除系统（如Umbra、PVSporta等第三方解决方案，或Unity的Entitiy组件系统ECS下的一些新方法）。</p><p>运行时 动态加载实例化一些预制体出来 Unity也没有什么接口能让我在运行时给这些物体设置静态的操作吗?<br>非常好的问题！这触及了Unity静态系统的一个核心限制。</p><p>简单直接的回答是：没有。Unity 没有提供在运行时（Runtime）通过代码将 GameObject 设置为“静态”（包括 Occluder Static）并使其生效的接口。</p><p>详细解释<br>为什么不行？</p><p>烘焙（Baking）是一个编辑器（Editor-Time）过程：静态标记的真正意义在于，它告诉Unity的光照系统（GI）、遮挡剔除系统（Occlusion Culling） 和导航系统（Navigation） 等，这些物体是静止的，可以针对它们进行预计算。</p><p>这个预计算过程（我们常说的“Bake灯光”、“Bake Occlusion”）非常耗时，它需要分析场景中所有静态物体的几何关系、UV、材质属性等，并生成相应的数据（如光照贴图、遮挡数据、导航网格）。这个过程绝不可能在游戏运行时实时完成，否则会卡住游戏好几秒甚至几分钟。</p><p>gameObject.isStatic 属性存在，但它是“陷阱”<br>你确实能在代码中找到 gameObject.isStatic 这个属性，并且可以设置它。但是！</p><p>它只改变标识，不触发烘焙。你可以在运行时将一个物体 isStatic = true，但这只是一个“标签”。光照、遮挡等系统所使用的预计算数据是在编辑器阶段就生成好的，运行时不会因为你这个标记的改变而重新计算。</p><p>结果是无效的。你把它标记为静态，但它并不会因此就能遮挡其他物体，也不会参与全局光照。它的作用微乎其微，几乎只是为了查询。</p><p>运行时实例化的物体如何参与遮挡？<br>虽然不能成为“遮挡物”，但你动态实例化的物体仍然可以作为“被遮挡者”，这是自动的，无需任何设置。</p><p>流程是这样的：</p><p>你在编辑器烘焙Occlusion Data时，场景里那些标记为 Occluder Static 的墙壁、山体等生成了遮挡数据。</p><p>运行时，你实例化了一个角色（动态物体）。</p><p>Unity的摄像机每帧都会进行视锥体剔除和遮挡查询。</p><p>它会判断你这个角色的包围盒是否被那些预计算好的静态遮挡物挡住。</p><p>如果被挡住，Unity就不会渲染这个角色。</p><p>所以，动态物体享受到了被静态遮挡物剔除的好处，但它自己不能贡献遮挡。</p><p>替代方案与解决方案<br>如果你的项目确实需要在运行时动态生成关卡，并且希望这些新生成的墙体等能作为有效的遮挡物，你有几个选择：</p><p>使用第三方实时遮挡剔除解决方案：</p><p>例如 Umbra（很多3A大作在用）、PVS Studio 等。</p><p>它们的工作原理不同，通常基于软件光栅化等技术，在CPU上实时计算遮挡关系，不依赖预烘焙的数据，因此非常适合动态环境。但这些都是付费插件，并且需要一定的集成和学习成本。</p><p>自己实现简单的遮挡剔除：</p><p>对于简单需求，你可以自己写逻辑。例如：</p><p>距离剔除：如果物体离相机很远，直接隐藏。</p><p>手动区域管理（Room System）：将动态生成的关卡分成多个房间（Room），当相机在一个房间内时，只启用这个房间内的物体，禁用其他所有房间的物体。这是一种粗粒度的“遮挡”。</p><p>设计上的规避：</p><p>这是最常用的方法。既然知道动态生成的物体不能遮挡，就在设计关卡时避免出现“需要一个动态生成的大物体去遮挡大量其他动态物体”的情况。</p><p>确保主要的、大型的遮挡物（如外围城墙、主要建筑结构）是场景中预先放置好并烘焙好的静态物体。而动态生成的部分只是内部的可移动细节。</p><p>结论<br>你不能在运行时创建真正的“静态”物体。Unity的静态系统是一个为编辑器预计算服务的系统。</p><p>对于遮挡剔除：运行时实例化的物体只能是被遮挡者，无法成为遮挡物。</p><p>如果你的项目严重依赖运行时生成几何体并需要它们遮挡，你需要寻求不依赖预烘焙的实时剔除方案，而不是试图去设置静态标志。</p><p>那比如说 场景中有一个被标记为static的物体 我在运行时通过脚本获取到了这个物体 然后用代码去移动这个物体 会有什么问题吗?<br>千万不要这样做！ 这是一个非常错误的操作，会导致一系列问题，但Unity并不会阻止你这么做。</p><p>移动一个在编辑器中被标记为 Static 的物体，会导致“静态”系统的假设完全失效，从而引发各种渲染和逻辑错误。</p><p>会产生的问题：<br>渲染错误（最主要的问题）：</p><p>光照错误（Lighting Artifacts）：静态物体参与了全局光照（GI） 和光照贴图（Lightmapping） 的烘焙。光照贴图上的光线、阴影和反弹光信息都是基于该物体原始的位置、旋转和缩放计算并“烤”在纹理上的。如果你移动了物体，它的模型顶点和光照贴图上的信息就错位了，会导致奇怪的阴影、错误的光照甚至模型变黑。</p><p>遮挡剔除失效（Broken Occlusion Culling）：遮挡数据是基于物体静态时的位置预计算的。你移动它之后，它可能还在原地遮挡着实际上已经可见的物体，或者它本该在新位置遮挡物体却没能起到作用。这会导致本应被剔除的物体被渲染（性能下降） 或本应被渲染的物体被错误剔除（物体消失）。</p><p>性能问题：</p><p>虽然你移动了它，但Unity的许多系统（如GI、OC）仍然会把它当作静态物体来处理，使用那份已经失效的预计算数据。这会导致CPU和GPU在做无用功，甚至比直接使用一个动态物体的性能还要差。</p><p>导航系统问题（如果标记了 Navigation Static）：</p><p>如果这个静态物体还参与了导航网格（NavMesh）的烘焙，那么AI会依然认为它在旧的位置上，从而撞向空气墙（因为物体实际已经移走了）或者穿墙而过（因为物体移动到了一个原本可通行的区域）。</p><p>正确的做法是什么？<br>如果你需要一个物体在游戏开始时是静态的（参与烘焙），但运行时又需要移动它，你必须遵循以下流程：</p><p>在运行时取消其静态标记：在移动它之前，通过代码将其 isStatic 属性设置为 false。</p><p>通知相关系统更新：告诉Unity的各个系统，这个物体的状态已经改变了。</p><p>对于渲染器（Renderer）：通常需要强制刷新或重新计算一些数据，但在Unity中，简单地取消静态标记后，渲染器会将其视为动态物体，使用实时光照而不是光照贴图。这可能会导致视觉效果突变（例如从有烘焙光变到只有实时光）。</p><p>对于导航（Navigation）：如果你移动了一个曾经是导航静态的物体，你可能需要重新烘焙导航网格（NavMesh） 或使用 NavMesh Obstacle 组件来动态阻挡AI。运行时烘焙NavMesh是一个开销很大的操作，需要谨慎使用。</p><p>示例代码：</p><p>csharp<br>public class MoveStaticObject : MonoBehaviour<br>{<br>public GameObject staticObject; // 赋值那个静态物体<br>public Vector3 targetPosition;</p><pre><code>void Start()&#123;    // 1. 在移动前，取消它的静态标记！    staticObject.isStatic = false;    // 2. （可选但重要）通知渲染器等相关组件    // 例如，强制它使用实时光照，停止尝试使用光照贴图    var renderer = staticObject.GetComponent&lt;Renderer&gt;();    if (renderer != null)    &#123;        renderer.lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.BlendProbes; // 使用光照探针        // renderer.reflectionProbeUsage = ...; // 可能需要设置反射探针    &#125;    // 3. 现在可以移动它了    staticObject.transform.position = targetPosition;    // 注意：对于导航，处理起来更复杂，需要添加NavMeshObstacle或RebakeNavMesh。&#125;</code></pre><p>}<br>总结<br>静态标记是一个“契约”：你向Unity承诺这个物体在运行时永远不会变换（移动、旋转、缩放），Unity则通过耗时的预计算来为你优化光照和性能。</p><p>如果你在运行时打破了这份契约（移动了静态物体），Unity基于承诺所进行的优化就会全部出错。 因此，最佳实践是：任何需要在运行时变换的物体，都不要在编辑器里标记为 Static。 如果它最初是静态的，移动前务必先取消其静态标记。</p><p>Camera -&gt; DynamicA -&gt; DynamicB -&gt; Static C -&gt; Dynamic D -&gt; Static E 这个位置关系中, D 、E实际上是不会渲染的, 剩下的A B C 都渲染<br>非常好！你给出的这个例子非常经典，完美地说明了Unity遮挡剔除（Occlusion Culling）的工作原理。</p><p>你的理解是完全正确的。</p><p>在这个位置关系 Camera -&gt; DynamicA -&gt; DynamicB -&gt; Static C -&gt; Dynamic D -&gt; Static E 中，最终的渲染结果很可能是：Dynamic A, Dynamic B, Static C 被渲染，而 Dynamic D 和 Static E 不会被渲染。</p><p>原理逐步分析：<br>让我们一步步分析相机渲染时发生了什么：</p><p>视锥体剔除（Frustum Culling）：</p><p>首先，相机会进行视锥体剔除。我们假设所有物体（A, B, C, D, E）都在相机的视野范围内，所以这一步它们全部通过。</p><p>遮挡查询（Occlusion Query）：</p><p>接下来，Unity的遮挡剔除系统开始工作。它会使用在编辑器里预先烘焙好的遮挡数据（由 Static C 和 Static E 这些静态遮挡物生成）来判断物体之间的可见性。</p><p>它的判断逻辑是从近到远（或者按某种顺序），但核心是：如果一个物体被一个已知的、不透明的遮挡物完全挡住，它就会被剔除。</p><p>具体到你的例子：</p><p>Dynamic A：离相机最近，没有任何东西挡住它。（渲染）</p><p>Dynamic B：它可能在A的后面，但Dynamic物体不能作为遮挡物，所以系统会认为A没有挡住B。B是否被渲染取决于它有没有被静态遮挡物挡住。假设没有，（渲染）</p><p>Static C：它是一个强大的静态遮挡物。系统会检查它是否可见。因为前面的A和B都是动态物，不遮挡它，所以它是可见的。（渲染）</p><p>Dynamic D：系统会检查D的包围盒（Bounds）。由于 Static C 是一个有效的静态遮挡物，并且从相机视角看，D完全在C的后面，因此Unity会判定D被C完全遮挡。（剔除，不渲染）</p><p>Static E：系统同样会检查E的包围盒。它不仅在C的后面，还在D的后面。但判断遮挡时，只要有一个不透明的静态遮挡物（C）挡住了它，它就会被剔除。不需要关心它前面还有一个Dynamic D。（剔除，不渲染）</p><p>核心要点总结：<br>遮挡物的权威性：只有被标记为 Occluder Static 的物体（如你的C和E）才能在遮挡查询中起到遮挡作用。动态物体（A, B, D）即使看起来很大，也完全不会影响遮挡计算。</p><p>查询逻辑：遮挡查询并不关心物体之间的“父子关系”或“逻辑关系”，它只关心它们的世界坐标下的包围盒和从相机出发的射线是否被静态遮挡物阻断。</p><p>性能增益：正是因为这个机制，Static C 成功地将它身后的整个区域（包括D和E）都剔除了，为GPU节省了大量的渲染工作量（避免了overdraw）。这就是 occlusion culling 在GPU瓶颈场景中提升性能的关键。</p><p>所以，你的判断非常准确！这个例子清晰地展示了为何将重要的、大的场景结构标记为 Occluder Static 是如此重要。</p><p>如果场景中没有物体被标记为Static 那么开启摄像机的OcclusionCulling有什么作用呢?<br>这是一个非常好的问题，它触及了Unity occlusion culling 系统的一个关键前提。</p><p>简单直接的回答是：如果场景中没有任何物体被标记为 Occluder Static，那么开启摄像机的 Occlusion Culling 功能几乎没有任何作用，只会白白浪费一点CPU性能。</p><p>详细解释<br>Occlusion Culling 系统的工作分为两个核心阶段：</p><p>预计算阶段（烘焙，Baking）：</p><p>在编辑器里，你点击“Bake”按钮时，Unity会遍历场景中所有标记了 Occluder Static 的物体。</p><p>它会将这些物体的几何信息（简化后的）分解成一个个小块（ cells），并计算它们之间的相互遮挡关系，然后将这些关系保存成一个遮挡数据文件（OcclusionCullingData.asset）。</p><p>如果没有物体被标记为 Occluder Static，这个烘焙过程就无法生成任何有效的遮挡数据。 结果就是一个空的或者无效的遮挡数据文件。</p><p>运行时阶段（查询）：</p><p>在游戏运行时，开启Occlusion Culling的摄像机会查询第一步中生成的预计算数据。</p><p>它会根据相机的位置和视角，快速地从数据中查出：“在这个视角下，哪些静态遮挡物是可见的？哪些区域被它们完全挡住了？”</p><p>然后，它会将那些位于被挡住区域内的物体（无论是静态还是动态）从渲染队列中剔除。</p><p>如果没有预计算的遮挡数据（因为没标记静态物体），这个查询就无数据可查，系统也就无法知道任何遮挡关系。</p><p>那么，开启后还有什么效果？<br>即使没有静态遮挡物，开启Occlusion Culling可能还会有以下极其有限的效果，但这些效果并不依赖它：</p><p>视锥体剔除（Frustum Culling）：</p><p>这是所有摄像机默认永远开启的核心功能，与你是否开启Occlusion Culling无关。</p><p>它的作用是只渲染相机视锥体（视野范围）内的物体。视野外的物体本来就不会渲染。</p><p>你开不开OC，视锥体剔除都在工作。所以这不是OC的功劳。</p><p>非常微弱的动态物体处理：</p><p>理论上，Unity的OC系统可能仍会为动态物体执行一些最基本的包围盒检查。但由于没有静态遮挡物作为参考，它无法判断一个动态物体是否被另一个动态物体挡住（因为动态物体不能作为遮挡物）。</p><p>因此，所有动态物体只要在视野内，就都会被渲染，哪怕它们堆叠在一起。这会导致严重的过度绘制（Overdraw）。</p><p>结论与比喻<br>你可以把这个过程想象成一个捉迷藏游戏：</p><p>静态遮挡物（Occluder Static）：就像是房间里预先把家具、墙壁的位置和大小画好的藏宝图。</p><p>烘焙（Baking）：就是绘制这张藏宝图的过程。</p><p>运行时Occlusion Culling：就是“鬼”看着这张藏宝图，直接知道哪些地方藏了人（被遮挡），不用一个个角落去翻找（渲染）。</p><p>如果你的场景里没有标记任何静态物体，就相当于：</p><p>你告诉“鬼”：“我们玩捉迷藏吧！”，然后递给他一张白纸（空的遮挡数据）。“鬼”拿着这张白纸，依然需要翻遍房间的每一个角落（渲染所有视野内的物体），因为他没有任何信息能帮他排除任何位置。</p><p>因此，开启摄像机的Occlusion Culling功能，但又不提供任何静态遮挡物，是完全没有意义的优化策略。 正确的做法是：将场景中永远不会移动的大型物体（地形、建筑、山体）标记为 Occluder Static，并进行烘焙，这样才能真正发挥OC的强大威力。</p><p>这个Bake操作 是每次打包前必须我自己处理吗? 还是自动处理<br>这是一个非常关键的工作流问题。</p><p>答案是：Bake操作必须由你在Unity编辑器中手动执行。它不会在打包时自动处理，也不会在运行时自动完成。</p><p>详细解释<br>为什么不是自动的？</p><p>极其耗时：烘焙光照（GI）和遮挡剔除（Occlusion Culling）是非常消耗计算资源的进程，可能需要几分钟到几小时不等，取决于场景的复杂度和你的电脑配置。如果每次打包前都自动执行一次，整个开发流程会变得无法忍受的缓慢。</p><p>需要人工审核：烘焙结果常常需要开发者用眼睛去检查。比如光照贴图是否有瑕疵、漏光？遮挡剔除是否正确，有没有不该被剔除的物体被剔除了？这些都需要人工在编辑器里查看和调整参数后重新烘焙，无法全自动完成。</p><p>基于编辑器状态：烘焙过程依赖于物体在编辑器场景（Scene） 中的状态（位置、静态标记、光照参数等）。打包（Build）过程只是将编辑器的最终成果（包括烘焙好的数据文件）打包成一个游戏应用程序。</p><p>烘焙的数据去哪了？<br>当你点击Bake按钮后，Unity会在你的项目资产（Assets） 文件夹中生成对应的数据文件：</p><p>光照烘焙（Lighting Bake）：会在场景文件所在的同级目录生成一个名为 LightingData 的文件夹，里面包含 .exr, .lighting 等光照贴图和数据文件。</p><p>遮挡剔除烘焙（Occlusion Culling Bake）：会在场景文件所在的同级目录生成一个 OcclusionCullingData.asset 文件。</p><p>打包（Build）时，这些数据文件会和场景、模型、纹理等资源一起被包含到最终的游戏包（.apk, .exe等）中。运行时直接读取这些预计算好的数据。</p><p>正确的工作流程<br>你的工作流程应该是这样的，特别是在项目后期：</p><p>在编辑器中进行最终调整：布置好场景中的所有静态物体，设置好灯光参数、 occlusion culling 参数。</p><p>手动执行烘焙：在 Window &gt; Rendering &gt; Lighting 和 Window &gt; Rendering &gt; Occlusion Culling 面板中，点击 Generate Lighting 和 Bake 按钮。</p><p>等待并检查结果：等待烘焙完成，在场景视图中检查烘焙效果是否正确。如果有问题，调整参数后回到第2步重新烘焙。</p><p>保存场景和项目：确保烘焙生成的数据文件已经保存。</p><p>打包（Build）：现在你可以点击 File &gt; Build Settings… &gt; Build 进行打包了。打包器会自动包含所有当前已经烘焙好的数据文件。</p><p>非常重要的注意事项<br>版本控制（Version Control）：烘焙生成的数据文件（光照贴图、OcclusionCullingData.asset）是必须提交到版本控制系统（如Git, SVN） 的文件。这样能保证所有团队成员和构建服务器（CI/CD）拿到项目后，看到的画面和性能是一致的，而无需自己重新烘焙。</p><p>构建服务器（CI/CD）：在自动化的构建流水线上，通常不会执行烘焙操作。构建脚本会直接打包已经由开发者在本机烘焙好并提交到版本库的数据。如果需要在服务器上烘焙，需要专门配置，但这会极大地增加构建时间。</p><p>动态修改：如果你在运行时通过代码实例化或移动了物体，这些变动完全不会影响已经烘焙好的数据。这也是为什么移动静态物体会导致渲染错误的原因。</p><p>总结一句话：Bake 是你在编辑器里为游戏“预处理”数据的创作过程，而 Build 只是将这些处理好的成果“打包发货”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.html&quot;&gt;看完Unity 官方Graphics文档&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Render中的概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——尽信书不如无书</title>
    <link href="https://soincredible.github.io/posts/75ed80d8/"/>
    <id>https://soincredible.github.io/posts/75ed80d8/</id>
    <published>2025-08-22T07:44:50.000Z</published>
    <updated>2025-08-22T10:05:52.649Z</updated>
    
    <content type="html"><![CDATA[<h1>到底该如何阅读</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;到底该如何阅读&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——哪有什么岁月静好,都是有人替你负重前行</title>
    <link href="https://soincredible.github.io/posts/4d82216e/"/>
    <id>https://soincredible.github.io/posts/4d82216e/</id>
    <published>2025-08-20T17:36:58.000Z</published>
    <updated>2025-08-28T12:11:23.449Z</updated>
    
    <content type="html"><![CDATA[<p>起因是, 笔者想要在Unity中实现一些基于UGUI的拖拽效果, 于是开始去思考UGUI是如何实现响应输入的, 接着了解到Unity的EventSystem和一系列EventHandler接口(IPointerClickHandler、 IDragHandler等)来驱动整个System的运转. 笔者在这篇博客中并非是要讨论EventSystem的具体实现. 而是想陈述自己对EventHandler这些接口在UGUI体系中扮演角色的一些迷思. 作为UGUI的使用者, 我只关心如何实现自己想要的功能. 如果我想让一个UI元素可以响应点击, 那我就要创建一个继承自MonoBehaviour的脚本, 挂载到这个UI元素上, 并且还要实现IPointerClickHandler接口, 这样就结束了, 至于怎么样在运行时获取到这个UI元素上的脚本实例, 以及如何触发接口中的方法, 我不关心, Unity会帮我处理. 这就是我对接口最初的理解, <strong>我</strong>只负责接口行为的定义, 我不负责接口行为的调用. 于是有一段时间我经常会遇到这种处境: 在业务的开发中发现一些类型中能抽象出一部分行为封装成接口, 但有可能这些类根本就不是同一个概念下的东西, 或者, 正是由于这种 只考考虑抽离行为 而不考虑接口调用时机和接口持有者的数据组织格式, 导致绝大部分抽离行为封装接口的操作都十分多余.</p><p>接口的行为不止于此 我记得在刚入行的时候, 一个程序员前辈跟我说, 写代码是一个十分繁琐的过程, 但如果你觉得某一部分代码写起来好像不用那么繁琐就能实现你的功能, 那有可能是有人在你不知道的地方帮你做了很多事情. 我上面举的EventSystem就是这样一个例子, UGUI系统通过对外暴露EventHandler接口的方式, 在内部有能够持有接口实例的方法, 你不需要去关心UGUI系统内部是如何持有接口示例的. YooAsset自定义打包Step也是类似的思想, 二者都是通过某种方式持有了外部的对象实例, Unity是通过运行时持有并遍历所有的GameObject, 找到上面的EventHandler来持有它们, 而YooAsset则是在Init时将需要的buildstep实例注册到YooAsset内部去. 两者的思想或许可以表述如下: <strong>外部定义行为, 内部控制流程</strong>.</p><p>最近笔者想要给项目的换皮活动也做一个类似的, 一个活动换皮要有下面几个固定的步骤 导入资源、更新配置表, 定义一个IStep接口, 接口内有一个Action行为, 调用方可以实现多个继承IStep接口的类, 比如导入资源类、更新配置表类, 然后在Action行为中就可以实现是如何导入资源的、如何更新配置表的. 然后将导入资源类和更新配置表类再注册到一个序列化的数据结构或者硬编码的脚本中, 在执行换皮的时候就是从序列化数据或者硬编码脚本中拿到这一套流程信息 传入到 我这套换皮框架中, 外部不用管我内部是如何驱动这套流程信息运转的, 这样的模式和上面举的UGUI、YooAsset的例子大同小异.</p><p>Unity协程、C#的Task也是如此, 只因我被“保护”得太好了, Unity的协程和Task都很好用, 丢进去一个异步的任务, 让他自己在那里执行就好了, 可是异步任务本质上是怎么执行的呢? Unity协程依赖于MonoBehaviour的Update机制, Task依赖于C#内部的线程池. 背后都会有一个间隔一定时间轮询的逻辑, 只是我不需要关心这段逻辑罢了</p><p>我有段时间看了大量讲述C#Task的文章, 现在再去回想其实还是不甚理解, 多去想想</p><p>定义接口的目的, 让一些类型具有某些行为, 并且可以通过声明接口类型, 来持有接口的实例, 一个实例的对象既可以是该实例的class类型, 也可以是其实现的任意一个接口的类型.<br>下面列举了笔者在开发过程中遇到的</p><ol><li><p>C#中的非托管资源在使用的时候可以实现IDisposable接口, 在Dispose接口中, 给了开发者比较统一便捷的方式对不同的非托管资源进行释放的一个点, 另外其中</p></li><li><p>语法糖foreach, 有一个IEnumerable和IEnumerator, 使用IEnumerable标识一个类型的身份,</p></li></ol><p>因此 接口在设计隔离性、统一操作、标识统一身份等场景下能发挥作用.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;起因是, 笔者想要在Unity中实现一些基于UGUI的拖拽效果, 于是开始去思考UGUI是如何实现响应输入的, 接着了解到Unity的EventSystem和一系列EventHandler接口(IPointerClickHandler、 IDragHandler等)来驱动整</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://soincredible.github.io/posts/e255a10a/"/>
    <id>https://soincredible.github.io/posts/e255a10a/</id>
    <published>2025-08-20T16:42:31.000Z</published>
    <updated>2025-09-02T02:21:51.952Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV19d4y1678X/?vd_source=83f4165825ce9df46cf4fd576ccb1102">Skynet入门</a></p><h1>路由器的概念</h1><h1>端口</h1><h1>IP地址</h1><h1>C# Socket编程</h1><h1>什么是Socket</h1><p>一个Socket连接的流程<br>客户端发起</p><p>需要注意的是, 可以多次发起连接请求, 这样就会建立多个Socket, 存在风险</p><h2 id="客户端">客户端</h2><p>Send方法返回只代表成功将数据放到发送缓存区中, 对方可能还没收到数据</p><h2 id="服务端">服务端</h2><p>Accept是建立连接用<br>Receive是接受消息用</p><p>Accept -&gt; Receive</p><p>结合GPT 使用C#使用一个Actor模型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV19d4y1678X/?vd_source=83f4165825ce9df46cf4fd576ccb1102&quot;&gt;Skynet入门&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;路由器的概念&lt;/h1&gt;
&lt;h1&gt;端口</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnrealEngine源码</title>
    <link href="https://soincredible.github.io/posts/43a309b5/"/>
    <id>https://soincredible.github.io/posts/43a309b5/</id>
    <published>2025-08-16T09:39:38.000Z</published>
    <updated>2025-08-27T02:33:09.827Z</updated>
    
    <content type="html"><![CDATA[<p>虚幻引擎的代码使用的是古早版本的C++, 跟现代的C++有些脱节了, 所以可以把虚幻引擎的源代码理解为是C++的一个变种</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚幻引擎的代码使用的是古早版本的C++, 跟现代的C++有些脱节了, 所以可以把虚幻引擎的源代码理解为是C++的一个变种&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在Unity中实现拖拽物体的功能</title>
    <link href="https://soincredible.github.io/posts/aa328bbc/"/>
    <id>https://soincredible.github.io/posts/aa328bbc/</id>
    <published>2025-08-10T08:33:19.000Z</published>
    <updated>2025-08-11T03:35:33.789Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DraggableObj</span> : <span class="title">MonoBehaviour</span>, </span><br><span class="line">        <span class="title">IDragHandler</span>, <span class="title">IBeginDragHandler</span>, <span class="title">IEndDragHandler</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">enum</span> DragState</span><br><span class="line">        &#123;</span><br><span class="line">            None,</span><br><span class="line">            Idle,</span><br><span class="line">            Dragging,</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> DragState dragState = DragState.None;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;拖拽中...&quot;</span>);</span><br><span class="line">            RectTransformUtility.ScreenPointToLocalPointInRectangle(transform.parent.transform <span class="keyword">as</span> RectTransform, eventData.position, Camera.main, <span class="keyword">out</span> Vector2 point);</span><br><span class="line">            transform.localPosition = point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;开始拖拽&quot;</span>);</span><br><span class="line">            transform.localScale = Vector3.one * <span class="number">1.5f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;拖拽结束...&quot;</span>);</span><br><span class="line">            transform.localScale = Vector3.one;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将上面的逻辑进一步抽象一下, 把每个接口内的行为抽离出来, 作为一个action, 在合适的时机传进去.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FigmaAPI阅读</title>
    <link href="https://soincredible.github.io/posts/8d32db40/"/>
    <id>https://soincredible.github.io/posts/8d32db40/</id>
    <published>2025-08-10T08:29:45.000Z</published>
    <updated>2025-08-11T03:35:33.787Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.figma.com/developers/api#intro">https://www.figma.com/developers/api#intro</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.figma.com/developers/api#intro&quot;&gt;https://www.figma.com/developers/api#intro&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity源码阅读</title>
    <link href="https://soincredible.github.io/posts/4d404b8c/"/>
    <id>https://soincredible.github.io/posts/4d404b8c/</id>
    <published>2025-08-10T02:11:30.000Z</published>
    <updated>2025-08-27T02:30:30.264Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayerLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ReentrancyChecker <span class="title">checker</span><span class="params">(&amp;s_InsidePlayerLoop)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!checker.<span class="built_in">IsOK</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ErrorString</span>(<span class="string">&quot;An abnormal situation has occurred: the PlayerLoop internal function has been called recursively. &quot;</span></span><br><span class="line">            <span class="string">&quot;Please contact Customer Support with a sample project so that we can reproduce the problem and troubleshoot it.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FRAME_DEBUGGER_REMOTE_PLAYER</span></span><br><span class="line">    <span class="keyword">if</span> (FrameDebugger::<span class="built_in">IsLocalEnabled</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        FrameDebugger::<span class="built_in">PlayerLoop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">SetWorldPlayingThisFrame</span>(<span class="built_in">IsWorldPlaying</span>());   <span class="comment">// The IsWorldPlaying state can potentially be</span></span><br><span class="line">                                                    <span class="comment">// modified inside the loop, so to ensure consistency</span></span><br><span class="line">                                                    <span class="comment">// we need to store it for the duration of the frame.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//          ---                                               ----</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Do NOT add any logic or branches below, any new code MUST use callbacks</span></span><br><span class="line">    <span class="comment">//          ---                                               ----</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The time should be updated as early as possible to allow the rest of the</span></span><br><span class="line">    <span class="comment">// loop logic to be on the same time for this loop. It is also a must before</span></span><br><span class="line">    <span class="comment">// calling SynchronizeState (used in cluster mode).</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(Initialization, PlayerUpdateTime);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(Initialization, AsyncUploadTimeSlicedUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(Initialization, SynchronizeInputs);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(Initialization, SynchronizeState);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(Initialization, XREarlyUpdate);             <span class="comment">// Potentially invalidates our GfxDevice!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, PollPlayerConnection);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, ProfilerStartFrame);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, GpuTimestamp);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UnityConnectClientUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, CloudWebServicesUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, NScreenUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UnityWebRequestUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, ExecuteMainThreadJobs);        <span class="comment">// Update background tasks</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, ProcessMouseInWindow);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, ClearIntermediateRenderers);   <span class="comment">// In the editor, clear intermediate renderers before loop.</span></span><br><span class="line">                                                                    <span class="comment">// So that in paused state or when resizing windows,</span></span><br><span class="line">                                                                    <span class="comment">// we can still draw the previous ones.</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, ClearLines);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, PresentBeforeUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, ResetFrameStatsAfterPresent);  <span class="comment">// Reset frame stats after present (case 496221)</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UpdateAllUnityWebStreams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////@<span class="doctag">TODO:</span> CLeanup code where input is processed after scene loading</span></span><br><span class="line">    <span class="comment">/// All input should be processed prior to scene loading</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UpdateTextureStreamingManager);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UpdatePreloading);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, RendererNotifyInvisible);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, PlayerCleanupCachedData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the screen manager uses the correct Game View size, which is only known on the managed side.</span></span><br><span class="line">    <span class="comment">// We query it in the game loop rather than setting it from the Game View. This prevents multiple Game Views overwriting the value,</span></span><br><span class="line">    <span class="comment">// or none setting it because no Game View has its tab in front.</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UpdateMainGameViewRect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UpdateCanvasRectTransform modifies the RectTransform of the Canvas.</span></span><br><span class="line">    <span class="comment">// It is done before all Update functions so that UI elements can react to the change in the same frame.</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UpdateCanvasRectTransform);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////@<span class="doctag">TODO:</span> CLeanup code where input is processed after scene loading</span></span><br><span class="line">    <span class="comment">/// All input should be processed prior to scene loading</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UpdateInputManager);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, ProcessRemoteInput);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, XRUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, TangoUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, ScriptRunDelayedStartupFrame);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, UpdateKinect);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, DeliverIosPlatformEvents);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, DispatchEventQueueEvents);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, DirectorSampleTime);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, PhysicsResetInterpolatedTransformPosition); <span class="comment">// Initializes fixed time step loop</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, NewInputBeginFrame);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, SpriteAtlasManagerUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(EarlyUpdate, PerformanceAnalyticsUpdate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is what fixed time stepping is doing</span></span><br><span class="line"><span class="comment">    float time = GetProfilerTime ();</span></span><br><span class="line"><span class="comment">    while (fixedTime &lt; time)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        fixedTime += fixedDeltaTime;</span></span><br><span class="line"><span class="comment">        UpdateFixedBehaviours ();</span></span><br><span class="line"><span class="comment">        UdateDynamicsManager ();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Which means:</span></span><br><span class="line"><span class="comment">      - fixed timestep is always larger than dynamic timestep</span></span><br><span class="line"><span class="comment">      - fixed delta time is always the same</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fixed framerate loop (fixed behaviours, dynamics, delayed calling)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetTimeManager</span>().<span class="built_in">StepFixedTime</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, ClearLines);                       <span class="comment">// Placed here so we ensure it is also called</span></span><br><span class="line">                                                                            <span class="comment">// in edit-mode (fix for case 379024: pressing</span></span><br><span class="line">                                                                            <span class="comment">// stop did not properly clear fixedStepLines)</span></span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, NewInputEndFixedUpdate);</span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, DirectorFixedSampleTime);</span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, AudioFixedUpdate);</span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, ScriptRunBehaviourFixedUpdate);    <span class="comment">// Script.FixedUpdate</span></span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, DirectorFixedUpdate);</span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, LegacyFixedAnimationUpdate);       <span class="comment">// Animation (Root motion)</span></span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, XRFixedUpdate);</span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, PhysicsFixedUpdate);               <span class="comment">// 3D Physics</span></span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, Physics2DFixedUpdate);             <span class="comment">// 2D Physics</span></span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, DirectorFixedUpdatePostPhysics);   <span class="comment">// Animation IK and write bones</span></span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, ScriptRunDelayedFixedFrameRate);   <span class="comment">// Script Coroutines</span></span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, ScriptRunDelayedTasks);            <span class="comment">// Tasks on Synchronization Context</span></span><br><span class="line">        <span class="built_in">CALL_UPDATE_MODULAR</span>(FixedUpdate, NewInputBeginFixedUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dynamics, animation, behaviours</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, PhysicsUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, Physics2DUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, CheckTexFieldInput);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, IMGUISendQueuedEvents);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, NewInputUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, SendMouseEvents);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, AIUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, WindUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreUpdate, UpdateVideo);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(Update, ScriptRunBehaviourUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(Update, DirectorUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(Update, ScriptRunDelayedDynamicFrameRate);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, AIUpdatePostScript);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, DirectorUpdateAnimationBegin);       <span class="comment">// Dynamic Step Animation Update</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, LegacyAnimationUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, DirectorUpdateAnimationEnd);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, DirectorDeferredEvaluate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, UpdateNetworkManager);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, UpdateMasterServerInterface);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, UNetUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, EndGraphicsJobsLate);                <span class="comment">// Latest possible time to end graphics jobs of the previous frame. Must run before any graphics callbacks.</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, ParticleSystemBeginUpdateAll);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PreLateUpdate, ScriptRunBehaviourLateUpdate);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, PlayerSendFrameStarted);            <span class="comment">// For Editor, we call begin frame just before starting</span></span><br><span class="line">                                                                            <span class="comment">// rendering RepaintController. For Runtime we start here.</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, DirectorLateUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ScriptRunDelayedDynamicFrameRate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, PhysicsSkinnedClothBeginUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateCanvasRectTransform);         <span class="comment">// UI update here after late update</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, PlayerUpdateCanvases);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateAudio);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ParticlesLegacyUpdateAllParticleSystems);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ParticleSystemEndUpdateAll);        <span class="comment">// We need to sync particle systems here to</span></span><br><span class="line">                                                                            <span class="comment">// make sure they update their renderers properly</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateSubstance);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateCustomRenderTextures);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateAllRenderers);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, EnlightenRuntimeUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateAllSkinnedMeshes);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ProcessWebSendMessages);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, SortingGroupsUpdate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removed because nothing seems to actually register at this manager</span></span><br><span class="line">    <span class="comment">//GetUpdateManager ().Update ();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateVideoTextures);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateVideo);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, DirectorRenderImage);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ExecuteOneJobInMainThread);         <span class="comment">// Execute one job from the main thread</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, PlayerEmitCanvasGeometry);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, PhysicsSkinnedClothFinishUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, FinishFrameRendering);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, BatchModeUpdate);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, PlayerSendFrameComplete);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateCaptureScreenshot);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, PresentAfterDraw);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ClearImmediateRenderers);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, PlayerSendFramePostPresent);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, UpdateResolution);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, InputEndFrame);                     <span class="comment">// Clear the input string and the key-down events at the end</span></span><br><span class="line">                                                                            <span class="comment">// of the Loop. This makes sure all input string is cleared.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We have two UI systems. IM GUI &amp; the new component based UI system.</span></span><br><span class="line">    <span class="comment">// IM GUI doesn&#x27;t consume the move events. They are consumed by the player loop.</span></span><br><span class="line">    <span class="comment">// But there might be no scripts popping the vents. So clear them at the end of the frame.</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, GUIClearEvents);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ShaderHandleErrors);                <span class="comment">// Handle any shaders with errors discovered</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ResetInputAxis);                    <span class="comment">// We entered Text Field input this frame, Game mode input</span></span><br><span class="line">                                                                            <span class="comment">// is disabled. Reset axes, so they don&#x27;t stick.</span></span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ThreadedLoadingDebug);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ProfilerSynchronizeStats);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, MemoryFrameMaintenance);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ExecuteGameCenterCallbacks);</span><br><span class="line">    <span class="built_in">CALL_UPDATE_MODULAR</span>(PostLateUpdate, ProfilerEndFrame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_PLAYERLOOP_CALL(TYPE_, NAME_, BODY_, ...)                       \</span></span><br><span class="line"><span class="meta">    struct TYPE_##NAME_##Registrator                                             \</span></span><br><span class="line"><span class="meta">    &#123;                                                                            \</span></span><br><span class="line"><span class="meta">        static void Forward (__VA_ARGS__)                                        \</span></span><br><span class="line"><span class="meta">        &#123;                                                                        \</span></span><br><span class="line"><span class="meta">            PROFILE_CALLBACK_AUTO(TYPE_##NAME_##Registrator, #TYPE_ <span class="string">&quot;.&quot;</span> #NAME_); \</span></span><br><span class="line"><span class="meta">            BODY_;                                                               \</span></span><br><span class="line"><span class="meta">        &#125;                                                                        \</span></span><br><span class="line"><span class="meta">    &#125;;                                                                           \</span></span><br><span class="line"><span class="meta">    gPlayerLoopCallbacks.TYPE_.NAME_ = TYPE_##NAME_##Registrator::Forward;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUGUI解构(二)-EventSystem</title>
    <link href="https://soincredible.github.io/posts/28d70de0/"/>
    <id>https://soincredible.github.io/posts/28d70de0/</id>
    <published>2025-08-10T00:42:26.000Z</published>
    <updated>2025-08-20T13:53:56.093Z</updated>
    
    <content type="html"><![CDATA[<h1>GraphicRaycaster</h1><p>为什么在创建Canvas节点的时候, 都要GrapihcRaycaster会自动创建<br>GrapihcRaycaster组件不是必须的, 删除掉之后这个Canvas就不能响应点击了.</p><p>要看明白下面这段逻辑是在干什么</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">Raycast</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isActiveAndEnabled)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t = transform;</span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> ignoreParentGroups = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">bool</span> continueTraversal = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t.GetComponents(components);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> canvas = components[i] <span class="keyword">as</span> Canvas;</span><br><span class="line">            <span class="keyword">if</span> (canvas != <span class="literal">null</span> &amp;&amp; canvas.overrideSorting)</span><br><span class="line">                continueTraversal = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> filter = components[i] <span class="keyword">as</span> ICanvasRaycastFilter;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filter == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> raycastValid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">group</span> = components[i] <span class="keyword">as</span> CanvasGroup;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">group</span> != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">group</span>.enabled)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ignoreParentGroups == <span class="literal">false</span> &amp;&amp; <span class="keyword">group</span>.ignoreParentGroups)</span><br><span class="line">                &#123;</span><br><span class="line">                    ignoreParentGroups = <span class="literal">true</span>;</span><br><span class="line">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!ignoreParentGroups)</span><br><span class="line">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!raycastValid)</span><br><span class="line">            &#123;</span><br><span class="line">                ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = continueTraversal ? t.parent : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>EventSystem的触发机理</h1><p>依赖Raycast给的一些数据, 用这些数据找到Raycast命中的gameobject, 找到这些gameObject上的Handler组件, 触发这些Handler.</p><p>不管市面上的UnityUI的方案(比如FGUI)多炫酷, 最终到Unity中都是要走UGUI的底层</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;GraphicRaycaster&lt;/h1&gt;
&lt;p&gt;为什么在创建Canvas节点的时候, 都要GrapihcRaycaster会自动创建&lt;br&gt;
GrapihcRaycaster组件不是必须的, 删除掉之后这个Canvas就不能响应点击了.&lt;/p&gt;
&lt;p&gt;要看明白下面这段逻</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Actor模型</title>
    <link href="https://soincredible.github.io/posts/d6fe94a3/"/>
    <id>https://soincredible.github.io/posts/d6fe94a3/</id>
    <published>2025-07-29T00:59:18.000Z</published>
    <updated>2025-08-11T03:35:33.787Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>迷思——欲速则不达</title>
    <link href="https://soincredible.github.io/posts/5b1bb5d7/"/>
    <id>https://soincredible.github.io/posts/5b1bb5d7/</id>
    <published>2025-07-26T01:00:24.000Z</published>
    <updated>2025-09-02T03:49:36.153Z</updated>
    
    <content type="html"><![CDATA[<h1>坚持下去 总会有成效的</h1><p>短期内看不到成效<br>看代码也是 画UML图 画着画着 画到一定规模 YooAsset的架构就豁然开朗了</p><p>看不懂的代码, 画UML图, 画着画着, 就清楚了,</p><h1>学吉他</h1><p>缺少耐心了</p><h1>要吃屎</h1><p>对一些业务不感兴趣 不行 要硬着头皮去做一些不想做的事情</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;坚持下去 总会有成效的&lt;/h1&gt;
&lt;p&gt;短期内看不到成效&lt;br&gt;
看代码也是 画UML图 画着画着 画到一定规模 YooAsset的架构就豁然开朗了&lt;/p&gt;
&lt;p&gt;看不懂的代码, 画UML图, 画着画着, 就清楚了,&lt;/p&gt;
&lt;h1&gt;学吉他&lt;/h1&gt;
&lt;p&gt;缺少耐心了&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUGUI解构(一)——RectTransform</title>
    <link href="https://soincredible.github.io/posts/67d7d086/"/>
    <id>https://soincredible.github.io/posts/67d7d086/</id>
    <published>2025-07-15T13:56:01.000Z</published>
    <updated>2025-08-25T02:03:40.795Z</updated>
    
    <content type="html"><![CDATA[<p>RectTransform继承自Transform, 并没有包含在UGUI体系里面, 但是RectTransform的字段绝大多数情况下只在UGUI体系中才有意义.  因此我们可以将RectTransform看作是Unity UGUI的一部分, 并且将其作为UGUI系列中首个分析的对象.</p><h1>锚点(Anchor)与中心点(Pivot)</h1><h2 id="锚点Anchor">锚点Anchor</h2><p>这个Anchor并不是直接参与位置信息运算的数据, Unity会先根据这个信息计算出一个anchorReferencePosition, 再用这个值进行其他的运算.<br>在Unity中 锚点是可以至多被分成四个角的, 并不是一个点. 而在计算一个RectTransform中的一些属性时需要把锚点作为一个&quot;点&quot; 参与运算, 作为四个角不重合的情况, 需要有一个Anchor Reference Position来作为锚点,<br>Anchor Reference Position的计算公式如下:<br>$$ AnchorReferencePosition_x = (1 - pivot_x) \times x_0 + pivot_x \times x_1 $$<br>$$ AnchorReferencePosition_y = (1 - pivot_y) \times y_0 + pivot_y \times y_1 $$<br>其中 (x0, y0)代表的是AnchorMin在该RectTransform的父节点中的位置, (x1, y1)代表的是AnchorMax在该RectTransform的父节点中的位置, (pivotx, pivoty)指的是中心点的归一化位置坐标</p><p>有一个概念叫AnchoredPosition, 这个值的含义是Pivot点相对于<code>Anchor Reference Position</code>的距离, 当锚点的四个角没有重合在一点时, 我们可能会以为Anchor Reference Position</p><p>AnchoredPosition和Local Position的区别是什么?<br>在Transform(非RectTransform)体系中, 子物体的localPosition只能通过调整其和父物体的相对位置来实现变化, 在RectTransform体系下, 子物体的localPosition除了受相对位置的影响, 还与父物体的width、子物体本身的pivot有关</p><h1>RectTransform中的字段</h1><blockquote><p>💡本文我们只讨论RectTransform中有而Transform中没有的字段</p></blockquote><ul><li>rect Rect 注意RectTransform中的rect成员不支持直接修改注意以上字段都是不可以通过RectTransform操作其值的., 因为没有set属性, 外部没有对它的访问权限<ul><li>xMin, 代表的是rect围成矩形区域的左下角的横坐标值, 坐标系原点是这个rect围成的矩形区域的中心点,</li><li>yMin, 代表的是rect围成矩形区域的左下角的纵坐标值, 坐标系原点是这个rect围成的矩形区域的中心点,</li><li>mHeight, 这个rect围成矩形的高</li><li>mWidth, 这个rect围成矩形的宽</li></ul></li><li>anchorMin Vector2 以当前RectTransform的父节点的rect的左下角为坐标原点, 锚点左下角的归一化位置坐标</li><li>anchorMax Vector2 以当前RectTransform的父节点的rect的左下角为坐标原点, 锚点右上角的归一化位置坐标</li><li>sizeDelta Vector2 当锚点四角重合时, sizeDelta.x=rect.width=(offsetMax-offsetMin).x, sizeDelta.y=rect.height=(offsetMax-offsetMin).y 当不重合时 sizeDelta.x=(offsetMax-offsetMin).x, sizeDelta.y=(offsetMax-offsetMin).y</li><li>offsetMin Vector2 指锚点左下角与rect的左下角的偏移值 以当前RectTransform的父节点的rect的左下角为坐标原点</li><li>offsetMax Vector2  指锚点右上角与rect的右上角的偏移值 以当前RectTransform的父节点的rect的左下角为坐标原点</li><li>anchoredPosition Vector2</li><li>anchoredPosition3D Vector3 包含anchoredPosition的xy分量, 增加了z分量 一般用不到<br>localPosition的含义是当前RectTransform的pivot相对于该RectTransform的父节点rect的中心点的位置, 由于可以调整父节点的rect, 所以可以间接影响子物体的localPosition属性, 而我也可以让rect的绝对位置不变 通过改变pivot的位置来影响localPosition的值, 这在Transform(非RectTransform)体系下是不太可能做到的,</li></ul><p>锚点(Anchor)描述的是当前UI节点和其父节点的位置关系, 锚点虽然叫点, 但是会存在锚点的四个角没有重合的情况. 只不过锚点的四角重合时anchor reference position和该点重合了而已 unity会计算出一个anchor reference point, 和pivot做运算得到anchored position<br>中心点(Pivot)描述的是当前UI节点的轴心位置 与父节点无关</p><h1>IDragHandler</h1><p>在此猜测 , IDragHandler的生效逻辑是什么</p><p>每一帧 Unity都会从摄像机出发生成一个射线 由你的pointer投射到场景中的gameObject上, 每一帧你都会拿到这些信息 拿到这些物体, 查看这些物体上挂载的组件有没有实现IDragHandler接口, 如果有, 出发这个IDragHnader的fafa</p><p>在Unity源码中 搜 localIdentifierInFile</p><p>BuildSerialization.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConvertSceneObjectsToInstanceIDBuildRemap</span><span class="params">(<span class="type">const</span> core::string&amp; path, <span class="type">const</span> WriteDataArray&amp; sceneObjects, InstanceIDBuildRemap&amp; output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pathIndex = <span class="built_in">GetPersistentManager</span>().<span class="built_in">GetSerializedFileIndexFromPath</span>(path);</span><br><span class="line"></span><br><span class="line">    output.<span class="built_in">reserve</span>(output.<span class="built_in">size</span>() + sceneObjects.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (WriteDataArray::const_iterator i = sceneObjects.<span class="built_in">begin</span>(); i != sceneObjects.<span class="built_in">end</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Assert</span>(i-&gt;localIdentifierInFile != <span class="number">0</span>);</span><br><span class="line">        output.<span class="built_in">push_unsorted</span>(i-&gt;instanceID, <span class="built_in">SerializedObjectIdentifier</span>(pathIndex, i-&gt;localIdentifierInFile));</span><br><span class="line">    &#125;</span><br><span class="line">    output.<span class="built_in">sort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResourceManager.cpp中的void BuiltinResourceManager::InitializeResources()方法</p><p>下面这段代码, 推测应该是Unity给资产生成FileId的逻辑<br>明天验证一下 对于大部分的FBX中的mesh资源, 他们应该都是叫同样的名字, 又因为他们都是mesh, 所以传入的参数一样, 所以在meta文件中, 你可以看到, 即便是引用了不同的fbx的mesh, 变的只有guid, fileid都是一样了<br>明天验证一下, 两个mesh名不一样的fbx, 应该fileId就会不一样, 而且改了mesh的名字, fileId的名字也就会跟着变</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RectTransform继承自Transform, 并没有包含在UGUI体系里面, 但是RectTransform的字段绝大多数情况下只在UGUI体系中才有意义.  因此我们可以将RectTransform看作是Unity UGUI的一部分, 并且将其作为UGUI系列中首</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSharp合集</title>
    <link href="https://soincredible.github.io/posts/d97e22f1/"/>
    <id>https://soincredible.github.io/posts/d97e22f1/</id>
    <published>2025-07-15T13:43:56.000Z</published>
    <updated>2025-07-15T13:47:59.495Z</updated>
    
    <content type="html"><![CDATA[<p>CSharp问题杂记<br><a href="20505312">CSharp前传</a><br>CSharp中的委托<br>CSharp中的CancellationToken<br>CSharp中的Task<br>Dissecting-the-async-methods-in-CSharp<br>Extending-the-asynce-methods-in-CSharp-译</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CSharp问题杂记&lt;br&gt;
&lt;a href=&quot;20505312&quot;&gt;CSharp前传&lt;/a&gt;&lt;br&gt;
CSharp中的委托&lt;br&gt;
CSharp中的CancellationToken&lt;br&gt;
CSharp中的Task&lt;br&gt;
Dissecting-the-async-met</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>代码热更新合集</title>
    <link href="https://soincredible.github.io/posts/99b1bffa/"/>
    <id>https://soincredible.github.io/posts/99b1bffa/</id>
    <published>2025-06-23T11:07:40.000Z</published>
    <updated>2025-07-28T06:44:13.278Z</updated>
    
    <content type="html"><![CDATA[<h1>XLua、ILRuntime、HybridCLR热更原理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;XLua、ILRuntime、HybridCLR热更原理&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSharp前传</title>
    <link href="https://soincredible.github.io/posts/20505312/"/>
    <id>https://soincredible.github.io/posts/20505312/</id>
    <published>2025-06-22T00:31:38.000Z</published>
    <updated>2025-07-15T13:47:59.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《CLR via C#》这本书帮助读者建立起了C#的知识框架, 是笔者职业生涯中功不可没的好书, 不过本书的作者Jeffrey <a href="http://xn--Richter-oc5k144o.Net">Richter是以.Net</a> Framework框架在Windows平台进行开发的视角上介绍.Net的一些特性的, 而笔者作为一个Unity入门C#的半吊子在最初阅读本书的很长一段时间内是没有真正理解.Net的核心特性的. 在本篇博客中, 笔者尝试基于这本书, 加上笔者对Unity的理解, 站在Unity开发者的视角上, 诠释.Net中的一些关键性概念.</p></blockquote><h1>.NET往事</h1><p>在《CLR via C#》<a href="http://xn--1jq840bfog6d140aln3a9iqxvd2rli4epa472o.Net">这本书里面并没有详细解释.Net</a>、.NetCore、.Net Standard、.Net Framework一系列的概念, 之所以有这么多的概念, 也是有历史原因的, 了解.Net的发展史能帮我们更好地理解这些概念、<br>.Net是.Net C#是C#, .Net是一套支持C#代码运行的框架体系, 除此之外.Net还支持F#、VB等语言</p><p>.Net Framework、 .NetCore、 .Net这三者是对同一个对象在不同发展时期的不同称谓, 这一对象在不同发展时期具有不同的特点.<br>他们是同种概念的不同形态</p><h2 id="Net-Framework时期">.Net Framework时期</h2><p>早期的.Net只能运行在<br>此时的.Net只能够运行在Windows上, 而且C#代码的运行方式是JIT模式</p><h2 id="Mono的出现">Mono的出现</h2><p>由于.Net完全闭源, 有一群人从零手搓了一个, 使用体验跟.Net一模一样的Mono, 而且还支持跨平台, 就跟汉堡王和肯德基一样, 都是汉堡薯条, 吃起来大同小异, 但是做法原料可能完全不同, 也就是说, Mono和.Net可能底层实现不一样, 但是上层要实现的功能是完全一样的: 为C#(笔者这里就只说C#了)提供一套能够正确运行的环境, 知道这个就行了.</p><h2 id="Net-Core是啥">.Net Core是啥</h2><p>.Net Core在原来.NetFramework的基础上, 增加了对于跨平台的支持</p><h2 id="Net-是啥">.Net 是啥</h2><p><a href="http://xn--6kqv66j.Net">至于.Net</a>, 是目前的大一统状态, 里面</p><p>经过一段时间的演变, .Net <a href="http://xn--Core-ts5fw5zn9ou7k.Net">Core就变成了.Net</a></p><table><thead><tr><th>组件名称</th><th>作用</th><th>说明</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>CoreCLR / .NET Runtime</td><td>托管运行时/虚拟机，负责执行IL，中间语言JIT，GC</td><td><a href="https://github.com/dotnet/runtime%EF%BC%88%E5%B7%B2%E5%BC%80%E6%BA%90%EF%BC%89">https://github.com/dotnet/runtime（已开源）</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CoreFX / 基类库（Base Class Library, BCL）</td><td>常用系统API：IO、网络、集合、字符串等</td><td>现代叫runtime中的“libraries”</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="http://ASP.NET">ASP.NET</a> Core</td><td>Web开发框架</td><td>支持Web服务器、API、MVC、Blazor、SignalR、gRPC等平台</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Entity Framework Core</td><td>对象关系映射（ORM）数据库组件</td><td>支持SQLServer、SQLite、MySQL等主流数据库</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>WinForms、WPF（Windows Only）</td><td>桌面GUI开发</td><td>.NET 5+支持基本移植，但仅限Windows</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MSBuild</td><td>构建系统</td><td>dotnet build 就是用的这个</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Roslyn</td><td>C#、VB.NET编译器和代码分析器</td><td><a href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>NuGet</td><td>包管理工具</td><td>在线/本地包管理</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CLI</td><td>命令行工具（dotnet）</td><td>包括dotnet、dotnet build、dotnet run等基础命令</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="Mono是啥">Mono是啥</h2><p>Mono 项目始于 2001 年，由 Ximian 公司的创始人 Miguel de Icaza 领导。Ximian 是一家专注于 Linux 和开源软件的公司。Miguel de Icaza <a href="http://xn--4gqvd70lutrsxi5wc1t2biya.NET">的目标是创建一个.NET</a> 框架的开源实现，以便在 Linux 上运行。</p><p>.NET 框架最初由微软开发，主要用于构建 Windows 应用程序。<a href="http://xn--6kqu55g.NET">由于.NET</a> 框架的闭源性，它无法直接在其他操作系统上运行。Mono 项目的出现打破了这一限制，<a href="http://xn--2rq350b.NET">使得.NET</a> 开发者的代码能够在多种平台上运行。</p><p>随着时间的推移，Mono 项目得到了广泛的社区支持，并且不断发展和完善。它支持多种编程语言，包括 C#、Visual <a href="http://Basic.NET">Basic.NET</a> 和 F#，<a href="http://xn--phqsk73ztrc71ev35bpf9a.NET">并且实现了许多.NET</a> 框架的功能。Mono <a href="http://xn--fiqqezet6cs0gs0ag5r80qxpgh48a7jsgeb81q2u9fc90a.NET">项目在开源社区中的成功也促进了.NET</a> 技术在非 Windows 平台上的普及。</p><p><a href="http://xn--xft85uwsaj08j.xn--Net-6g3ei87f2r7a.Net">还有就是.Net升级是.Net</a> C# language升级是language<br>一般来说, 先是C#的语言有更新, 必须新增了某种语法或者语言特性 那么配套的.Net中就需要支持能够识别并驱动这些语法, 因此一般C#有新特性增加对应的.Net也有新的升级</p><p>说白了 .Net、.NetCore、.NetFramework、Mono每一个都是一套让C#代码能够运行跑起来的平台. 这就好比各家虚拟机平台, 而C#就像是你在微软官网上下载的Windows操作系统的镜像文件, 你可以将这个镜像文件挂载在VMWare平台上, 也可以挂载在Parallel Desktop平台上, 即便平台的底层实现不同, 但是因为它们都遵循同样的规范, 因此同样的一操作系统镜像文件可以跑在不同的虚拟机平台上, 这些平台遵循的规范, 类比到.Net中也就是<code>.Net Standard</code></p><h2 id="Net-Standard">.Net Standard</h2><p>.Net Standard 是针对多个 .Net实现推出的一套正式的.Net API规范. 推出.NetStandard的背后动机是要提高.Net生态系统中的一致性.<br>由上面的陈述可知, .Net有很多的实现, 为了能够让不同实现的.Net能够协同工作, .Net Standard出现了. 比如在Unity开发中, 你需要使用一个托管的dll, 这个dll使用.Net环境开发, 而Unity是Mono环境, 为了让dll中的代码能够和Unity中的代码正确协同, <a href="http://xn--Unitydll-b50n2ky0c413fdixom8b6r7cmhhzivd30a.Net">只需要让Unity和dll遵循同样的.Net</a> Standard版本就可以了. 在Unity的BuildSettings中的APICompatibilityLevel就是这个作用, 不同的Unity版本可以对标的.Net版本也不太一样. 比如在<code>2020.3.48</code>版本中, <code>API Compatibility Level</code>的选项是<code>.Net 4.X</code>和<code>.Net Standard 2.0</code>, 而在<code>2022.3.15</code>版本中, <code>API Compatibility Level</code>的选项则变成了<code>.Net Standard 2.1</code>和<code>.Net Framework</code>. 所以这么一看你所使用的插件必须要有<code>API Compatibility Level</code>相对应的版本才能够在Unity中使用.<br><a href="http://xn--zbs584j.Net">说回.Net</a>, .Net5采用的不同的方法来建立一致性, <a href="http://xn--ghqe42iv2dxrl2vvsdhtrtvcvrs3cu50i0xyjnofs9cchveoes67a.Net">这种新方法在很多情况下都不需要使用到.Net</a> Standard.</p><p>你的Unity工程，允许代码能用（兼容）的 .NET（或Mono）API集合的标准程度。</p><p>Unity的脚本运行环境（Scripting Backend）是基于Mono（或IL2CPP）来实现C#环境的；<br>但Mono和微软官方.NET实现的API/标准并不是完全一致的，有新有旧、有全有残；<br>API Compatibility Level，就是让你指定用哪一套标准的API接口子集：<br>比如：.NET 2.0 Subset<br>又比如：.NET 4.x / .NET Standard 2.0<br>或者更高（随着Unity版本演进而变化）<br>这些选项，<a href="http://xn--Unity-fg1hjcs88bgjegyy9a11h01wpp1glkcu71cohh804h.NET">实际上背后对应着一组Unity定制的.NET</a> Base Class Library (BCL)，决定你在C#脚本里能不能引用、编译、反射、调用某些标准库功能。</p><p>新项目：优先选“.NET 4.x”或“.NET Standard 2.0”。<br>项目中有现代C#语法（如async/await、LINQ等）：必须选新标准。<br>做插件/SDK跨Unity兼容：优先考虑“.NET Standard 2.0”。<br>有老DLL、Asset Store资产只支持2.0，且不想升级：临时用“.NET 2.0”。<br>手机版本极度精简、追求最小包体：用Subset，但很少有这种极端需求。</p><h1>一个C#工程使用的.Net版本怎么看?</h1><p>注意.Net版本和C#LanguageVersion是两个东西,<br>对于使用Rider创建的C#项目,</p><p>Unity的.NetVersion能不能改?</p><h1>一个C#工程使用的.Net版本怎么修改?</h1><h1>C#项目的组织结构</h1><h1>Unity项目的代码组织结构</h1><h2 id="sln-csproj-dll-asmdef-pdb的区别和联系">.sln .csproj .dll .asmdef .pdb的区别和联系</h2><h2 id="dll">.dll</h2><p>如果你的C#项目选择的是ClassLibrary, 那么构建这个C#项目的时候, 构建结果就是.dll,<br><a href="https://github.com/shimat/opencvsharp/releases">这是C#版本的OpenCV库</a>, 下载他的release你会发现,里面还带一个pdb文件.<br>.sln 是<br>.csproj 一个sln下会有多个csproj<br>.asmdef 这是Unity中的一个概念, 每创建一个asmdef, Unity都会自动生成这个asmdef对应的csproj<br>.dll dll一般有两种: 使用C#编译生成的dll, 这类dll属于托管类dll, 导入Unity能够直接被Unity编译器识别; 还有一类是使用c/c++等非托管类语言编译生成的dll, 这类dll需要C#具有能够调用原生(native)代码的能力, 需要使用<code>[DLLImport]</code>属性来导入方法</p><p>对于简单的项目 完全没必要创建sln 但是像Rider、Visual Studio这些IDE是没有提供只创建csproj的选项的, 这就有点大材小用了 我们可以通过使用命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dotnet new console</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建后是一个dll</span></span><br><span class="line">dotnet new classlib</span><br></pre></td></tr></table></figure><p>这种方式只创建csproj, 然后使用Rider或者VS打开这个csproj, 就可以绕过生成sln文件<br>.sln（Solution）文件是 Visual Studio/VS Code/Coderush Rider 等IDE用来管理一组相关项目（.csproj）的容器。比如你要做大型架构、包括多个类库、应用，以及单元测试项目时，.sln文件可以统一管理它们的依赖与结构。<br>但是，小项目、单个项目时，完全可以不建 .sln，只用一个 csproj 文件照样编译、运行、开发（如命令行下dotnet build XX.csproj，VS Code 也能直接打开）。<br>实例1：你在任意文件夹里新建dotnet new console，它会创建Program.cs和XX.csproj，没有.sln，也能正常dotnet run/build。<br>只有需要管理多个项目（比如引用类库或测试工程等），用.sln会更方便。</p><p>pdb 文件是什么？</p><p>PDB（Program Database）是Windows/Visual Studio环境下的“程序数据库”文件。<br>内容：主要存储了可执行文件（exe/dll等）的调试信息，如：<br>源文件名/路径<br>行号<br>局部变量、函数参数名<br>类型信息<br>符号表、断点等信息<br>目的是：进行调试时，IDE/调试器能还原源代码对应关系、栈、变量名等，是“调试辅助文件”。<br>3. dll 和 pdb 的关系</p><p>当你用 Visual Studio 编译一个 dll 时（Debug 模式），通常会生成同名的 pdb 文件。<br>这个 dll 文件是真正的动态库，pdb 文件不给程序加载，只在调试/分析时让开发者用。<br>没有 pdb，发布的 dll 依然可以运行，只是调试难度大。</p><h1>C#代码是怎么跑起来的?</h1><p>在《CLR via C#》中, 作者只提及了JIT, 因为AOT方式是在2022年在.Net7发布的, 本书的成书时间应该是2014年, 没有提及AOT也是很正常的</p><h2 id="JIT模式">JIT模式</h2><p>在Unity中, 这对应的就是Mono的构建方式</p><p>JIT方式打包, 在打包阶段, 我们编写的C#代码会被编译成IL, 打入一个.dll的文件, 这就是Mono的打包方式, 使用这种方式打的包, 包体小, 但是由于其代码不是原生的, 所以运行时需要依赖CLR将IL代码编译成原生代码执行, 比起AOT方式 在启动时间上会久一点, 因为需要编译, 但是只要编译了一次之后, 执行效率和AOT是没什么区别的</p><p>笔者认为在一开始.Net可能就只支持JIT的方式执行C#代码, 而AOT和解释器方式则是跨平台的概念引入到.Net中后, 才出现的概念.</p><p>随着.Net支持跨平台. 想要在MacOS、iOS上运行.Net程序, 使用JIT的方式就不行了, 因为苹果是不允许程序运行时动态加载代码的, 所有代码必须被编译成机器码原生地执行. 这就是AOT模式</p><h2 id="AOT模式">AOT模式</h2><p>微软是在.Net7版本中实现了AOT功能.</p><p>在Unity中, 这对应的就是IL2CPP的构建方式</p><p>我们就拿Unity开发举例子, 如果使用AOT的方式打包, 那么在打包阶段, 我们编写的C#代码就会全部被编译成机器码, 也就是.so文件, 这种代码就是原生的代码, 丢到机器上就就能立刻运行, 不需要编译, 但是机器码都是01, 存储效率低, 由我们的C#脚本转成机器码会造成代码膨胀, 听起来是不是很像IL2CPP?</p><p>那在AOT推出之前, Unity是怎么实现在iOS平台上发布的呢? Mono是专门提供了</p><h1>代码热更</h1><h2 id="Interpreter模式">Interpreter模式</h2><p>解释器, 笔者第一次看到这个概念出现在C#中时, 是非常疑惑的, 因为笔者理解的解释器, 是像Python那种解释型语言才会使用到的东西, 而C#作为一个编译型语言, 其实C#并不是传统意义上的编译型语言, 因为C#是先编译成IL中间语言, 然后在运行时通过JITCompiler将中间语言编译成机器码执行的方式.</p><p>也就是, C#不解释型语言那样直接解释源代码执行, 也不像C++那样一次性把源代码编译成机器码执行.</p><p>解释器模式可以理解为是在Unity开发中代码热更新场景下, 业内开发者为了能够执行热更代码(dll)而开发的一种迷你版的CLR(虚拟机).<br>我再理解一下解释器的角色, 解释器就是在AOT打包方式下, 主包的.Net的虚拟机被剔除丧失了解析编译IL(dll)的能力, 需要一个迷你版的虚拟机(也就是解释器)来执行IL代码</p><h1>JIT和解释器的区别是啥呢? 不都是运行时编译代码嘛?</h1><p>JIT方式是有完整的Mono或者CLR虚拟机的机制, 而解释器则是一种针对Unity热更场景下的迷你版虚拟机机制.</p><h2 id="Lua、XLua">Lua、XLua</h2><h2 id="ILRuntime">ILRuntime</h2><h2 id="HybridCLR">HybridCLR</h2><h1>C#的执行机制</h1><p>C#代码会被编译成IL语言, 在运行的时候, 通过一个Interpreter(解释器)逐行解释IL指令运行<br>在IOS上, 是不允许JIT的方式运行代码的, 只能使用AOT的方式运行<br>在Android等其他设备上AOT和JIT都是可以的</p><h1>如今行业内主流的热更方案究竟是怎么形成的?</h1><ul><li>由于IOS对于JIT的限制, 导致主包必须使用AOT的方式打包, <a href="http://xn--AOT-0y9d42pwx1aclan9eb47e78s.Net">而AOT打包会直接把.Net</a> Mono虚拟机剔除掉, 将C#直接转成C++原生代码. 这就会导致主包不具备识别dll能力</li><li>接着, 由于各个操作系统平台对于原生代码的动态加载是有限制的（比如 dlopen 加新 so/dll）, 所以想要在运行时动态的加载一段逻辑进来, 只能使用非原生代码, 于是热更通常选择DLL（IL）</li><li>要让底包能认识和运行“热更dll”里的 C# 代码，就得有.NET虚拟机。但AOT打包让虚拟机相关能力被移除/阉割，不认dll。 但是虚拟机在AOT打包的时候已经几乎被完全剔除掉了, 因此我们必须让它恢复识别dll的功能,</li><li>要想恢复识别dll的能力，就得集成新的虚拟机或解释能力（比如ILRuntime/HybridCLR）。HybridCLR的意义就是让AOT包恢复充分甚至很大程度原生的DLL识别/运行能力。这就是HybridCLR所做的事情在AOT打包模式剔除掉Mono虚拟机识别dll代码能力的情况下, 重写AOT的打包方式, 让其保留能够识别dll代码的能力.</li></ul><h1>代码热更新</h1><p>为什么代码热更新都选择使用JIT(将热更代码编译成dll)的方式, 而不选择AOT原生方式呢?</p><h1>热更的代码和热更的资源 哪个应该先加载?</h1><p>热更代码的调用方式<br>有一种很取巧的方式加载热更代码, 那就是把热更代码挂载到某一个预制体上, 通过Unity的Awake方法调用热更代码的入口<br>AOT程序集 就是底包程序集 AOT是一种代码编译方式 它会</p><p>什么是streaming path? 什么是persistent path?</p><h1>一些Unity中无法内置的dll的处理</h1><p><a href="https://blog.csdn.net/lanchunhui/article/details/53239441">https://blog.csdn.net/lanchunhui/article/details/53239441</a></p><p><a href="https://zh.wikipedia.org/zh-hans/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83">https://zh.wikipedia.org/zh-hans/正态分布</a></p><p><a href="https://blog.csdn.net/qq_17347313/article/details/106995687">https://blog.csdn.net/qq_17347313/article/details/106995687</a><br>C#中正态分布的第三方库</p><h1>正态分布</h1><h2 id="标准正态分布">标准正态分布</h2><h1>正偏态分布</h1><h1>累积分布函数</h1><h1>参考</h1><ul><li><a href="https://www.cnblogs.com/SunSpring/p/15047424.html">.net 温故知新：【2】 .Net Framework 、.Net 、 .NET Standard的概念与区别</a></li><li><a href="https://blog.csdn.net/codywangziham01/article/details/123689658">AOT 和 JIT、 IL2CPP和Mono、 CLR、 ILRuntime热更新原理</a></li><li><a href="https://www.cnblogs.com/fly-100/p/4594380.html">Unity跨平台原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/88692056">Unity从发布到流行经历了什么重大变化（2）</a></li><li><a href="https://blog.csdn.net/gz_huangzl/article/details/52486255">Unity将来时：IL2CPP是什么？有了Mono为什么还需要IL2CPP?</a></li><li><a href="https://blog.csdn.net/Funniyuan/article/details/136002603">.NET 发展历程与未来</a></li><li><a href="https://my.oschina.net/emacs_9244658/blog/18230886">Mono 软件发展历程详解</a></li><li><a href="https://www.cnblogs.com/willick/p/15038133.html">.NET 的发展简史</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;《CLR via C#》这本书帮助读者建立起了C#的知识框架, 是笔者职业生涯中功不可没的好书, 不过本书的作者Jeffrey &lt;a href=&quot;http://xn--Richter-oc5k144o.Net&quot;&gt;Richter是以.Net&lt;/a&gt; </summary>
      
    
    
    
    
  </entry>
  
</feed>
