<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EddieLee</title>
  
  <subtitle>to infinity and beyond✨🛸.</subtitle>
  <link href="https://soincredible.github.io/atom.xml" rel="self"/>
  
  <link href="https://soincredible.github.io/"/>
  <updated>2025-05-08T03:00:00.545Z</updated>
  <id>https://soincredible.github.io/</id>
  
  <author>
    <name>Eddie Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dissecting the async methods in CSharp</title>
    <link href="https://soincredible.github.io/posts/72dba58e/"/>
    <id>https://soincredible.github.io/posts/72dba58e/</id>
    <published>2025-05-07T12:44:20.000Z</published>
    <updated>2025-05-08T03:00:00.545Z</updated>
    
    <content type="html"><![CDATA[<h1>关于异步的历史</h1><p>C#开发者在第一次接触异步的概念, 应该是通过Task类型. Task是在<code>.Net 4.0</code>的时候被引入的. 一个task就是一个work单元, 且该task承诺, 在这个task未来完成的时候, 会将结果返回给task的调用者. 这个Task可能是由IO操作支持或者计算密集型操作(这正好对应了笔者在协程部分所说的CPU密集型操作和IO型操作, Unity协程只能用来做IO型的异步操作). 重要的是该操作的结果是自包含的，且具有一等公民身份。你可以自由传递这个&quot;未来&quot;：将其存储在变量中、从方法返回它、或传递给其他方法。你可以将两个&quot;未来&quot;合并形成新的任务，可以同步等待结果，也可以通过添加&quot;延续&quot;来&quot;等待&quot;结果。仅凭任务实例本身，你就能决定在操作成功、失败或被取消时采取何种处理。</p><p>任务并行库 (TPL) 改变了我们对并发编程的认知，而 C# 5 通过引入 async/await 进一步推动了这一发展。async/await 让任务的组合变得更加容易，并允许开发者使用熟悉的代码结构，如 try/catch、using 等。但是async/await也有其开销. 要理解具体开销是什么, 我们需要深入底层机制中.</p><h1>异步方法内部</h1><p>普通方法只有一个入口点和一个退出点（虽然可能有多个 return 语句，但在运行时，每次调用仅有一个实际退出点）。但 异步方法（*） 和 迭代器方法（包含 yield return 的方法）则不同。对于异步方法而言，调用方几乎可以立即获取结果（即 Task 或 Task<T>），然后通过返回的任务（Task）来 “await” 方法的实际执行结果。</p><p>（*）我们定义的 “异步方法” 是指用 async 上下文关键字标记的方法。这并不一定意味着该方法会异步执行，甚至完全不意味着它是异步的。它仅表示 编译器会对该方法进行某些特殊转换。</p><p>看一下下面这个异步方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class StockPrices</span><br><span class="line">&#123;</span><br><span class="line">    private Dictionary&lt;string, decimal&gt; _stockPrices;</span><br><span class="line">    // 被标记了async的方法, Compiler会在背后将其内部的逻辑转调用一个状态机</span><br><span class="line">    // 而这个异步方法中原来的逻辑会全部转移到Compiler自动生成的状态机的MoveNext方法中 </span><br><span class="line">    public async Task&lt;decimal&gt; GetStockPriceForAsync(string companyId)</span><br><span class="line">    &#123;</span><br><span class="line">        await InitializeMapIfNeededAsync();</span><br><span class="line">        _stockPrices.TryGetValue(companyId, out var result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 被标记了async的方法, Compiler会在背后将其转换成状态机</span><br><span class="line">    // 而这个异步方法中原来的逻辑会全部转移到Compiler自动生成的状态机的MoveNext方法中 </span><br><span class="line">    private async Task InitializeMapIfNeededAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_stockPrices != null)</span><br><span class="line">            return;</span><br><span class="line"> </span><br><span class="line">        await Task.Delay(42);</span><br><span class="line">        // Getting the stock prices from the external source and cache in memory.</span><br><span class="line">        _stockPrices = new Dictionary&lt;string, decimal&gt; &#123; &#123; &quot;MSFT&quot;, 42 &#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的理解编译器做了或者能做什么, 让我们尝试着手写一下转换过程</p><h1>手动解构异步方法</h1><p>TPL（任务并行库）提供了两大核心构建模块，帮助我们构造和组合任务：</p><ul><li>任务延续（Task Continuation）-&gt; 通过 <code>Task.ContinueWith</code>实现</li><li>手动构建任务 -&gt; 通过 <code>TaskCompletionSource&lt;T&gt;</code> 类实现<br>（注：前者用于链式编排任务，后者用于手动控制任务生命周期。）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class GetStockPriceForAsync_StateMachine</span><br><span class="line">&#123;</span><br><span class="line">    enum State &#123; Start, Step1, &#125;</span><br><span class="line">    private readonly StockPrices @this;</span><br><span class="line">    private readonly string _companyId;</span><br><span class="line">    private readonly TaskCompletionSource&lt;decimal&gt; _tcs;</span><br><span class="line">    private Task _initializeMapIfNeededTask;</span><br><span class="line">    private State _state = State.Start;</span><br><span class="line"> </span><br><span class="line">    public GetStockPriceForAsync_StateMachine(StockPrices @this, string companyId)</span><br><span class="line">    &#123;</span><br><span class="line">        this.@this = @this;</span><br><span class="line">        _companyId = companyId;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            if (_state == State.Start)</span><br><span class="line">            &#123;</span><br><span class="line">                // The code from the start of the method to the first &#x27;await&#x27;.</span><br><span class="line"> </span><br><span class="line">                if (string.IsNullOrEmpty(_companyId))</span><br><span class="line">                    throw new ArgumentNullException();</span><br><span class="line"> </span><br><span class="line">                _initializeMapIfNeededTask = @this.InitializeMapIfNeeded();</span><br><span class="line"> </span><br><span class="line">                // Update state and schedule continuation</span><br><span class="line">                _state = State.Step1;</span><br><span class="line">                _initializeMapIfNeededTask.ContinueWith(_ =&gt; Start());</span><br><span class="line">            &#125;</span><br><span class="line">            else if (_state == State.Step1)</span><br><span class="line">            &#123;</span><br><span class="line">                // Need to check the error and the cancel case first</span><br><span class="line">                if (_initializeMapIfNeededTask.Status == TaskStatus.Canceled)</span><br><span class="line">                    _tcs.SetCanceled();</span><br><span class="line">                else if (_initializeMapIfNeededTask.Status == TaskStatus.Faulted)</span><br><span class="line">                    _tcs.SetException(_initializeMapIfNeededTask.Exception.InnerException);</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    // The code between first await and the rest of the method</span><br><span class="line"> </span><br><span class="line">                    @this._store.TryGetValue(_companyId, out var result);</span><br><span class="line">                    _tcs.SetResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            _tcs.SetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Task&lt;decimal&gt; Task =&gt; _tcs.Task;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public Task&lt;decimal&gt; GetStockPriceForAsync(string companyId)</span><br><span class="line">&#123;</span><br><span class="line">    var stateMachine = new GetStockPriceForAsync_StateMachine(this, companyId);</span><br><span class="line">    stateMachine.Start();</span><br><span class="line">    return stateMachine.Task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然冗长，但逻辑相对直接。原先在 GetStockPriceForAsync 中的所有逻辑都被转移到了 GetStockPriceForAsync_StateMachine.Start 方法中，该方法采用了&quot;延续传递风格&quot;(continuation passing style)。异步转换的核心算法就是将原始方法在 await 边界处分割成若干代码块：</p><ul><li>第一个代码块：从方法开始到第一个 await 之间的代码</li><li>第二个代码块：从第一个 await 到第二个 await 之间的代码</li><li>第三个代码块：从第二个 await 到第三个 await 或方法结束的代码 以此类推</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Step 1 of the generated state machine:</span><br><span class="line"> </span><br><span class="line">if (string.IsNullOrEmpty(_companyId)) throw new ArgumentNullException();</span><br><span class="line">_initializeMapIfNeededTask = @this.InitializeMapIfNeeded();</span><br></pre></td></tr></table></figure><p>每个被 await 的任务现在都变成了状态机的一个字段，而 Start 方法会将自己注册为这些任务的延续（continuation）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_state = State.Step1;</span><br><span class="line">_initializeMapIfNeededTask.ContinueWith(_ =&gt; Start());</span><br></pre></td></tr></table></figure><p>随后，当任务完成时，Start方法会被回调，并通过检查_state字段来确定当前执行阶段。接着，状态机会判断任务是成功完成、被取消还是出现异常。如果是成功完成的情况，状态机就会继续执行下一个代码块。当所有操作都完成后，状态机会设置TaskCompletionSource<T>实例的结果值，此时从GetStockPricesForAsync返回的任务状态就会变更为已完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// The code between first await and the rest of the method</span><br><span class="line"> </span><br><span class="line">@this._stockPrices.TryGetValue(_companyId, out var result);</span><br><span class="line">_tcs.SetResult(result); // The caller gets the result back</span><br></pre></td></tr></table></figure><p>这种&quot;实现方式&quot;存在几个严重缺陷：</p><ul><li>大量堆内存分配：<ul><li>状态机实例需要1次内存分配</li><li>TaskCompletionSource<T>需要1次分配</li><li>TaskCompletionSource<T>内部任务需要1次分配, 按照GPT的说法<code>TaskCompletionSource&lt;decimal&gt;</code>内部会自动创建一个<code>Task&lt;decimal&gt;</code> 实例（通过其 .Task 属性访问）</li><li>延续委托(delegate)需要1次分配, 指的应该是<code> _initializeMapIfNeededTask.ContinueWith(_ =&gt; Start());</code></li></ul></li><li>缺少&quot;热路径优化&quot;：<br>当被等待的任务已经完成时，完全没有必要创建延续委托</li><li>可扩展性不足：<br>实现与Task类紧密耦合，导致无法用于其他场景，例如：<ul><li>等待非Task类型</li><li>返回非Task/Task<T>类型</li></ul></li></ul><p>下面我们就来看一下上述提到的缺陷在真正的异步机制中是如何被解决的.</p><h1>异步机制</h1><p>编译器执行异步方法转换的整个过程, 其实已经和上面我们手动实现的方式十分接近了. 为了得到预期的行为, 编译器依赖于以下的类型:</p><ul><li>对于一个异步方法的生成的状态机, 其行为会像栈帧一样, 并且该状态机包含原始异步方法中的全部逻辑</li><li><code>AsyncTaskMethodBuilder&lt;T&gt;</code>持有完成的task（与 TaskCompletionSource<T> 类型非常相似）, 并且管理状态机的转换.</li><li><code>TaskAwaiter&lt;T&gt;</code>负责包装task, 并在需要时调度其延续</li><li><code>MoveNetRunner</code>负责在正确的执行上下文中调用<code>IAsyncStateMachine.MoveNext</code>方法</li></ul><p>生成的状态机在Debug模式下是一个类, 在Release模式下则是一个struct. 其他的类型(除了<code>MoveNextRunner</code>类)在BCL中均被定义为了struct.</p><p>编译器生成的状态机类型名称通常类似于<code>&lt;YourMethodNameAsync&gt;d_1</code>, 为了避免名称冲突, 生成的名字中包含了一些无效的标识符字符, 这些字符无法被用户直接定义或引用. 但是为了简化说明, 在后续的所有示例中, 我们还是将使用有效的标识符来替换掉<code>&lt;</code>、<code>&gt;</code>、<code>_</code>这些字符, 并且使用更容易理解的名字.</p><h1>原始方法</h1><p>原始的异步方法会创建一个状态机实例, 用捕获的状态（如果方法非静态，则包括 this 指针）初始化该实例, 通过传递状态机实例的引用并调用<code>AsyncTaskMethodBuilder&lt;T&gt;.Start</code>来启动执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[AsyncStateMachine(typeof(_GetStockPriceForAsync_d__1))]</span><br><span class="line">public Task&lt;decimal&gt; GetStockPriceFor(string companyId)</span><br><span class="line">&#123;</span><br><span class="line">    _GetStockPriceForAsync_d__1 _GetStockPriceFor_d__;</span><br><span class="line">    _GetStockPriceFor_d__.__this = this;</span><br><span class="line">    _GetStockPriceFor_d__.companyId = companyId;</span><br><span class="line">    _GetStockPriceFor_d__.__builder = AsyncTaskMethodBuilder&lt;decimal&gt;.Create();</span><br><span class="line">    _GetStockPriceFor_d__.__state = -1;</span><br><span class="line">    var __t__builder = _GetStockPriceFor_d__.__builder;</span><br><span class="line">    __t__builder.Start&lt;_GetStockPriceForAsync_d__1&gt;(ref _GetStockPriceFor_d__);</span><br><span class="line">    return _GetStockPriceFor_d__.__builder.Task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递引用是一个重要的优化, 因为一个状态机往往是相对大的结构(大于100bytes), 因此传递引用会避免冗余拷贝.<br>状态机代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">struct _GetStockPriceForAsync_d__1 : IAsyncStateMachine</span><br><span class="line">&#123;</span><br><span class="line">    public StockPrices __this;</span><br><span class="line">    public string companyId;</span><br><span class="line">    public AsyncTaskMethodBuilder&lt;decimal&gt; __builder;</span><br><span class="line">    public int __state;</span><br><span class="line">    private TaskAwaiter __task1Awaiter;</span><br><span class="line"> </span><br><span class="line">    public void MoveNext()</span><br><span class="line">    &#123;</span><br><span class="line">        decimal result;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            TaskAwaiter awaiter;</span><br><span class="line">            if (__state != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // State 1 of the generated state machine:</span><br><span class="line">                if (string.IsNullOrEmpty(companyId))</span><br><span class="line">                    throw new ArgumentNullException();</span><br><span class="line"> </span><br><span class="line">                awaiter = __this.InitializeLocalStoreIfNeededAsync().GetAwaiter();</span><br><span class="line"> </span><br><span class="line">                // Hot path optimization: if the task is completed,</span><br><span class="line">                // the state machine automatically moves to the next step</span><br><span class="line">                if (!awaiter.IsCompleted)</span><br><span class="line">                &#123;</span><br><span class="line">                    __state = 0;</span><br><span class="line">                    __task1Awaiter = awaiter;</span><br><span class="line"> </span><br><span class="line">                    // The following call will eventually cause boxing of the state machine.</span><br><span class="line">                    __builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                awaiter = __task1Awaiter;</span><br><span class="line">                __task1Awaiter = default(TaskAwaiter);</span><br><span class="line">                __state = -1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // GetResult returns void, but it&#x27;ll throw if the awaited task failed.</span><br><span class="line">            // This exception is catched later and changes the resulting task.</span><br><span class="line">            awaiter.GetResult();</span><br><span class="line">            __this._stocks.TryGetValue(companyId, out result);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception exception)</span><br><span class="line">        &#123;</span><br><span class="line">            // Final state: failure</span><br><span class="line">            __state = -2;</span><br><span class="line">            __builder.SetException(exception);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // Final state: success</span><br><span class="line">        __state = -2;</span><br><span class="line">        __builder.SetResult(result);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">    &#123;</span><br><span class="line">        __builder.SetStateMachine(stateMachine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的状态机代码看起来比较复杂, 但是本质上, 它和我们手写的那一版的代码是十分相似的.<br>即使两个版本十分相似, 但是还是有一些重要的不同的.</p><ol><li>“Hot Path” 优化</li></ol><p>不像我们原生的方式, 生成的状态机知道一个被awaited的task可能已经完成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awaiter = __this.InitializeLocalStoreIfNeededAsync().GetAwaiter();</span><br><span class="line"> </span><br><span class="line">// Hot path optimization: if the task is completed,</span><br><span class="line">// the state machine automatically moves to the next step</span><br><span class="line">if (!awaiter.IsCompleted)</span><br><span class="line">&#123;</span><br><span class="line">    // Irrelevant stuff</span><br><span class="line"> </span><br><span class="line">    // The following call will eventually cause boxing of the state machine.</span><br><span class="line">    __builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个被await的task已经完成了(无论成功与否), 状态机会向前直行下一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// GetResult returns void, but it&#x27;ll throw if the awaited task failed.</span><br><span class="line">// This exception is catched later and changes the resulting task.</span><br><span class="line">awaiter.GetResult();</span><br><span class="line">__this._stocks.TryGetValue(companyId, out result);</span><br></pre></td></tr></table></figure><p>这就意味着, 如果所有awaited的task都已经完成了, 整个状态机将只会停留在栈上. 一个异步方法甚至在今天如果所有awaited的task都已经完成或者同步完成了, 那么这个异步方法是可以只会造成很小的内存开销的. 仅剩的开销只是这个task本身.</p><ol start="2"><li>错误处理</li></ol><p>当前逻辑并未专门处理任务处于故障状态或已取消状态的情况。状态机通过调用awaiter.GetResult()方法，当任务被取消时将抛出TaskCancelledException，若任务失败则抛出其他异常。这种设计十分优雅，因为GetResult()在错误处理机制上与task.Wait()或task.Result有本质区别。</p><p>无论是task.Wait()还是task.Result，即便任务因单一异常导致失败，它们都会抛出AggregateException。这背后的逻辑很简单：任务不仅可能代表通常只有单一故障的IO操作，也可能是并行计算的结果。后者可能产生多个错误，而AggregateException正是为聚合所有错误而设计。</p><p>但<code>async/await</code>模式专为异步操作设计，这类操作通常最多只会产生一个错误。因此语言设计者认为，若<code>awaiter.GetResult()</code>能对AggregateException进行解包并仅抛出首个异常，将更符合使用场景。这一设计并非完美，我们将在后续文章中看到这种抽象方案可能存在的漏洞。</p><p>异步状态机只是整个拼图的一部分。要完整理解其运作机制，我们还需了解状态机实例如何与<code>TaskAwaiter&lt;T&gt;</code>和<code>AsyncTaskMethodBuilder&lt;T&gt;</code>进行交互。</p><h1>这些模块是如何被联系到一起的呢?</h1><p><a href="https://devblogs.microsoft.com/wp-content/uploads/sites/31/2019/06/Async_sequence_state_machine_thumb.png"></a></p><p>图表看似过于复杂，但每个组件都经过精心设计且扮演着重要角色。最有趣的协作发生在等待的任务尚未完成时（图中用棕色矩形标记）：</p><p>状态机注册任务延续</p><p>状态机调用 <code>__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this)</code>，将自身注册为任务的延续。<br><code>AsyncTaskMethodBuilder</code> 确保任务完成后调用 <code>IAsyncStateMachine.MoveNext</code> 方法：<br>捕获当前 执行上下文（ExecutionContext），创建一个 MoveNextRunner 实例，将其与当前状态机实例关联。<br>从 MoveNextRunner.Run 创建一个 Action 委托，用于在捕获的执行上下文中推进状态机。<br>调用 TaskAwaiter.UnsafeOnCompleted(action)，将上述 Action 委托调度为等待任务的延续。<br>任务完成后的恢复</p><p>当等待的任务完成时，注册的回调（Action 委托）被触发，状态机继续执行异步方法的下一段代码块。</p><h1>执行上下文</h1><p>问题：什么是执行上下文？为何需要这种复杂的设计？<br>在同步代码中，每个线程通过 <code>线程本地存储（Thread-Local Storage）</code> 维护环境信息，例如：安全凭据（如 SecurityContext）区域性设置（如 CultureInfo）或者其他上下文数据（如 AsyncLocal<T> 的值）<br>当三个方法在同一个线程中依次调用时，这些信息会自动在方法间流动。但是对于异步方法来说就不再是这样了. 异步方法的每个代码段（如 await 前后的代码）可能在不同线程上执行，<code>线程本地存储(Thread-Local Storage</code>失效。<br>因此执行上下文派上用场, 它为 一个逻辑控制流 维护上下文信息，即使该控制流跨越多线程。<br>例如，Task.Run 或 ThreadPool.QueueUserWorkItem 会 自动捕获调用线程的执行上下文，并将其与任务绑定。<br>当任务执行时，调度器（如 TaskScheduler）通过 ExecutionContext.Run 在捕获的上下文中运行委托，确保环境信息（如安全凭据）无缝延续。</p><p>通过下面这个例子理解一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static Task ExecutionContextInAction()</span><br><span class="line">&#123;</span><br><span class="line">    var li = new AsyncLocal&lt;int&gt;();</span><br><span class="line">    li.Value = 42;</span><br><span class="line"> </span><br><span class="line">    return Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // Task.Run restores the execution context</span><br><span class="line">        Console.WriteLine(&quot;In Task.Run: &quot; + li.Value);</span><br><span class="line">    &#125;).ContinueWith(_ =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // The continuation restores the execution context as well</span><br><span class="line">        Console.WriteLine(&quot;In Task.ContinueWith: &quot; + li.Value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中, 执行上下文通过<code>Task.Run</code>流向了<code>Task.ContinueWith</code>. 因此上面这段代码的执行结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In Task.Run: 42</span><br><span class="line">In Task.ContinueWith: 42</span><br></pre></td></tr></table></figure><p>但是不是所有在BCL中的方法都会自动捕获并恢复执行上下文. 两个例外是: <code>TaskAwaiter&lt;T&gt;.UnsafeOnCompledte</code>和<code>AsyncMethodBuilder&lt;T&gt;.AwaitUnsafeOnComplete</code>. 这看起来十分奇怪, 语言设计者决定添加不安全的方法手动使用<code>AsyncMethodBuilder&lt;T&gt;</code>和<code>MoveNetRunner</code>而不是依赖于内建的类似<code>AwaitTaskContinuation</code>这样的机制驱动执行上下文, 猜测这是出于性能问题考虑或者是对现有实现的另一个妥协.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static async Task ExecutionContextInAsyncMethod()</span><br><span class="line">&#123;</span><br><span class="line">    var li = new AsyncLocal&lt;int&gt;();</span><br><span class="line">    li.Value = 42;</span><br><span class="line">    await Task.Delay(42);</span><br><span class="line"></span><br><span class="line">    // The context is implicitely captured. li.Value is 42</span><br><span class="line">    Console.WriteLine(&quot;After first await: &quot; + li.Value);</span><br><span class="line"></span><br><span class="line">    var tsk2 = Task.Yield();</span><br><span class="line">    tsk2.GetAwaiter().UnsafeOnCompleted(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // The context is not captured: li.Value is 0</span><br><span class="line">        Console.WriteLine(&quot;Inside UnsafeOnCompleted: &quot; + li.Value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    await tsk2;</span><br><span class="line"></span><br><span class="line">    // The context is captured: li.Value is 42</span><br><span class="line">    Console.WriteLine(&quot;After second await: &quot; + li.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">After first await: 42</span><br><span class="line">Inside UnsafeOnCompleted: 0</span><br><span class="line">After second await: 42</span><br></pre></td></tr></table></figure><h1>结论</h1><ul><li><p>异步方法（async）的底层行为与同步方法截然不同，其核心机制依赖于编译器生成的 状态机（State Machine）：</p></li><li><p>编译器会为每个异步方法生成一个独立的状态机，将原方法的全部逻辑转移至状态机中。 状态机负责跟踪执行进度（通过状态值）、挂起（await 时）与恢复（任务完成时）的逻辑流转。</p></li><li><p>对同步完成的深度优化. 若所有等待的任务（await 的任务）已同步完成（如缓存命中、内存计算等无阻塞操作），异步方法的性能开销极低，几乎与同步方法无异。<br>此优化避免了不必要的上下文切换或调度，是异步编程高性能的关键保障。<br>异步场景的复杂性</p></li><li><p>当等待的任务未完成（需异步等待）时，状态机依赖一系列辅助类型（如 AsyncTaskMethodBuilder<T>、TaskAwaiter<T>、MoveNextRunner 等）协作完成：</p><ul><li>注册任务延续（Continuation）。</li><li>维护执行上下文（ExecutionContext）。<br>跨线程调度时的状态安全流转。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;关于异步的历史&lt;/h1&gt;
&lt;p&gt;C#开发者在第一次接触异步的概念, 应该是通过Task类型. Task是在&lt;code&gt;.Net 4.0&lt;/code&gt;的时候被引入的. 一个task就是一个work单元, 且该task承诺, 在这个task未来完成的时候, 会将结果返回给ta</summary>
      
    
    
    
    <category term="C#" scheme="https://soincredible.github.io/categories/C/"/>
    
    
    <category term="异步" scheme="https://soincredible.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>精细化实验策略下一种多策略交叉的美术、动效框架的实现</title>
    <link href="https://soincredible.github.io/posts/4bbdbff1/"/>
    <id>https://soincredible.github.io/posts/4bbdbff1/</id>
    <published>2025-05-01T15:07:44.000Z</published>
    <updated>2025-05-07T03:12:56.673Z</updated>
    
    <content type="html"><![CDATA[<h1>笔者对精细化实验的定义</h1><p>当游戏要新增或改动一个功能时, 如果开发者不能确其会对用户体验造成什么影响, 就会用做实验的方式将功能发布到线上, 即将用户分为对照组和实验组, 看两组用户的数据表现, 来判断该功能的好坏. 如果实验组数据好于对照组, 则应用实验组, 反之应用对照组. 不论应用哪一组, 没有被应用的那一组的硬编码就可以删除掉, 因此实验组与对照组逻辑的代码只是会临时插入到项目中, 只要实验应用了之后把非应用实验分支的代码删干净, 长期下来是不会对整个项目代码结构有什么影响. 但是我们团队在按照上述模式推进了一段时间之后发现了这种模式存在问题, 同一个版本上线的多个实验之间存在交叉, 且会对单个实验的结果产生影响, 而且有的实验短期内是实验组的数据好, 而长期又变成了对照组的数据好. 因此, 我们认为之前对实验数据的结论不准确, 我们决定将一段周期内最早的那个版本的项目状态定义为<strong>基线组</strong>, 在这一周期内的每个版本会上线的实验都不会应用, 而是会一直在线上跑, 随着实验越开越多, 实验之间的交叉问题越来越严重, 又因为这些实验的分支代码不会删除, 代码也会变得越来越难以维护, 上述这种在一段周期上线大量不会应用实验, 且希望每个实验都能交叉, 在一段周期后会形成上百、上千条实验分支的实验, 就是<strong>精细化实验</strong>, 对应的, 我们团队就需要一套能够管理精细化实验的框架.</p><h1>精细化框架的实现思路</h1><p>每个实验能够交叉, 是十分美好的愿景. 但是, 在实际开发中我们发现, 经常会有互为互斥关系的实验存在, 比如两个实验同时对模块A做了改动, 或者实验一影响模块ABC, 实验二影响模块ABD, 这种情况是不可避免的, 因此, 精细化框架要做的事情, 不仅仅是驱动这些实验, 还要制定一套规范, 处理实验之间的冲突问题.</p><p>本篇博客笔者会以UI换皮实验和动效换皮实验为例子, 阐述UI框架、动效播放框架的实现思路, 以及这些框架和精细化框架的协同过程.</p><h2 id="从ABTest框架说起">从ABTest框架说起</h2><p>我们最初使用的AB测试系统十分简陋, AB测系统在启动时从磁盘上加载上来所有的AB实验信息, 根据设备的uid, 判断一个用户该表现为对照组还是实验组是根据用户使用设备的uid, 我们在后台配置一个实验的时候, 有多少个实验组就会生成几个“桶”, 这些桶里面装的是用户设备的uid, 用户设备启动游戏的时候, 程序能够知道当前设备在哪个桶里, 但是在某一个桶里并不意味着就一定表现为这个桶所对应的实验组, 还有其他的限制条件, 比如安装版本必须大于某一个版本或者必须是新用户, 或者必须是某一国家地区的等等. 总之, 业务层只需要把它们关系的实验字段传入, 就能够拿到当前设备对应实验所在的实验组是哪一个.</p><h2 id="精细化实验模块登场">精细化实验模块登场</h2><p>精细化实验要做的, 就是把ABTest框架和业务层解耦, 作为两者之间的桥梁. 当你想让两个模块解耦时, 最直接的方式就是在两个模块通讯的接口处增加桥接层, 有了这层桥接, ABTest中庞大的数据不至于一下子涌向业务层, 而是在精细化实验层整合、处理, 精细化实验层会把ABTest中影响同一个业务的实验们按照人为定义的规则进行整合、冲突处理, 然后将结果转换成对应业务能够识别的格式——精细化实验层需要和每一个具体的业务定义一套协议, 这套协议能够描述, 经过多个实验的多重影响, 该业务最终的表现效果是怎样的. 我们计划使用Json作为这些实验配置的载体:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;1024&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;uiTest&quot;,</span><br><span class="line">        &quot;experimentSceneType&quot;: &quot;UIStyle&quot;, </span><br><span class="line">        &quot;experimentParam&quot;: &#123;</span><br><span class="line">            &quot;group1&quot;: [</span><br><span class="line">                [</span><br><span class="line">                    &quot;homePage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;playPage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;resultPage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;settingPage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ]</span><br><span class="line">            ],</span><br><span class="line">            &quot;group2&quot;: [</span><br><span class="line">                [</span><br><span class="line">                    &quot;homePage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;playPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;resultPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;settingPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">     &quot;1025&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;uiTest2&quot;,</span><br><span class="line">        &quot;experimentSceneType&quot;: &quot;UIStyle&quot;, </span><br><span class="line">        &quot;experimentParam&quot;: &#123;</span><br><span class="line">            &quot;group1&quot;: [</span><br><span class="line">                [</span><br><span class="line">                    &quot;homePage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;playPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;resultPage&quot;,</span><br><span class="line">                    1</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;settingPage&quot;,</span><br><span class="line">                    4</span><br><span class="line">                ]</span><br><span class="line">            ],</span><br><span class="line">            &quot;group2&quot;: [</span><br><span class="line">                [</span><br><span class="line">                    &quot;homePage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;playPage&quot;,</span><br><span class="line">                    3</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;resultPage&quot;,</span><br><span class="line">                    5</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    &quot;settingPage&quot;,</span><br><span class="line">                    2</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>对上述Json格式做一下说明, 最外层的数字代表实验ID, <code>name</code>是实验名, <code>experimentSceneType</code>是实验场景, <code>experimentParam</code>能够描述实验场景下的实验内容, <code>group</code>代表实验分组, 不同实验场景下<code>group</code>字段下的结构不一样, 在<code>UIStyle</code>实验场景下是一个列表, 每个元素代表一个UI, 和该UI使用的<code>styleId</code>.</p><p>程序启动时必定加载上面两个实验, 并命中其中一个实验组, 而这两个实验是互斥的, 因此会在精细化实验层进行处理. 具体的处理规则, 则需要和策划团队一起制定, 硬编码进精细化实验模块中, 等业务场景足够丰富的时候, 也许可以从中提取出一套规则来支持配置. 不过这就不在本篇博客要讨论的范畴内了. 总之, 经过精细化层的处理之后, UIStyle实验场景会得到一组类似group字段内的列表, 这里面存储了所有UI的styleId, UIManager侧维护着每个UI每个styleId的映射关系. 有精细化层传来的参数, UIManager就可以给每个UI设置运行时styleId了.</p><p>我们设计的实验表格如下:</p><h2 id="UI框架的配表">UI框架的配表</h2><h2 id="音频框架配表">音频框架配表</h2><h2 id="动效配表">动效配表</h2><h2 id="实验配置">实验配置</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;笔者对精细化实验的定义&lt;/h1&gt;
&lt;p&gt;当游戏要新增或改动一个功能时, 如果开发者不能确其会对用户体验造成什么影响, 就会用做实验的方式将功能发布到线上, 即将用户分为对照组和实验组, 看两组用户的数据表现, 来判断该功能的好坏. 如果实验组数据好于对照组, 则应用实验组</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>时势:周期波动下的国家、社会和个人</title>
    <link href="https://soincredible.github.io/posts/1cb37a62/"/>
    <id>https://soincredible.github.io/posts/1cb37a62/</id>
    <published>2025-04-29T05:58:00.000Z</published>
    <updated>2025-05-07T03:12:56.673Z</updated>
    
    <content type="html"><![CDATA[<h1>日本失落的三十年</h1><p>日本财团</p><p>广场协议</p><p>国债</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;日本失落的三十年&lt;/h1&gt;
&lt;p&gt;日本财团&lt;/p&gt;
&lt;p&gt;广场协议&lt;/p&gt;
&lt;p&gt;国债&lt;/p&gt;
</summary>
      
    
    
    
    <category term="读万卷书" scheme="https://soincredible.github.io/categories/%E8%AF%BB%E4%B8%87%E5%8D%B7%E4%B9%A6/"/>
    
    
    <category term="读书笔记" scheme="https://soincredible.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>对C#中类型转换和拆装箱的思考</title>
    <link href="https://soincredible.github.io/posts/fad28a7c/"/>
    <id>https://soincredible.github.io/posts/fad28a7c/</id>
    <published>2025-04-26T03:18:44.000Z</published>
    <updated>2025-04-27T01:30:44.578Z</updated>
    
    <content type="html"><![CDATA[<h1>类型转换的开销来自哪里?</h1><p>类型转换在时间和空间上都会造成开销, 因为类型转换C#编译器会生成额外的类型转换处理代码, 导致代码文件的体积变大. 既然有额外的IL代码生成则就需要有额外的时间去执行. 如果类型转换中涉及到装拆箱操作, 则还会对运行时内存产生影响.</p><ul><li>CLR会生成额外IL代码执行类型转换是否合法的判断逻辑, 这部分开销是不可避免的, 即便开发者笃定类型转换必定合法. 不过这部分开销的影响并不大. 如果类型转换判定为不合法, 则需要额外的开销来处理异常, 我们通常会有两种类型转换的方式, 两种转换方式不合法的处理的开销不同:<ul><li>使用类型强转, 即<code>var a = (someType)b</code>形式, 这种方式在转换不合法的时候会抛出异常, 开销较大.</li><li>使用<code>as</code>操作符,即<code>var a = b as someType</code>, 这种方式在转换不合法的时候会将a字段设置为<code>null</code>,开销小. 更推荐使用这种方式.<br>不过如果你真的笃定类型转换不会出错, 那么以上这两种类型转换的方式其实影响不大.</li></ul></li><li>拆箱装箱造成的开销, 请记住这句话:<strong>装箱拆箱一定是类型转换造成的, 但是类型转换不一定会导致装箱拆箱</strong> 装拆箱详解请继续往下看.</li></ul><h1>值类型与引用类型</h1><p>值类型创建在栈上, 堆类型创建在堆上 这句话是不完全对的, 更准确的描述是: 引用类型一定创建在堆上, 值类型既可以创建在堆上, 也可以创建在栈上, 值类型创建在栈还是堆上取决于它所在的容器: 如果值类型是引用类型的一个成员字段, 则该值类型创建在堆上, 如果该值类型是一个局部变量(临时变量)或者是一个是另外一个值类型的字段成员的话, 则创建在堆上.</p><h1>装箱拆箱的开销来自哪里</h1><p><strong>装箱过程发生了什么</strong></p><ol><li>在托管堆中分配内存, 分配的内存量是值类型各字段所需的内存量, 还要加上托管堆所有对象都有的两个额外成员(类型对象指针和同步块索引)所需的内存量</li><li>值类型的字段复制到新分配的堆内存</li><li>返回对象地址. 现在该地址是对象引用; 值类型成了引用类型</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>拆箱过程发生了什么</strong><br>请反复阅读并理解这句话: <strong>拆箱不是直接将装箱过程倒过来, 拆箱过程本身不会复制任何类型, 但是拆箱过后往往跟随着一次字段的复制.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object obj = 10; //装箱</span><br><span class="line"></span><br><span class="line">int a = (int)b // 拆箱 + 字段的复制</span><br></pre></td></tr></table></figure><p><code>(int)b</code>部分完成了拆箱操作, <code>int a =</code>部分完成了字段复制操作, 我们在写代码的时候很自然而然地会这么写.</p><p>另外，值类型装箱后是不能改变它的值的，装箱后的值具有恒定性（Immutable）的特点，如果想给引用类型的变量赋予新的值，那就需要再堆上另开辟新的内存空间，一旦一个值类型被装箱，它的值就没有办法改变了. 看下面的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct ValueType</span><br><span class="line">&#123;</span><br><span class="line">    public int Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void SomeFunc()</span><br><span class="line">&#123;</span><br><span class="line">    var value = new ValueType</span><br><span class="line">    &#123;</span><br><span class="line">        Value = 100</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    object vv = value;</span><br><span class="line">    </span><br><span class="line">    ((ValueType)vv).Value = 200; // 这里会报错Cannot modify struct member when accessed struct is not classified as a variable</span><br><span class="line"></span><br><span class="line">    var vvv = ((ValueType)vv); // 不会报错</span><br><span class="line">    vvv.Value = 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 如果只是进行拆箱操作, 我们无法对拆箱后的字段做任何修改, 并报错提示拆箱后的值成员并没有分类为变量, 我们必须将拆箱后的数据复制给一个值类型变量, 在这个变量上进行修改, 不过这个变量是拆箱数据的拷贝, 拆箱的数据没有任何关系. 所以上面才说<strong>拆箱过后往往跟随着一次字段的复制</strong></p><h1>反复地拆装箱</h1><p>反复地拆装箱会产生额外的IL代码, 增加代码体积. 更大的问题是, 额外的装箱步骤会在托管堆中分配额外的对象, 将来必须对其进行垃圾回收. 拆装箱的滥用会严重影响程序的性能和内存消耗.<br>如果我们想修改装箱后的值类型的内容, 虽然笔者想不出实际开发中会有这种场景, 我们就必须先将其拆箱, 接着复制给一个值类型变量, 修改值类型变量的内容, 将值类型变量装箱, 最后把指向原来装箱值类型在堆上地址的引用指向的地址改为指向新的值类型变量装箱后所在堆上的地址. 那么原来那一个被装箱的值类型在堆上占据的内容空间就废弃了, 在未来需要进行垃圾回收. 这也就是为什么装箱拆箱会引起GC。</p><h1>小节</h1><p>在实际写代码的过程中, 拆装箱问题并不常见, 因为大部分开发者想都不想只会把class传来传去, 而且我们肯定不会闲得声明一个object类型的字段, 却用一个值类型的数据给它赋值. 所以类型转换中主要的性能开销<strong>在于CLR会生成额外IL代码执行类型转换是否合法的判断逻辑</strong>(程序员一般情况下还是可以保证类型转换是合法的).</p><h1>其他要注意的点</h1><p><strong>类型检查中要注意的点</strong><br>使用<code>is</code>操作符和<code>.GetType()</code>接口都可以做类型检查, 但是两者的开销是不同的, 按照GPT的说法, <code>is</code>操作符的性能开销要小于<code>.GetType()</code>的开销:</p><ul><li>使用<code>is</code>操作符, C#编译器生成直接的类型检查指令(isinst IL指令), 无需触发完整的类型元数据加载. <code>is</code>操作符会利用类型继承关系进行快速判断, 无需获取完整的Type对象, 值类型优化: 如果转换后的类型是值类型, is会避免装箱, 前提是obj是值类型且类型兼容</li><li>使用<code>.GetType()</code>时, 会触发完整类型元数据加载, 需要访问对象的Type对象, 涉及元数据查询<br>精确类型比较: GetTypE()返回的是对象的实际运行时类型, 与typeof(MyType)比较时,只有当obj的运行时类型完全等于MyType时才返回true, <code>.GetType()</code>是虚方法调用, 需经过虚方法表查找.</li></ul><p>当然, <code>.GetType</code>也有其用武之处, 因为在有些场景下确实是需要精确查找的, 继承关系A-&gt;B-&gt;C, A是基类, 如果传入的实例是C, 使用<code>is B</code>返回的结果是true, 而使用<code>.GetType() == typeof(B)</code> 返回的是false. 实际开发中大部分场景下<code>is</code>操作符就足够完成需求了.</p><p><strong>typeof、GetType()、is 和 as 这四种类型判断操作的开销对比</strong></p><table><thead><tr><th>操作</th><th>开销来源</th><th>适用场景</th><th>示例代码</th></tr></thead><tbody><tr><td>typeof(T)</td><td>⚡️ 编译时静态解析（零运行时开销）</td><td>编译时已知类型</td><td>if (type == typeof(MyClass))</td></tr><tr><td>is</td><td>⚡️ 单次类型检查（无转换）</td><td>安全类型检查</td><td>if (obj is MyClass)</td></tr><tr><td>as</td><td>⚡️ 单次类型检查 + 返回转换结果</td><td>安全类型转换</td><td>var x = obj as MyClass;</td></tr><tr><td>GetType()</td><td>⚠️ 访问对象类型句柄 + 元数据查找</td><td>需获取对象实际运行时类型</td><td>if (obj.GetType() == typeof(MyClass))</td></tr></tbody></table><p><strong>值类型、引用类型与闭包</strong></p><p>因为值类型的生命周期会随着其作用域的结束而释放掉, 但是引用类型不会, 引用类型释放掉的只是指向堆上内存位置的指针而已. 本来笔者计划使用闭包的方式把两种类型带出其各自的作用域, 不过实操下来, 两种类型里面的数据都是正常读取的. 据GPT说值类型的闭包是将数据复制了一份传入到了闭包中, 因此在原值类型数据生命周期外数据能正确读取, 而引用类型则是在其生命周期结束之后, 真正的数据还都存放在堆上呢根本就没释放掉呢, 因此可以正确读取, 不过笔者个人猜测, 引用类型本身(或者叫创建在线程栈上指向堆中数据的指针)在生命周期结束后其实也被释放掉了, 在闭包中也是传入了这个引用类型本身的一份拷贝而已. 但是笔者在这里就不深究了.</p><h1>更优雅的类型转换</h1><p>按照GPT的说法, 泛型是一种能够规避类型转换、且保证类型安全的双赢方法, 泛型的类型转换并不是在运行时做的, 而是在编译时编译器静默地进行了类型转换, 因此泛型在运行时是没有额外开销的.</p><p>下面看两组代码的对比:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 非泛型接口</span><br><span class="line">public interface IUILogic</span><br><span class="line">&#123;</span><br><span class="line">    void OnShow(object data); // 数据用 object 传递</span><br><span class="line">    void OnClose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 非泛型基类</span><br><span class="line">public abstract class BaseEUI : MonoBehaviour, IUILogic</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void OnShow(object data);</span><br><span class="line">    public abstract void OnClose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体 UI 类（需手动转换数据）</span><br><span class="line">public class PlayPage : BaseEUI</span><br><span class="line">&#123;</span><br><span class="line">    public override void OnShow(object data)</span><br><span class="line">    &#123;</span><br><span class="line">        var showData = (PlayPageShowData)data; // 运行时转换</span><br><span class="line">        // 实际逻辑...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void OnClose() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UI 管理器</span><br><span class="line">public class UIMgr</span><br><span class="line">&#123;</span><br><span class="line">    public static UIMgr Instance &#123; get; &#125; = new UIMgr();</span><br><span class="line">    private Dictionary&lt;Type, BaseEUI&gt; _uiInstances = new Dictionary&lt;Type, BaseEUI&gt;();</span><br><span class="line"></span><br><span class="line">    public void ShowUI(Type uiType, object data)</span><br><span class="line">    &#123;</span><br><span class="line">        if (_uiInstances.TryGetValue(uiType, out var ui))</span><br><span class="line">        &#123;</span><br><span class="line">            ui.OnShow(data); // 非泛型调用</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            var obj = Resources.Load(&quot;&quot;);</span><br><span class="line">            var go = Object.Instantiate(obj) as GameObject;</span><br><span class="line">            ui = go.AddComponent(uiType) as BaseEUI;</span><br><span class="line">            ui.OnShow(data);</span><br><span class="line">            _uiInstances.Add(uiType, ui);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用示例</span><br><span class="line">var param = new PlayPageShowData();</span><br><span class="line">UIMgr.Instance.ShowUI(typeof(PlayPage), param); // 需显式传递 Type</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 泛型接口（类型安全）</span><br><span class="line">public interface IUILogic&lt;TUIShowData&gt; where TUIShowData : struct</span><br><span class="line">&#123;</span><br><span class="line">    void OnShow(TUIShowData data); // 明确数据类型</span><br><span class="line">    void OnClose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 泛型基类</span><br><span class="line">public abstract class BaseEUI&lt;TUIShowData&gt; : MonoBehaviour, IUILogic&lt;TUIShowData&gt; </span><br><span class="line">    where TUIShowData : struct</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void OnShow(TUIShowData data);</span><br><span class="line">    public abstract void OnClose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体 UI 类（无需手动转换数据）</span><br><span class="line">public class PlayPage : BaseEUI&lt;PlayPageShowData&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public override void OnShow(PlayPageShowData data) // 直接使用具体类型</span><br><span class="line">    &#123;</span><br><span class="line">        // 直接访问 data 的字段，无需类型转换</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void OnClose() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UI 管理器（泛型版）</span><br><span class="line">public class UIMgr</span><br><span class="line">&#123;</span><br><span class="line">    public static UIMgr Instance &#123; get; &#125; = new UIMgr();</span><br><span class="line">    private Dictionary&lt;Type, object&gt; _uiInstances = new Dictionary&lt;Type, object&gt;();</span><br><span class="line"></span><br><span class="line">    // 泛型方法：类型安全且无装箱</span><br><span class="line">    public void ShowUI&lt;TUI, TUIShowData&gt;(TUIShowData data)</span><br><span class="line">        where TUI : BaseEUI&lt;TUIShowData&gt;, new()</span><br><span class="line">        where TUIShowData : struct</span><br><span class="line">    &#123;</span><br><span class="line">        if (_uiInstances.TryGetValue(typeof(TUI), out var ui))</span><br><span class="line">        &#123;</span><br><span class="line">            ((IUILogic&lt;TUIShowData&gt;)ui).OnShow(data); // 需一次接口转换</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            var obj = Resources.Load(&quot;&quot;);</span><br><span class="line">            var go = Object.Instantiate(obj) as GameObject;</span><br><span class="line">            var uiLogic = go.AddComponent&lt;TUI&gt;();</span><br><span class="line">            uiLogic.OnShow(data);</span><br><span class="line">            _uiInstances.Add(typeof(TUI), uiLogic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用示例</span><br><span class="line">var param = new PlayPageShowData();</span><br><span class="line">UIMgr.Instance.ShowUI&lt;PlayPage, PlayPageShowData&gt;(param); // 编译时类型检查</span><br></pre></td></tr></table></figure><p>对比上面两组代码, 非泛型方式打开一个UI要经过4次类型转换, 而且还有装箱和拆箱的风险; 而泛型版本打开一个UI只需要进行2次类型转换</p><p><strong>非泛型和泛型方案对比</strong></p><table><thead><tr><th>特性</th><th>非泛型方案</th><th>泛型方案 (IUILogic<T>)</th></tr></thead><tbody><tr><td>类型安全</td><td>❌ 运行时可能 InvalidCastException</td><td>✔️ 编译时检查</td></tr><tr><td>数据传递效率</td><td>⚠️ 值类型会装箱（struct → object）</td><td>✔️ 无装箱（直接传递 struct）</td></tr><tr><td>代码复杂度</td><td>✔️ 更简单</td><td>❌ 需要泛型约束和类型参数</td></tr><tr><td>性能开销</td><td>⚠️ 装箱/拆箱 + 类型转换</td><td>⚡️ 无额外开销（除可能的 as 转换）</td></tr><tr><td>扩展性</td><td>❌ 新增 UI 需手动维护数据类型</td><td>✔️ 自动适配不同 TUIShowData</td></tr></tbody></table><p><strong>注意</strong> 泛型确实是一种十分优雅的类型转换方式, 但是妄图使用泛型替代所有的类型转换是不可能的. 泛型在一定程度上破坏了突破了面向对象的继承结构的限制, 但是你想要在面向对象的编程语言中编写非面向对象的代码是十分困难的, 看上面UIMgr代码的例子你就知道了, UIMgr作为所有UI的管理者, 它管理者一类UI, 为了实现管理一组对象的效果, 这一组对象在UIMgr的视角下必须是同一种类的, 也就是它们要具有同一父类, 因此即便泛型打破了继承关系, 但是在管理一组对象这种领域还是无法替代普通类型转换, 所以在由上层管理到底层执行之间有一个不可避免的类型转换, 不过这一次类型转换是必定成功的, 这是由上层管理和底层具体执行视角不同导致的.</p><h1>总结</h1><p>因此, 滥用object作为接口的参数并不是一种优雅的方式, 类型转换在实际开发中不可避免, 但我们还是可以通过泛型等方式尽可能地减少类型转换的开销.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;类型转换的开销来自哪里?&lt;/h1&gt;
&lt;p&gt;类型转换在时间和空间上都会造成开销, 因为类型转换C#编译器会生成额外的类型转换处理代码, 导致代码文件的体积变大. 既然有额外的IL代码生成则就需要有额外的时间去执行. 如果类型转换中涉及到装拆箱操作, 则还会对运行时内存产生影</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUGUI源码</title>
    <link href="https://soincredible.github.io/posts/906aab82/"/>
    <id>https://soincredible.github.io/posts/906aab82/</id>
    <published>2025-04-19T08:46:20.000Z</published>
    <updated>2025-04-27T01:30:44.577Z</updated>
    
    <content type="html"><![CDATA[<h1>UGUI的渲染和3D物体渲染的区别?</h1><p>笔者希望各位读者区分两个概念: 渲染和渲染所需的数据更新. Unity首先更新其要渲染物体的渲染数据, 然后根据渲染数据将画面渲染到屏幕上, 笔者在最初接触这部分内容时, 把两者混为一谈, 给自己造成了理解上的困难, 因此在此说明.</p><p>UGUI的渲染发生在每一帧<code>CanvasUpdateRegistry</code>的<code>SendWillRenderCanvases()</code>接口被调用之后,不过我们看不到调用该接口的代码,猜测调用处通过<code>[RequireByNativeCode]</code>特性隐藏在了Unity更底层的引擎代码中. 但这不影响我们知道UGUI的渲染位于事件执行的什么位置. 为了知道这几个事件的执行顺序,因为这些事件是在每一帧都执行的, 所以使用断点调试的方式不太方便, 于是笔者尝试使用Log方式观察几个事件的执行顺序,</p><h1>CanvasScaler</h1><p>按照标准分辨率来设计的</p><p>Unity粒子的Render和Canvas的OrderInLayer是一样的 用来处理渲染层级的问题</p><p>常规模型和粒子满足谁距离摄像机近谁后渲染<br>在Unity中创建一个场景，创建两个Image，然后创建一个Sphere，将Sphere放置在两个Image中间，会发生奇怪的事情<br>UI和常规模型满足谁距离摄像机近谁后渲染<br>UI和粒子就不满足谁距离摄像机近谁后渲染 为什么？ 给粒子系统挂载RectTransform就会这样<br>移除RectTransform后就没有问题了 RectTransform改变了什么？<br>RectTransform组件上的Pos Z字段可以设置游戏对象的Z轴位置，但是不影响显示顺序，在同一个Canvas画布中，游戏对象的显示顺序由Hierarchy视图中的顺序决定<br>即便是在不同的Canvas中想通过调整PosZ字段也不能影响显示顺序 处理不同Canvas的显示顺序是通过修改Canvas的 OrderInLayer值来实现的</p><p>疑惑场景<br>两个Canvas，每个Canvas下面都有一个Image组件，Hierarchy窗口中Canvas1在Canvas2上面，无论如何调整Canvas1和Canvas2的PosZ属性，只要不动Canvas的OrderInLayer属性，Canvas2就一直会显示在Canvas1上面<br>Canvas1<br>Canvas2</p><p>如果在场景中创建一个Sphere 3D物体，物体上挂载的是Transform不是RectTransform，调整Sphere、Canvas1、Canvas2的PosZ属性使得距离摄像机有远到近的关系为：Canvas2、Sphere、Canvas1，会发现Sphere会潜入Canvas2中，而Canvas1本应该被Canvas2盖住，但是现在也会在Sphere遮挡Canvas2的区域中显示出来，原因是什么？</p><p>就算只有一个Canvas 下添加两个Image组件，Hierarchy中Image1在Image2的上面 就算Image1的PosZ比Image2的PosZ要小 Image1还是应该被Image2挡住，但是将Sphere放在两个Image中间的时候也会出现上述情况，为什么？</p><p>RectTransform的PosZ不能用来处理UI元素之间的层级关系 但是可以用来处理UI和3D物体之间的层级关系</p><p>Unity是如何渲染UI的？</p><h1>Unity的渲染顺序</h1><p>如果开启了深度测试永远都是离摄像机近的物体该在离摄像机远的物体之前</p><h1>Canvas</h1><p>Canvas组件提供了一个供UI布局和渲染的抽象空间。所有的UI元素必须是一个挂载有Canvas组件的GameObject的子。当我们创建一个UI元素的时候，如果场景中还没有一个带有Canvas的物体，那么一个Canvas的Object将会自动被创建出来。</p><h2 id="属性">属性</h2><ul><li>Render Mode: UI渲染到屏幕上或者是作为一个Object被渲染到3D空间中的方式。共有三种选项 Screen Space - Overlay， Screen Space - Camera和World Space</li><li>Pixel Pefect(Screen Space modes only): 为了精度UI是否应该关闭抗锯齿并渲染</li><li>Render Camera(Screen Space - Camera mode onle): UI要被渲染到哪个Camera上</li><li>Sort Order: 用于控制不通过Canvas之间的绘制顺序，数值越大，该canvas的绘制优先级越高，会绘制在其他Canvas的上方</li><li>Plane Distance(Screen Space - Camera mode only): 被渲染的UI放置在渲染摄像机前的距离</li><li>Event Camera(World Space mode only): 用来运行UI Event的Camera</li><li>Receives Events: UIEvent是否会被该Canvas驱动？</li></ul><h2 id="细节">细节</h2><p>对于所有的UI元素单个Canvas已经是足够的了，但是在场景中放置多个Canvas也是可以的。同样地，使用嵌套Canvas也是可以的，一般我们出于优化的目的会将一个Canvas设置为另一个Canvas的子节点。嵌套Canvas的Canvas采用和父Canvas相同的渲染模式。</p><p>传统方式中，所有的UI就像它们是简单的图形设计一样被直接地渲染到了屏幕上。这就是说，在Camera的视角下，它们是没有3D空间的概念的。Unity支持这种屏幕空间的渲染并且同时支持UI作为Object被渲染到3D空间中，这取决于Render Mode的值。</p><h2 id="Screen-Space-Overlay">Screen Space - Overlay</h2><p>这种模式下，Canvas会被缩放以适应屏幕然后在没有场景或者Camera的参照下直接渲染出来（UI会直接渲染出来，即使场景中根本就没有Camera）。如果屏幕的尺寸或者分辨率发生了改变，那么UI会自动地重新缩放来适应新的尺寸。UI会绘制在任何其他图形比如摄像机视角的上层</p><p>注意：Screen Space - Overlay模式下，挂载canvas的节点必须是在hierarchy窗口中的最上级的节点。如果没有这样使用canvas的话可能会导致UI从视野里消失。这是从Unity引擎设计上的局限，因此保持ScreenSpace - Overlay canvas在hierarchy的最顶层以保证能够获得期望的效果</p><h2 id="Screen-Space-Camera">Screen Space - Camera</h2><p>在这种模式下，Canvas会被渲染在一个平面的物体上，该平面距离给定的摄像机有一定的距离，这种模式下的UI显示在屏幕上的尺寸并不会随着距离而变化，因为它总是会重新缩放来适应Camera的平截头体中，如果屏幕的尺寸或者分辨率或者Camera的平截头体发生了变化，那么该UI会自动的缩放来适应改变话。任何在场景中的3D物体如果距离摄像机比该UI近的话，那么就会被渲染在该UI的前面，而在UI后面的物体就会被遮挡</p><h2 id="World-Space">World Space</h2><p>这种模式下的UI会想一个平面的物体一样被渲染在场景中，不想Screen Space - Camera一样，这种模式下的UI不需要面向摄像机并且可以朝向任何方向，这种模式下的Canvas的尺寸可以通过该节点上的RectTransform组件进行设置。而它的显示效果取决于观看角度和该UI距离Camera的距离，其他场景中的物体可以穿过该UI，或者在它的前面，或者在它的后面</p><h1>CanvasScaler</h1><p>Canvas Scaler组件用来控制UI元素在Canvas上的整体缩放和像素密度。这个组件会影响所有的位于该Canvas组件下的UI元素，包括字体大小和图片的边界</p><h2 id="属性-2">属性</h2><ul><li>UIScaleMode:  决定在该Canvas上的UI元素该如何进行缩放<ul><li>ConstantPixelSize: 让UI元素保持相同的像素不论屏幕的尺寸<ul><li>Scale Factor: 该Canvas中的所有UI元素的缩放受该factor影响</li><li>ReferencePixelsPerUnit: 如果一个sprite进行了Pixel Per Unity的设置，那么在该sprite中的一个像素将会覆盖一个单元</li></ul></li><li>ScaleWithScreenSize: 屏幕的尺寸越大，UI元素也越大<ul><li>Reference Resolution: UI布局是基于此分辨率设计的，如果屏幕分辨率更大，那么UI会被放大，反之UI会被缩小</li><li>ScreenMatchMode: 一种模式用来适应不同分辨率UI的缩放方式<ul><li>Match Width or Height: 如果设备的分辨率和默认分辨率不匹配的话，那么是保证宽和原分辨率成比例还是高与原分辨率成比例</li><li>Expand:</li><li>Shrink:</li></ul></li><li>Match: 决定</li><li>Reference Pixels Per Unit</li></ul></li><li>ConstantPhysicalSize: 让UI元素保持同样的物理尺寸的大小而不管屏幕的尺寸和分辨率<ul><li>Physical Unit:</li><li>Fallback Screen DPI</li><li>Default Sprite DPI</li><li>Reference Pixels Per Unit</li></ul></li></ul></li><li>当Canvas的RenderMode被设置为WorldSpace的时候<ul><li>Dynamic Pixels Per Unit： 表示UI中动态创建的位图，比如Text，中单个单元的像素数量</li><li>Reference Pixels Per Unit:  如果一个sprite有这个Pixels Per Unity的设置，那么在Sprite中的一个像素将会覆盖世界场景中韩的一个单元，如果Reference Pixel Per Unit 被设置为了1，那么在sprite中的Pixels Per Unit设置将会被直接使用</li></ul></li></ul><h2 id="细节-2">细节</h2><p>对于被设置为Screen Space - Overlay 或者 Screen Space - Camera 的 Canvas，Canvas Scaler UI 的 Scale Mode 可以被设置为Constant PixelSize， Scale With Screen 或者 Constant Physical Size</p><h2 id="Constant-Pixel-Size">Constant Pixel Size</h2><h2 id="Scale-With-Screen-Size">Scale With Screen Size</h2><h2 id="Constant-Physical-Size">Constant Physical Size</h2><h2 id="World-Space-2">World Space</h2><h1>CanvasGroup</h1><p>CanvasGroup用来控制某些方面</p><h1>CanvasRenderer</h1><p>Canvas Renderer 组件将一个Canvas中的一个图像UI渲染出来，该组件需要挂载在每一个需要显示在屏幕上的UI组件上，Canvas Renderer组件没有任何属性暴露在inspector窗口中</p><h2 id="细节-3">细节</h2><p>在Unity的菜单中可以创建的标准的UI组件上不论你需不需要都挂载有Canvas Renderer组件，但是当我们开发我们自定义的UI组件的时候，我们需要手动将该组件挂载到自定义UI上，尽管在Inspector窗口中没有任何的属性，但是有一些属性和功能还是可以通过代码的形式来控制</p><h1>GraphicRaycaster</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;UGUI的渲染和3D物体渲染的区别?&lt;/h1&gt;
&lt;p&gt;笔者希望各位读者区分两个概念: 渲染和渲染所需的数据更新. Unity首先更新其要渲染物体的渲染数据, 然后根据渲染数据将画面渲染到屏幕上, 笔者在最初接触这部分内容时, 把两者混为一谈, 给自己造成了理解上的困难, </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity事件更新顺序</title>
    <link href="https://soincredible.github.io/posts/11d7edcb/"/>
    <id>https://soincredible.github.io/posts/11d7edcb/</id>
    <published>2025-04-18T22:33:36.000Z</published>
    <updated>2025-04-27T01:30:44.577Z</updated>
    
    <content type="html"><![CDATA[<h1>Unity事件执行顺序图</h1><p><a href="https://docs.unity3d.com/cn/2022.3/uploads/Main/monobehaviour_flowchart.svg"></a></p><h1>Awake、OnDestroy、OnEnable、OnDisable四者执行时机梳理</h1><p><code>OnEnable</code>方法在AddComponent、<strong>跟随预制体实例化(这里要十分注意挂载该脚本的GameObj的avtive状态要是true的情况下才会触发!)</strong>、在代码中手动设置enable为true的时候会调用.<br><code>OnDisable</code>方法是跟随预制体被删除、在代码中手动设置enable为false的时候会调用.</p><p><code>Awake</code>方法在AddComponent、<strong>跟随预制体实例化的时候会调用(这里要十分注意挂载该脚本的GameObj的avtive状态要是true的情况下才会触发!)</strong>. 整个组件的生命周期只会调用一次<br><code>OnDestroy</code>方法在跟随预制体被删除的时候调用. 整个组件的生命周期只会调用一次 <strong>注意,如果在这个预制体被实例化到销毁的这一生命周期内,挂载该脚本的节点的active一直都是false,那么就不会触发Awake,也不会触发OnDestroy,只要该节点被active过,即便被销毁的时候该节点处在not active状态,也会触发OnDestroy</strong></p><ul><li><code>yield WaitForEndOfFrame</code>是在干嘛?</li></ul><p>在非PlayMode下,有哪些生命周期内的方法会被执行?<br>在Unity开发过程中，我们经常需要在编辑器启动时或脚本重新编译后执行一些操作，例如初始化数据、注册事件等。这时，我们可以使用InitializeOnLoad特性来实现这一需求。本文将详细介绍InitializeOnLoad特性的用法，并通过三个实际案例来展示其应用场景。</p><p>OnValidate方法是一个仅限编辑器的函数，在Unity加载脚本或检查器中的值更改时调用。它的调用时机非常特殊，这里总结一下。</p><ol><li><p>OnValidate不受播放模式影响，只要其值发生变化，在非播放状态下也会被调用（可以用于非播放模式修改参数后更新）。</p></li><li><p>不受enabled状态影响，即使其所在的脚本被禁用，修改值时也会被正常调用。</p></li><li><p>更改脚本enabled状态时，会调用一次OnValidate。如果在Play Mode，OnValidated的调用时机在OnDisable或者OnEnable前。</p></li><li><p>更改GameObject active状态不会调用OnValidate，只有OnDisable和OnEnable会被调用。</p></li><li><p>初始加载时，无论enabled状态和active状态如何，都会被调用多次。其调用时机在Awake之前。</p></li></ol><p>常见用法：</p><ol><li><p>用于Play Mode下修改参数值，实时查看效果</p></li><li><p>实时更新资产文件，比如材质、shader等</p></li></ol><h1>参考资料</h1><ul><li><a href="https://blog.csdn.net/angry_youth/article/details/117469722">https://blog.csdn.net/angry_youth/article/details/117469722</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Unity事件执行顺序图&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/cn/2022.3/uploads/Main/monobehaviour_flowchart.svg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Awake、OnDestroy、</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityShader实现水的效果</title>
    <link href="https://soincredible.github.io/posts/265490d3/"/>
    <id>https://soincredible.github.io/posts/265490d3/</id>
    <published>2025-04-18T22:28:48.000Z</published>
    <updated>2025-04-27T01:30:44.577Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityShader实现草的效果</title>
    <link href="https://soincredible.github.io/posts/b1964c5e/"/>
    <id>https://soincredible.github.io/posts/b1964c5e/</id>
    <published>2025-04-18T22:28:32.000Z</published>
    <updated>2025-04-27T01:30:44.577Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityShader实现云的效果</title>
    <link href="https://soincredible.github.io/posts/81b49e5c/"/>
    <id>https://soincredible.github.io/posts/81b49e5c/</id>
    <published>2025-04-18T22:28:19.000Z</published>
    <updated>2025-04-27T01:30:44.577Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUGUI问题记录</title>
    <link href="https://soincredible.github.io/posts/2b97ac4f/"/>
    <id>https://soincredible.github.io/posts/2b97ac4f/</id>
    <published>2025-04-18T22:25:47.000Z</published>
    <updated>2025-05-07T12:15:13.507Z</updated>
    
    <content type="html"><![CDATA[<h1>为什么会有<code>LayoutRebuilder.ForceRebuildLayoutImmediate(RectTransform)</code>接口? 什么时候用这个接口?</h1><p>我们在某一帧的Update或者EventInput中执行了一段代码, 这段代码会修改某一UGUI组件的某些属性,我们知道,当一个UGUI组件的属性发生变化时,这个UGUI组件下面的所有UGUI组件的属性也会连带着发生变化. 但是在一帧内,这种变化不是真的同时发生的,UGUI的数据更新发生在<code>LateUpdate</code>之后,<code>OnPreCull</code>之前. 这是笔者还亲自验证的. 具体验证过程在<a href="">这篇博客</a>中.也就是说Unity会先执行完所有的代码逻辑, 然后再去更新这些UGUI组件的属性, 所以在这一帧中我们执行的修改UGUI组件属性的操作,只有在下一帧时,我们才能够拿到这个组件下UGUI组件的属性的正确值.<br>如果我们想在当前这一帧就获得正确的UGUI组件的属性,那么<code>LayoutRebuilder.ForceRebuildLayoutImmediate(RectTransform)</code>接口就派上用场了. 这个接口会强制更新传入UGUI及其子UGUI的RectTransform组件的属性, 然后我们就可以在当前帧获得正确的属性值了. 在笔者的开发经验中, 该接口一般会在使用UGUI里的Layout相关组件的时候比较常用.</p><h1>几个LayoutGroup组件的实现原理</h1><p>一个例子就是让父UI组件的尺寸跟着子UI组件的尺寸变化<br><a href="https://blog.csdn.net/yhx956058885/article/details/130729325">https://blog.csdn.net/yhx956058885/article/details/130729325</a></p><h1>Coffee UIEffect这个UI扩展库 里面的UIShadow组件上的值的实现原理和不同是什么? Outline和Outline8的区别? Fit还有一个什么忘了的区别?</h1><h1>Screen接口中的width和height 和 currentResolution的区别?</h1><h1>让UI变灰色</h1><p>给UI要变灰的UI组件挂载一个变灰材质</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;UI/Gray&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line"></span><br><span class="line">        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8</span><br><span class="line">        _Stencil (&quot;Stencil ID&quot;, Float) = 0</span><br><span class="line">        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0</span><br><span class="line">        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255</span><br><span class="line">        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255</span><br><span class="line"></span><br><span class="line">        _ColorMask (&quot;Color Mask&quot;, Float) = 15</span><br><span class="line"></span><br><span class="line">        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;PreviewType&quot;=&quot;Plane&quot;</span><br><span class="line">            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stencil</span><br><span class="line">        &#123;</span><br><span class="line">            Ref [_Stencil]</span><br><span class="line">            Comp [_StencilComp]</span><br><span class="line">            Pass [_StencilOp]</span><br><span class="line">            ReadMask [_StencilReadMask]</span><br><span class="line">            WriteMask [_StencilWriteMask]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cull Off</span><br><span class="line">        Lighting Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest [unity_GUIZTestMode]</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        ColorMask [_ColorMask]</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name &quot;Default&quot;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma target 2.0</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;UnityUI.cginc&quot;</span><br><span class="line"></span><br><span class="line">            #pragma multi_compile __ UNITY_UI_CLIP_RECT</span><br><span class="line">            #pragma multi_compile __ UNITY_UI_ALPHACLIP</span><br><span class="line"></span><br><span class="line">            struct appdata_t</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : POSITION;</span><br><span class="line">                float4 color    : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : SV_POSITION;</span><br><span class="line">                fixed4 color    : COLOR;</span><br><span class="line">                float2 texcoord  : TEXCOORD0;</span><br><span class="line">                float4 worldPosition : TEXCOORD1;</span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _TextureSampleAdd;</span><br><span class="line">            float4 _ClipRect;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_t v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f OUT;</span><br><span class="line">                UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);</span><br><span class="line">                OUT.worldPosition = v.vertex;</span><br><span class="line">                OUT.vertex = UnityObjectToClipPos(OUT.worldPosition);</span><br><span class="line"></span><br><span class="line">                OUT.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"></span><br><span class="line">                OUT.color = v.color * _Color;</span><br><span class="line">                return OUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f IN) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;</span><br><span class="line"></span><br><span class="line">                #ifdef UNITY_UI_CLIP_RECT</span><br><span class="line">                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                #ifdef UNITY_UI_ALPHACLIP</span><br><span class="line">                clip (color.a - 0.001);</span><br><span class="line">                #endif</span><br><span class="line">                // 色彩变灰  亮度提取矩阵</span><br><span class="line">                float gray = dot(color.xyz, float3(0.299, 0.587, 0.114));</span><br><span class="line">                color.xyz = float3(gray, gray, gray);</span><br><span class="line">                return color;</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>UGUI实现文字边缘发光效果</h1><h1>Unity实现Text部分区域可响应点击</h1><p>源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">namespace UI.UIItems</span><br><span class="line">&#123;</span><br><span class="line">    public class HyperlinkText : Text, IPointerClickHandler</span><br><span class="line">    &#123;</span><br><span class="line">        protected override void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">            Set_TextLinkFuncCB(Application.OpenURL);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 解析完最终的文本</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        private string m_OutputText;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 超链接信息列表</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        private readonly List&lt;HrefInfo_&gt; m_HrefInfos = new List&lt;HrefInfo_&gt;();</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 文本构造器</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        protected static readonly StringBuilder s_TextBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 超链接正则</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        private static readonly Regex s_HrefRegex =</span><br><span class="line">            new Regex(@&quot;&lt;a href=([^&gt;\n\s]+)&gt;(.*?)(&lt;/a&gt;)&quot;, RegexOptions.Singleline);</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        private static readonly Regex s_VertexFilter = new Regex(@&quot;(|[ \n\r\t]+)&quot;, RegexOptions.Singleline);</span><br><span class="line"></span><br><span class="line">        VertexHelper _toFill = null;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 是否使用超链接  默认未False</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        bool bool_IsLink = true;</span><br><span class="line"></span><br><span class="line">        private Action&lt;string&gt; linkFunc_Cb = null;</span><br><span class="line"></span><br><span class="line">        private RectTransform rect_Parent;</span><br><span class="line">        private RectTransform Rect_Parent</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                if (rect_Parent == null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Transform trans = this.transform.parent != null ? this.transform.parent.transform : this.transform;</span><br><span class="line">                    rect_Parent = trans.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return rect_Parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //设置 文本 超链接的点击回调事件</span><br><span class="line">        public void Set_TextLinkFuncCB(Action&lt;string&gt; linkFunc_Cb)</span><br><span class="line">        &#123;</span><br><span class="line">            bool_IsLink = true;</span><br><span class="line">            if (this.linkFunc_Cb != null)</span><br><span class="line">            &#123;</span><br><span class="line">                this.linkFunc_Cb = null;</span><br><span class="line">            &#125;</span><br><span class="line">            this.linkFunc_Cb = linkFunc_Cb;</span><br><span class="line">            OnPopulateMesh(_toFill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //字符顶点数</span><br><span class="line">        const int perCharVerCount = 4;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 文本构造器</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        protected static readonly StringBuilder textRebuild = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        protected override void OnPopulateMesh(VertexHelper toFill)</span><br><span class="line">        &#123;</span><br><span class="line">            if (toFill == null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            _toFill = toFill;</span><br><span class="line">            //TODO 编辑器状态下这里不执行， 方便调试看到效果用</span><br><span class="line">            if (!bool_IsLink)</span><br><span class="line">            &#123;</span><br><span class="line">                m_Text = GetOutputText_Nomal(text);</span><br><span class="line">                base.OnPopulateMesh(toFill);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var orignText = m_Text;</span><br><span class="line">            m_OutputText = GetOutputText_Init(text);</span><br><span class="line">            m_Text = m_OutputText;</span><br><span class="line">            text = m_OutputText;</span><br><span class="line">            base.OnPopulateMesh(toFill);</span><br><span class="line">            m_Text = orignText;</span><br><span class="line">            GetOutputText(text, toFill.currentVertCount);</span><br><span class="line"></span><br><span class="line">            UIVertex vert = new UIVertex();</span><br><span class="line"></span><br><span class="line">            // 处理超链接包围框</span><br><span class="line">            foreach (var hrefInfo in m_HrefInfos)</span><br><span class="line">            &#123;</span><br><span class="line">                hrefInfo.boxes.Clear();</span><br><span class="line">                if (hrefInfo.startIndex &gt;= toFill.currentVertCount)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 将超链接里面的文本顶点索引坐标加入到包围框</span><br><span class="line">                toFill.PopulateUIVertex(ref vert, hrefInfo.startIndex);</span><br><span class="line">                var pos = vert.position;</span><br><span class="line">                var bounds = new Bounds(pos, Vector3.zero);</span><br><span class="line">                Vector3 previousPos = Vector3.zero;</span><br><span class="line">                for (int i = hrefInfo.startIndex, m = hrefInfo.endIndex; i &lt; m; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (i &gt;= toFill.currentVertCount)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    toFill.PopulateUIVertex(ref vert, i);</span><br><span class="line">                    pos = vert.position;</span><br><span class="line">                    if ((i - hrefInfo.startIndex) % 4 == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        previousPos = pos;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (previousPos != Vector3.zero &amp;&amp; (i - hrefInfo.startIndex) % 4 == 0 &amp;&amp; pos.x &lt; previousPos.x) // 换行重新添加包围框</span><br><span class="line">                    &#123;</span><br><span class="line">                        hrefInfo.boxes.Add(new Rect(bounds.min, bounds.size));</span><br><span class="line">                        bounds = new Bounds(pos, Vector3.zero);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        bounds.Encapsulate(pos); // 扩展包围框</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hrefInfo.boxes.Add(new Rect(bounds.min, bounds.size));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (this.gameObject.activeInHierarchy)</span><br><span class="line">            &#123;</span><br><span class="line">                StartCoroutine(RefrehLayout());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IEnumerator RefrehLayout()</span><br><span class="line">        &#123;</span><br><span class="line">            yield return new WaitForEndOfFrame();</span><br><span class="line">            LayoutRebuilder.ForceRebuildLayoutImmediate(Rect_Parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化超链接文本 获取最终结果的定点数用</span><br><span class="line">        string GetOutputText_Init(string outputText)</span><br><span class="line">        &#123;</span><br><span class="line">            s_TextBuilder.Length = 0;</span><br><span class="line">            m_HrefInfos.Clear();</span><br><span class="line">            var indexText = 0;</span><br><span class="line">            foreach (Match match in s_HrefRegex.Matches(outputText))</span><br><span class="line">            &#123;</span><br><span class="line">                s_TextBuilder.Append(outputText.Substring(indexText, match.Index - indexText));</span><br><span class="line">                s_TextBuilder.Append(match.Groups[2].Value);</span><br><span class="line">                indexText = match.Index + match.Length;</span><br><span class="line">            &#125;</span><br><span class="line">            s_TextBuilder.Append(outputText.Substring(indexText, outputText.Length - indexText));</span><br><span class="line">            return s_TextBuilder.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 获取超链接解析后的最后输出文本</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">        string GetOutputText(string outputText, int currentVertCount)</span><br><span class="line">        &#123;</span><br><span class="line">            s_TextBuilder.Length = 0;</span><br><span class="line">            m_HrefInfos.Clear();</span><br><span class="line">            var indexText = 0;</span><br><span class="line">            int vertCount = Regex.Replace(Regex.Replace(outputText.ToString(), @&quot;\s&quot;, &quot;&quot;), @&quot;&lt;(.*?)&gt;&quot;, &quot;&quot;).Length * 4;</span><br><span class="line">            int vercCount_Offset_Start = 0;</span><br><span class="line">            int vercCount_Offset_End = 0;</span><br><span class="line">            bool isLineCup = false;</span><br><span class="line">            if (currentVertCount &gt; vertCount)</span><br><span class="line">            &#123;</span><br><span class="line">                isLineCup = true;</span><br><span class="line">                vercCount_Offset_Start = 80;</span><br><span class="line">                vercCount_Offset_End = 88;</span><br><span class="line">            &#125;</span><br><span class="line">            foreach (Match match in s_HrefRegex.Matches(outputText))</span><br><span class="line">            &#123;</span><br><span class="line">                s_TextBuilder.Append(outputText.Substring(indexText, match.Index - indexText));</span><br><span class="line">                int offset_Len = 0;</span><br><span class="line">                if (isLineCup)</span><br><span class="line">                &#123;</span><br><span class="line">                    offset_Len = (s_TextBuilder.Length - Regex.Replace(s_TextBuilder.ToString(), @&quot;&lt;(.*?)&gt;&quot;, &quot;&quot;).Length) * 4;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                s_TextBuilder.Append(&quot;&lt;i&gt;&lt;b&gt;&lt;color=#f49037&gt;&quot;);  // 超链接颜色</span><br><span class="line"></span><br><span class="line">                var str = Regex.Replace(s_TextBuilder.ToString(), @&quot;\s&quot;, &quot;&quot;);</span><br><span class="line">                var group = match.Groups[1];</span><br><span class="line">                var hrefInfo = new HrefInfo_</span><br><span class="line">                &#123;</span><br><span class="line">                    startIndex = Regex.Replace(str, @&quot;&lt;(.*?)&gt;&quot;, &quot;&quot;).Length * 4 + vercCount_Offset_Start + offset_Len, // 超链接里的文本起始顶点索引</span><br><span class="line">                    endIndex = (Regex.Replace(str, @&quot;&lt;(.*?)&gt;&quot;, &quot;&quot;).Length +</span><br><span class="line">                        Regex.Replace(Regex.Replace(match.Groups[2].ToString(), @&quot;\s&quot;, &quot;&quot;)</span><br><span class="line">                            , @&quot;&lt;(.*?)&gt;&quot;, &quot;&quot;).Length - 1) * 4 + 3 + vercCount_Offset_End + offset_Len,</span><br><span class="line">                    name = group.Value</span><br><span class="line">                &#125;;</span><br><span class="line">                m_HrefInfos.Add(hrefInfo);</span><br><span class="line">                //Debug.Log($&quot;顶点信息，开始的：&#123;hrefInfo.startIndex&#125;，结束的：&#123;hrefInfo.endIndex&#125;&quot;);</span><br><span class="line"></span><br><span class="line">                s_TextBuilder.Append(match.Groups[2].Value);</span><br><span class="line">                s_TextBuilder.Append(&quot;&lt;/color&gt;&lt;/b&gt;&lt;/i&gt;&quot;);</span><br><span class="line">                indexText = match.Index + match.Length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s_TextBuilder.Append(outputText.Substring(indexText, outputText.Length - indexText));</span><br><span class="line">            return s_TextBuilder.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取祛除掉超链接 保留普通文本  保证配置里超链接标签的文本  在其他地方也可以正常使用，只有调用了超链接初始化的  才会给超链接形式的文本</span><br><span class="line">        string GetOutputText_Nomal(string outputText)</span><br><span class="line">        &#123;</span><br><span class="line">            s_TextBuilder.Length = 0;</span><br><span class="line">            m_HrefInfos.Clear();</span><br><span class="line">            var indexText = 0;</span><br><span class="line">            MatchCollection matchs = s_HrefRegex.Matches(outputText);</span><br><span class="line">            if (matchs.Count &lt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                return outputText;</span><br><span class="line">            &#125;</span><br><span class="line">            foreach (Match match in matchs)</span><br><span class="line">            &#123;</span><br><span class="line">                s_TextBuilder.Append(outputText.Substring(indexText, match.Index - indexText));</span><br><span class="line">                s_TextBuilder.Append(match.Groups[2].Value);</span><br><span class="line">                indexText = match.Index + match.Length;</span><br><span class="line">            &#125;</span><br><span class="line">            s_TextBuilder.Append(outputText.Substring(indexText, outputText.Length - indexText));</span><br><span class="line">            return s_TextBuilder.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void OnPointerClick(PointerEventData eventData)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector2 lp;</span><br><span class="line">            RectTransformUtility.ScreenPointToLocalPointInRectangle(</span><br><span class="line">                rectTransform, eventData.position, eventData.pressEventCamera, out lp);</span><br><span class="line"></span><br><span class="line">            foreach (var hrefInfo in m_HrefInfos)</span><br><span class="line">            &#123;</span><br><span class="line">                var boxes = hrefInfo.boxes;</span><br><span class="line">                for (var i = 0; i &lt; boxes.Count; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (boxes[i].Contains(lp))</span><br><span class="line">                    &#123;</span><br><span class="line">                        //Debug.Log(&quot;技能 超链接 点击了：&quot; + hrefInfo.name);</span><br><span class="line">                        linkFunc_Cb?.Invoke(hrefInfo.name);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 超链接信息类</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    class HrefInfo_</span><br><span class="line">    &#123;</span><br><span class="line">        public int startIndex;</span><br><span class="line"></span><br><span class="line">        public int endIndex;</span><br><span class="line"></span><br><span class="line">        public string name;</span><br><span class="line"></span><br><span class="line">        public readonly List&lt;Rect&gt; boxes = new List&lt;Rect&gt;();</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var terms2 = $&quot;&lt;color=#aa3900&gt;&lt;a herf=&#123;PrivacyPolicyDefine.UrlService&#125;&gt;&#123;ScriptLocalization.terms_of_use&#125;&lt;/a&gt;&lt;/color&gt;&quot;;</span><br><span class="line"></span><br><span class="line">var policy2 = $&quot;&lt;color=#aa3900&gt;&lt;a herf=&#123;PrivacyPolicyDefine.UrlPrivacy&#125;&gt;&#123;ScriptLocalization.privacy_policy&#125;&lt;/a&gt;&lt;/color&gt;&quot;;</span><br><span class="line"></span><br><span class="line">_ui.contentText.text = string.Format(ScriptLocalization.terms_policy_dlg_content, terms2, policy2);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;为什么会有&lt;code&gt;LayoutRebuilder.ForceRebuildLayoutImmediate(RectTransform)&lt;/code&gt;接口? 什么时候用这个接口?&lt;/h1&gt;
&lt;p&gt;我们在某一帧的Update或者EventInput中执行了一段代码, 这段</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityEditor功能开发</title>
    <link href="https://soincredible.github.io/posts/2e6b555f/"/>
    <id>https://soincredible.github.io/posts/2e6b555f/</id>
    <published>2025-04-18T22:22:15.000Z</published>
    <updated>2025-04-27T01:30:44.577Z</updated>
    
    <content type="html"><![CDATA[<h1>拓展UnityInspector窗口</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Reflection;</span><br><span class="line">using UnityEditor;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace DDZ</span><br><span class="line">&#123;</span><br><span class="line">    [CustomEditor(typeof(RectTransform))]</span><br><span class="line">    public class RectTransformEditor : Editor</span><br><span class="line">    &#123;</span><br><span class="line">        Color defutColor;</span><br><span class="line">        RectTransform rectTransform;</span><br><span class="line">        UIRuntimeComponents runtimeComponents;</span><br><span class="line">        Object[] components;</span><br><span class="line">        Editor rectTransformEditor;</span><br><span class="line">        static bool showCustom = true;</span><br><span class="line"></span><br><span class="line">        GUIContent toggleLabel = new GUIContent(&quot; 节点收集&quot;);</span><br><span class="line">        GUIStyle style = null;</span><br><span class="line">        </span><br><span class="line">        private void OnEnable()</span><br><span class="line">        &#123;</span><br><span class="line">            //反射获取ectTransformEditor</span><br><span class="line">            var type = Assembly.GetAssembly(typeof(Editor)).GetType(&quot;UnityEditor.RectTransformEditor&quot;, false);</span><br><span class="line">            if (type==null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            rectTransformEditor = CreateEditor(target, type);</span><br><span class="line"></span><br><span class="line">            rectTransform = (RectTransform) target;</span><br><span class="line">            if (rectTransform != null)</span><br><span class="line">            &#123;</span><br><span class="line">                defutColor = GUI.backgroundColor;</span><br><span class="line">                </span><br><span class="line">                //获取RuntimeComponents组件</span><br><span class="line">                runtimeComponents = FindUIRuntimeComponents(rectTransform.parent);</span><br><span class="line">            </span><br><span class="line">                //收集节点，添加GameObject，并且删除CanvasRenderer</span><br><span class="line">                components = rectTransform.GetComponents&lt;Component&gt;();</span><br><span class="line">                var list = components.ToList();</span><br><span class="line">                list.Add(rectTransform.gameObject);</span><br><span class="line">                int len = list.Count;</span><br><span class="line">                for (int i = len - 1; i &gt;= 0; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    var component = list[i];</span><br><span class="line">                    var typeStr = component.GetType().Name;</span><br><span class="line">                    if (typeStr == &quot;CanvasRenderer&quot;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        list.RemoveAt(i);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                components = list.ToArray();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void OnInspectorGUI()</span><br><span class="line">        &#123;</span><br><span class="line">            if (rectTransform == null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (rectTransformEditor)</span><br><span class="line">            &#123;</span><br><span class="line">                rectTransformEditor.OnInspectorGUI();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (runtimeComponents == null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line">            Rect xian1 = GUILayoutUtility.GetRect(GUIContent.none, GUIStyle.none, GUILayout.Height(1));</span><br><span class="line">            Rect backgroundRect = GUILayoutUtility.GetRect(GUIContent.none, GUIStyle.none, GUILayout.Height(20));</span><br><span class="line"></span><br><span class="line">            EditorGUI.DrawRect(xian1, Color.black);</span><br><span class="line">            EditorGUI.DrawRect(backgroundRect, new Color(0.25f, 0.25f, 0.25f));</span><br><span class="line"></span><br><span class="line">            // 绘制内容区域</span><br><span class="line">            if (style==null)</span><br><span class="line">            &#123;</span><br><span class="line">                style = new GUIStyle(EditorStyles.foldout);</span><br><span class="line">                style.fontStyle = FontStyle.Bold;</span><br><span class="line">            &#125;</span><br><span class="line">            Rect contentRect = new Rect(backgroundRect.x-15 , backgroundRect.y, backgroundRect.width+20, backgroundRect.height);</span><br><span class="line">            showCustom = GUI.Toggle(contentRect, showCustom, toggleLabel,style);</span><br><span class="line"></span><br><span class="line">            if (showCustom)</span><br><span class="line">            &#123;</span><br><span class="line">                int len = components.Length;</span><br><span class="line">                for (int i = 0; i &lt; len; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    var component = components[i];</span><br><span class="line">                    var typeStr = component.GetType().Name;</span><br><span class="line">                    if (IsCollected(runtimeComponents, component))</span><br><span class="line">                    &#123;</span><br><span class="line">                        GUI.backgroundColor = Color.green;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        GUI.backgroundColor = defutColor;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (i % 3 == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        GUILayout.BeginHorizontal();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (i == len - 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (GUILayout.Button(typeStr, GUILayout.Width(100), GUILayout.Height(30)))</span><br><span class="line">                        &#123;</span><br><span class="line">                            OperateComponent(component);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (GUILayout.Button(typeStr, GUILayout.Height(30)))</span><br><span class="line">                        &#123;</span><br><span class="line">                            OperateComponent(component);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (i % 3 == 2 || i == len - 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        GUILayout.EndHorizontal();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                EditorGUI.indentLevel--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void OnDisable()</span><br><span class="line">        &#123;</span><br><span class="line">            if (rectTransformEditor)</span><br><span class="line">            &#123;</span><br><span class="line">                DestroyImmediate(rectTransformEditor);</span><br><span class="line">                rectTransform = null;</span><br><span class="line">                runtimeComponents = null;</span><br><span class="line">                components = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void OperateComponent(Object component)</span><br><span class="line">        &#123;</span><br><span class="line">            if (Event.current.button == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!Application.isPlaying)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (IsCollected(runtimeComponents, component))</span><br><span class="line">                    &#123;</span><br><span class="line">                        DeleteObject(runtimeComponents, component);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        AddObject(runtimeComponents, component);</span><br><span class="line">                    &#125;</span><br><span class="line">                            </span><br><span class="line">                    EditorApplication.ExecuteMenuItem(&quot;Window/General/Hierarchy&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (Event.current.button == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                if (IsCollected(runtimeComponents, component))</span><br><span class="line">                &#123;</span><br><span class="line">                    FindReferences(runtimeComponents, component);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bool IsCollected(UIRuntimeComponents runtimeComponents, Object component)</span><br><span class="line">        &#123;</span><br><span class="line">            if (runtimeComponents.m_objects==null)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            int len = runtimeComponents.m_objects.Length;</span><br><span class="line">            for (int i = 0; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (runtimeComponents.m_objects[i] == component)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void AddObject(UIRuntimeComponents runtimeComponents, Object component)</span><br><span class="line">        &#123;</span><br><span class="line">            if (runtimeComponents.m_objects==null)</span><br><span class="line">            &#123;</span><br><span class="line">                runtimeComponents.m_objects = new Object[0];</span><br><span class="line">            &#125;</span><br><span class="line">            int len = runtimeComponents.m_objects.Length;</span><br><span class="line">            for (int i = 0; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (runtimeComponents.m_objects[i] == component)</span><br><span class="line">                &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            var list = runtimeComponents.m_objects.ToList();</span><br><span class="line">            list.Add(component);</span><br><span class="line">            runtimeComponents.m_objects = list.ToArray();</span><br><span class="line">            SavePrefab(runtimeComponents);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void DeleteObject(UIRuntimeComponents runtimeComponents, Object component)</span><br><span class="line">        &#123;</span><br><span class="line">            var list = runtimeComponents.m_objects.ToList();</span><br><span class="line">            int len = list.Count;</span><br><span class="line">            for (int i = 0; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (list[i] == component)</span><br><span class="line">                &#123;</span><br><span class="line">                    list.RemoveAt(i);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            runtimeComponents.m_objects = list.ToArray();</span><br><span class="line">            if (runtimeComponents.m_objects.Length&lt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                runtimeComponents.m_objects = null;</span><br><span class="line">            &#125;</span><br><span class="line">            SavePrefab(runtimeComponents);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void FindReferences(UIRuntimeComponents runtimeComponents, Object component)</span><br><span class="line">        &#123;</span><br><span class="line">            EditorGUIUtility.PingObject(runtimeComponents.gameObject);</span><br><span class="line">            Selection.objects = new Object[] &#123;runtimeComponents.gameObject&#125;;</span><br><span class="line"></span><br><span class="line">            var len = runtimeComponents.m_objects.Length;</span><br><span class="line">            for (int i = 0; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (component == runtimeComponents.m_objects[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    runtimeComponents.focusIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UIRuntimeComponents FindUIRuntimeComponents(Transform transform)</span><br><span class="line">        &#123;</span><br><span class="line">            if (transform == null)</span><br><span class="line">                return null;</span><br><span class="line"></span><br><span class="line">            var runtimeComponents = transform.GetComponent&lt;UIRuntimeComponents&gt;();</span><br><span class="line">            if (runtimeComponents != null)</span><br><span class="line">                return runtimeComponents;</span><br><span class="line"></span><br><span class="line">            return FindUIRuntimeComponents(transform.parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void SavePrefab(UIRuntimeComponents runtime)</span><br><span class="line">        &#123;</span><br><span class="line">            if (runtime == null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GameObject save_go = runtime.gameObject;</span><br><span class="line">            var assetType = PrefabUtility.GetPrefabAssetType(runtime.gameObject);</span><br><span class="line">            if (assetType == PrefabAssetType.Regular) //如果是预制体的一部分</span><br><span class="line">            &#123;</span><br><span class="line">                save_go = PrefabUtility.GetOutermostPrefabInstanceRoot(runtime.gameObject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (EditorUtility.IsPersistent(save_go))</span><br><span class="line">            &#123;</span><br><span class="line">                EditorUtility.SetDirty(save_go);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                string path =</span><br><span class="line">                    AssetDatabase.GetAssetPath(PrefabUtility.GetCorrespondingObjectFromOriginalSource(save_go));</span><br><span class="line">                if (string.IsNullOrEmpty(path))</span><br><span class="line">                &#123;</span><br><span class="line">                    EditorUtility.SetDirty(save_go);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    PrefabUtility.SaveAsPrefabAssetAndConnect(save_go, path, InteractionMode.UserAction);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>UnityEditor下的加载弹窗或者弹窗</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static void ShowProgress(float progress, int total, int current)</span><br><span class="line">&#123;</span><br><span class="line">    EditorUtility.DisplayProgressBar(&quot;Searching&quot;,</span><br><span class="line">        string.Format(&quot;Checking (&#123;0&#125;/&#123;1&#125;), please wait...&quot;, current, total), progress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EditorUtility.DisplayDialog( &quot;&quot;, &quot;Board64中不存在对Board100的依赖&quot;, &quot;OK&quot; );</span><br></pre></td></tr></table></figure><h1>资源导入管线处理</h1><h1>参考资料</h1><ul><li><a href="https://blog.csdn.net/yx314636922/article/details/126872839">https://blog.csdn.net/yx314636922/article/details/126872839</a></li><li><a href="https://blog.csdn.net/angry_youth/article/details/117469722">https://blog.csdn.net/angry_youth/article/details/117469722</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;拓展UnityInspector窗口&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>乌合之众</title>
    <link href="https://soincredible.github.io/posts/2ecb1e55/"/>
    <id>https://soincredible.github.io/posts/2ecb1e55/</id>
    <published>2025-04-09T12:00:31.000Z</published>
    <updated>2025-04-27T01:30:44.578Z</updated>
    
    <content type="html"><![CDATA[<h1>序</h1><p>我发现，社会组织就像人体结构一样复杂，我们完全无法让它们突然经受深刻的变化。大自然有时是非常极端的，但决不像我们所理解的那样。所以，对一个民族来说，迷恋大变革是最可怕的事情之一。不管这种变革在理论上显得如何伟大，只有当它能立即改变民族的深层心理时，它才是有用的。然而，只有时间拥有这种力量。支配人类的，是思想、感情和习俗，是存在于我们自身的东西。制度和法律是人们内心精神的表现形式，反映了它的需要，既然是人们的内心精神诞生了制度和法律，制度和法律自然就无法改变它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;序&lt;/h1&gt;
&lt;p&gt;我发现，社会组织就像人体结构一样复杂，我们完全无法让它们突然经受深刻的变化。大自然有时是非常极端的，但决不像我们所理解的那样。所以，对一个民族来说，迷恋大变革是最可怕的事情之一。不管这种变革在理论上显得如何伟大，只有当它能立即改变民族的深层心理时，它才</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ET中的网络通信模块</title>
    <link href="https://soincredible.github.io/posts/3613bb98/"/>
    <id>https://soincredible.github.io/posts/3613bb98/</id>
    <published>2025-04-02T10:14:58.000Z</published>
    <updated>2025-04-29T08:14:40.410Z</updated>
    
    <content type="html"><![CDATA[<p>Realm Session<br>Router Session<br>Gate Session</p><p>通过Root节点上的RouterAddressComponent组件可以获得服务器的地址, 并将这个地址给到Session</p><p><a href="https://blog.csdn.net/u011041241/article/details/109574509">内网和外网之间的通信（端口映射原理）</a><br><a href="https://luyuhuang.tech/2020/12/09/kcp.html">KCP协议详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Realm Session&lt;br&gt;
Router Session&lt;br&gt;
Gate Session&lt;/p&gt;
&lt;p&gt;通过Root节点上的RouterAddressComponent组件可以获得服务器的地址, 并将这个地址给到Session&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ET框架自动生成脚本</title>
    <link href="https://soincredible.github.io/posts/ef16867e/"/>
    <id>https://soincredible.github.io/posts/ef16867e/</id>
    <published>2025-03-28T11:09:03.000Z</published>
    <updated>2025-04-17T05:42:38.016Z</updated>
    
    <content type="html"><![CDATA[<p>ET框架仓库下其实是有两个工程的，虽然这两个工程里面的脚本有可能是用的同一份</p><p>在Share这个模块中<code>ETSystemGenerator.cs</code>这个脚本里面！</p><blockquote><p>问题 这些代码自动生成的时机是什么时候？</p></blockquote><p>编译的时候自动生成，无需开发者手动管理ETSystemGenerator这个类实现了ISourceGenerator接口，但是需要注意的是，在Unity中自动生成脚本的功能是是通过dll插件的方式接入进来的，还得看一下怎么导出dll，如果对SourceGenerator的源码有修改，需要重新导入dll到Unity中</p><h1>GeneratorExecutionContext</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ET框架仓库下其实是有两个工程的，虽然这两个工程里面的脚本有可能是用的同一份&lt;/p&gt;
&lt;p&gt;在Share这个模块中&lt;code&gt;ETSystemGenerator.cs&lt;/code&gt;这个脚本里面！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题 这些代码自动生成的时机是什么时候</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ET框架索引</title>
    <link href="https://soincredible.github.io/posts/ff09e316/"/>
    <id>https://soincredible.github.io/posts/ff09e316/</id>
    <published>2025-03-28T06:37:27.000Z</published>
    <updated>2025-04-28T01:34:28.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>💡TIPS:本系列基于ET8.1版本</p></blockquote><p>本系列内容会十分繁杂, 因为不只是讨论ET的架构设计, 还有支持框架实现背后的技术: C#中的特性、反射、异步、代码检查、源代码生成、帧同步状态同步、网络通信、KCP、AOI等多个方面, 也只有具备了这些知识储备, 才能够更好的理解ET框架.</p><ul><li><a href="https://soincredible.github.io/posts/a8cdc42b/">ET中的异步</a></li><li><a href="https://soincredible.github.io/posts/50d23509/">帧同步与状态同步</a></li><li><a href="https://soincredible.github.io/posts/3613bb98/">ET中的网络通信模块</a></li><li><a href="https://soincredible.github.io/posts/12f854cb/">ET中的Singleton</a></li><li><a href="https://soincredible.github.io/posts/cd96d12/">ET中反射与特性的使用</a></li><li><a href="https://soincredible.github.io/posts/ef16867e/">ET框架自动生成脚本</a></li><li><a href="https://soincredible.github.io/posts/9c5dbe31/">ET框架Demo启动流程梳理</a></li></ul><p>ET中的SceneType, 可以这样理解: 一个由ET框架开发的游戏就是一个World, 在这个world下会有各种个样的Scene, 这些Scene扮演不同的角色, 这些角色扮演一般都是不同的职责. 在ET中,有一个名叫Demo的SceneType, 还有叫Main的</p><p>由World提供各种原材料, 供各个Scene下面的Entity使用</p><p>每一个Entity都会标记自己被创建出来的Scene<br>SceneType会影响Fiber的创建</p><p>ET中的Entity 有Child和Component之分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;💡TIPS:本系列基于ET8.1版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本系列内容会十分繁杂, 因为不只是讨论ET的架构设计, 还有支持框架实现背后的技术: C#中的特性、反射、异步、代码检查、源代码生成、帧同步状态同步、网络通信、KCP</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ET框架中的Singleton</title>
    <link href="https://soincredible.github.io/posts/12f854cb/"/>
    <id>https://soincredible.github.io/posts/12f854cb/</id>
    <published>2025-03-28T06:23:01.000Z</published>
    <updated>2025-04-21T10:33:11.365Z</updated>
    
    <content type="html"><![CDATA[<p>本文笔者会按照ET中所有Singleton创建的顺利，尝试梳理一下设计到的模块。</p><h1>Singleton的创建</h1><blockquote><p>疑问 已经有一个ASingleton了，为什么还要有一个ASingletonAwake？<br>所有的Singleton都会继承ASingleton基类。但是不同的Singleton还会继承不同的ISingletonAwake。 一是使用泛型，二是声明几个参数数量不同的ISingletonAwake接口，开发者可以根据需求选择具体的Singleton继承哪个接口，但是所有的Singleton又都会继承ASingleton被Word中的singletons管理起来，相当于把Singleton的初始化和管理的职能拆分交给了两个角色去处理，还是比较巧妙的。</p></blockquote><blockquote><p>疑问 为什么有的Singleton会被打上Code特性，有的不会？</p></blockquote><p>虽然大家都是Singleton，但是各个Singleton之间的优先级不一定一样，单例之间会存在依赖。比如CodeLoader、CodeTypes这两个单例，它们两个需要在其他单例之前先被Awake，然后在CodeType单例内部，再去创建出其他单例出来。因此，如果有一个单例没有被标记为Code特性，那么说明这个单例是一个优先级比较高的单例，它应该在某一比较早的时刻被我们开发者手动调用并创建出来。也就是ET框架通过给不给单例标记CodeAttribute的方式来对单例的创建进行手动或者自动的管理。</p><h1>World</h1><p>接着我们来说一下World中的AddSingleton接口，这个接口不仅仅是被World内部的几个泛型AddSingleton接口调用，还被下面几个地方调用了：</p><ul><li>CodeTypes</li><li>ConfigLoader</li><li>EditorLogHelper</li></ul><h1>CodeTypes</h1><h1>ConfigLoader</h1><h1>EditorLogHelper</h1><h1>AddSingleton的顺序</h1><ul><li>Logger</li><li>TimeInfo</li><li>FiberManager</li><li>ResourcesComponent</li><li>CodeLoader</li><li>接着调用CodeLoader的Start方法创建CodeTypes单例</li><li>接着通过反射的方式调用Entry中的Start方法创建下面单例：<ul><li>IdGenerater</li><li>OpcodeType</li><li>ObjectPool</li><li>MessageQueue</li><li>NetServices</li><li>NavmeshComponent</li><li>LogMsg</li><li>然后调用CodeTypes单例的CreateCode方法，该方法拿到所有被标记了CodeAttribute的类，自动的创建这些类的单例：<ul><li>EntitySystemSingleton</li><li>MessageDispatcher</li><li>EventSystem</li><li>HttpDispatcher</li><li>LSEntitySystemSingleton</li><li>AIDispatcherComponent</li><li>ConsoleDispatcher</li><li>MessageSessionDispatcher</li><li>NumericWatcherComponent</li><li>UIEventComponent</li></ul></li><li>ConfigLoader</li></ul></li></ul><h1>CodeTypes</h1><h1>EventSystem</h1><p>EventSystem是所有业务能够跑起来的基础</p><p>通过继承InvokeHandler, 在Handle方法里会操作其他单例或者component里面面的接口</p><ul><li>MessageSessionHandler MessageSessionDispatcher</li><li>MessageLocationHandler MessageDispatcherSingleton</li><li></li></ul><p>EventSystem中维护了两个字段<code>allEvents</code>和<code>allInvokers</code><br>EventSystem在Invoke的时候会初始化这两个字段的内容<br>allEvents字段中 记为Event特性的所有类型，创建这些类型的实例，被标记了Event特性的类必须要继承IEvent接口。</p><p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo.getcustomattributes?view=net-9.0"><code>MemberInfo.GetCustomAttributes(Type, bool);</code></a>。</p><p>看一下AEvent中提供了一个Run接口，</p><p>InvokeHandler和MessageHandler的区别是什么</p><p>Event和Invoker的区别是什么</p><h1>MessageHandler 感觉是另外一套逻辑</h1><h1>EntitySystemSingleton</h1><h2 id="EntitySystem">EntitySystem</h2><p>EntitySystemSingleton里面维护了一个TypeSystems字段</p><p>AwakeSystem和Component的IAwake接口之间的关系.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文笔者会按照ET中所有Singleton创建的顺利，尝试梳理一下设计到的模块。&lt;/p&gt;
&lt;h1&gt;Singleton的创建&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;疑问 已经有一个ASingleton了，为什么还要有一个ASingletonAwake？&lt;br&gt;
所有的Si</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>了不起的盖茨比</title>
    <link href="https://soincredible.github.io/posts/3941b47a/"/>
    <id>https://soincredible.github.io/posts/3941b47a/</id>
    <published>2025-03-27T12:42:13.000Z</published>
    <updated>2025-04-17T05:42:38.183Z</updated>
    
    <content type="html"><![CDATA[<p>“我们要明白，讲交情要在人活着的时候讲，人死就没有交情了，”他意味深长地说，“我自己的原则是，人死我就什么都不管了。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“我们要明白，讲交情要在人活着的时候讲，人死就没有交情了，”他意味深长地说，“我自己的原则是，人死我就什么都不管了。”&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>帧同步与状态同步</title>
    <link href="https://soincredible.github.io/posts/50d23509/"/>
    <id>https://soincredible.github.io/posts/50d23509/</id>
    <published>2025-03-26T23:52:43.000Z</published>
    <updated>2025-04-27T01:30:44.578Z</updated>
    
    <content type="html"><![CDATA[<h1>ECS架构</h1><p>ECS架构看起来就是这样子的。先有个World，它是系统（译注，这里的系统指的是ECS中的S，不是一般意义上的系统，为了方便阅读，下文统称System）和实体(Entity)的集合。而实体就是一个ID，这个ID对应了组件(Component)的集合。组件用来存储游戏状态并且没有任何的行为(Behavior)。System有行为但是没有状态。</p><p>数据和逻辑分离, Component中只有数据, System中只有逻辑, 首先有一个World, 管理着所有的Entity是Component的容器. 还有一个EntityAdmin来管理所有的Entity</p><p>游戏中不同的角色,看待同一个Entity下同一个Component时的视角是不一样的,角色希望这个Component能做什么,那么这个Component就真的可以做什么, Component自己能做什么不是它自己决定的, 而是由其观察者决定的. 但是这些观察者应当只是从Component中读状态, 而不会修改Component中的状态, Component中的状态需要有专门对应的System进行修改.** 结果看来，根据主体视角区分所有Behavior，这样来描述一棵树的全部行为会更容易，这个道理同样也适用于游戏对象(game objects)。**</p><h1>同步相关</h1><p>服务器上会构建一个纯数据向的World,所有Player的操作都会上报给服务器,不过由于客户端和服务器端的通信存在延迟,因此客户端会现在本地进行模拟,同时将操作上报给服务器并等待结果返回,如果服务器返回回来的数据和客户端模拟的结果是一致的,那么就可以继续下去,否则客户端就要会回退状态 然后客户端进行时间膨胀.</p><h1>参考资料</h1><ul><li><a href="https://www.bilibili.com/video/BV1RR4y1V7T2?spm_id_from=333.788.videopod.sections&amp;vd_source=83f4165825ce9df46cf4fd576ccb1102">烟雨的视频教程</a></li><li><a href="https://www.youtube.com/watch?v=W3aieHjyNvw&amp;t=2886s">守望先锋GDC讲座——架构设计和网络同步</a></li><li><a href="https://www.youtube.com/watch?v=W4oZq4tn57w">守望先锋GDC回放系统、全场最佳</a></li><li><a href="https://mp.weixin.qq.com/s/y8-Xb0az43pmjTlBXtNhdA">https://mp.weixin.qq.com/s/y8-Xb0az43pmjTlBXtNhdA</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;ECS架构&lt;/h1&gt;
&lt;p&gt;ECS架构看起来就是这样子的。先有个World，它是系统（译注，这里的系统指的是ECS中的S，不是一般意义上的系统，为了方便阅读，下文统称System）和实体(Entity)的集合。而实体就是一个ID，这个ID对应了组件(Component)的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ET中的异步</title>
    <link href="https://soincredible.github.io/posts/a8cdc42b/"/>
    <id>https://soincredible.github.io/posts/a8cdc42b/</id>
    <published>2025-03-25T08:21:26.000Z</published>
    <updated>2025-05-08T03:05:56.332Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客不止讨论ETTask如何实现, 更想探讨C#底层是如何支持异步实现的. 如果读者像笔者一样, 通过Unity接触到的C#语言, 可能对协程和异步概念的理解上有偏差, <strong>因为我们在Unity中使用的协程并不是操作系统层次下讨论的与线程、进程、协程中的协程概念</strong>, Unity的协程是Unity基于IEnumerator和Unity事件更新框架实现的伪协程、伪异步, Unity的协程限制非常多, 如果读者对Unity的协程、IEnumerator和<code>yield return</code>语法糖有疑惑, 欢迎参考<a href="https://soincredible.github.io/posts/133a9667/">这篇博客</a>, 希望能帮助你理解.</p><p>本篇博客首先会讨论C#中异步的实现思路, 然后会讨论ETTask的实现思路</p><p>另外, 如果读者对C#中的异步不是很了解, 推荐先看一下下面四篇翻译的文章:<br><a href="">Dissecting the async methods in C#</a><br><a href="">Extending the async methods in C#</a><br><a href="">The performance characteristics of the async methods in C#</a><br><a href="">One user scenario to rule them all</a></p><p>请思考这句话: Task是Task, Async是Async. 有Task并不一定意味着异步操作, 有Async也并不意味着一定有异步操作. 也就是说, 并不是只有在异步的场景下我们才可以使用Task, Task依然可以在同步场景下使用, 而<code>async</code>关键字也不能完全和异步绑定, 因为<code>async</code>关键字的作用只是告诉编译器对这个方法做一些特殊的处理: 每一个被标记为async的方法, Compiler在背后都会在其内部生成一个状态机.</p><h1>一个类是如何变得可以被await的？</h1><p>在Sergey的<a href="https://devblogs.microsoft.com/premier-developer/extending-the-async-methods-in-c/">这篇博客</a>中提到, 如果要让一个类变得&quot;awaitable&quot;, 这个类就必须遵循一些模式:</p><ul><li>编译器要能够找到一个实例或者一个扩展方法叫做<code>GetAwaiter</code>. 这个方法的返回类型需要遵守某些要求:</li><li>这个返回类型需要实现<code>INoifyCompletion</code>接口</li><li>这个返回类型需要有<code>bool IsCompleted&#123; get; &#125;</code>属性和<code>T GetResult()</code>方法</li></ul><h1>关于异步和多线程的讨论</h1><p>异步是异步, 多线程是多线程</p><p>多线程是真线程概念范围内的议题, 而异步的议题不止包含线程, 还包含网络请求、文件读取等和物理硬件相关的范畴</p><p>因为网络请求和文件读取等与物理硬件交互的过程并不占用线程, 因此在进行类似操作的时候, 线程上是可以执行别的任务的. 这种情况是异步</p><p>在多线程的范畴里, 由于多个任务确实就是并行地执行的, 我们也将其看成了异步</p><p>但是要注意的是, 我们Unity开发者调用Unity底层API的时候, 就拿网络请求和加载资源来说, Unity都会给我们提供两种类型的接口, 一种是异步, 一种是同步. 这两种接口都是I/O密集型操作, 因为Unity是单线程嘛. 如果你常常陷入纠结网络和资源加载的内部实现是怎样的 不利于你了解异步的本质,</p><p>所以妄图使用协程来做一些CPU密集型的工作是根本不可能的, 因为协程本质上还是运行在一个进程上, 协程反而适合那些I/O密集型的操作, 因为这类操作并不真的会占用CPU的执行时间, 这段时间的CPU只是在空转而已, 或者我们希望使用协程达成一种延时的效果</p><p>yield和await都能实现异步, 区别是什么?</p><p>而多线程我们往往会用多线程来做一些CPU密集型的任务, 我们会决定这些任务的具体实现, 或许会让你更好理解</p><p>我们看一下 这个例子</p><p>ThreadSynchronizationContext的作用?</p><h1>C#中要实现异步需要哪些角色</h1><p>YooAsset、ETTask、UniTask三者异步的实现方式的区别是什么？</p><h1>SynchronizationContext</h1><p>SynchronizationContext中存储了一些能够标识线程身份的信息，现在你有一个方法，你可以通过<code>SynchronizationContext.Send()</code>或者<code>SynchronizationContext.Post</code>方法把你要执行的这个方法丢给你想要让他执行的线程里面去，可以把他理解为是一种跨线程的方法调用的方式。<br>在一般单线程里，方法的调用都是直来直去，而在多线程里面，可以通过SynchronizationContext来实现线程间的函数调用。<br>要注意一下Send和Post的区别，如果使用Send的方式把一个方法丢给某一个上下文，如果这个方法恰好很耗时，那么就会卡住调用Send处之后代码的执行，而如果使用Post方法的话，则不会阻塞调用处之后代码的执行。根据需求选择用Send还是Post。示例如下👇👇</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace Learn</span><br><span class="line">&#123;</span><br><span class="line">    public class LearnSynchronizationContext : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        // SynchronizationContext的理解和使用</span><br><span class="line">        private SynchronizationContext _synchronizationContext;</span><br><span class="line"></span><br><span class="line">        private Thread _thread; // 新建一个线程 让上下文指向这个线程</span><br><span class="line">        </span><br><span class="line">        public void Start()</span><br><span class="line">        &#123;</span><br><span class="line">            // 不能把这个上下文设置成主线程 因为下面的测试代码中要在该上下文线程里面执行while循环</span><br><span class="line">            // 会卡住主线程</span><br><span class="line">            // _synchronizationContext = SynchronizationContext.Current;</span><br><span class="line">            this._synchronizationContext = new SynchronizationContext();</span><br><span class="line">            </span><br><span class="line">            // _thread = new Thread(() =&gt;</span><br><span class="line">            // &#123;</span><br><span class="line">            //     this._synchronizationContext.Post(async (obj) =&gt;</span><br><span class="line">            //     &#123;</span><br><span class="line">            //         // 让这个方法执行的久一点</span><br><span class="line">            //         // 向上下文中抛出一个方法   </span><br><span class="line">            //         // 执行某个方法， 这个方法要比较耗时一点 才能看出Send和Post的差距</span><br><span class="line">            //         await Task.Delay(1000);</span><br><span class="line">            //</span><br><span class="line">            //         var str = obj as STR;</span><br><span class="line">            //         str.number = 20000;</span><br><span class="line">            //         var threadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">            //         Debug.Log(&quot;执行上下文Send/Post方法的线程ID是: &quot; + threadId);</span><br><span class="line">            //     &#125;, str);</span><br><span class="line">            //     </span><br><span class="line">            //     Debug.Log(&quot;str字段中的number是&quot; + str.number);</span><br><span class="line">            //     var threadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">            //     Debug.Log(&quot;执行线程方法的线程ID是&quot; + threadId);</span><br><span class="line">            //     Debug.Log(&quot;我是调用上下文Send/Post方法之后执行的语句&quot;);</span><br><span class="line">            // &#125;);</span><br><span class="line"></span><br><span class="line">            // --------------------------------------------------</span><br><span class="line">            // Send</span><br><span class="line">            // --------------------------------------------------</span><br><span class="line">            </span><br><span class="line">            _thread = new Thread(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                this._synchronizationContext.Send((obj) =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    // 让这个方法执行的久一点</span><br><span class="line">                    // 向上下文中抛出一个方法   </span><br><span class="line">                    // 执行某个方法， 这个方法要比较耗时一点 才能看出Send和Post的差距</span><br><span class="line">                    while (true)</span><br><span class="line">                    &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, null);</span><br><span class="line">                </span><br><span class="line">                var threadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">                Debug.Log(&quot;执行线程方法的线程ID是&quot; + threadId);</span><br><span class="line">                Debug.Log(&quot;我是调用上下文Send/Post方法之后执行的语句&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            // --------------------------------------------------</span><br><span class="line">            // Post</span><br><span class="line">            // --------------------------------------------------</span><br><span class="line">            </span><br><span class="line">            // _thread = new Thread(() =&gt;</span><br><span class="line">            // &#123;</span><br><span class="line">            //     this._synchronizationContext.Post((obj) =&gt;</span><br><span class="line">            //     &#123;</span><br><span class="line">            //         // 让这个方法执行的久一点</span><br><span class="line">            //         // 向上下文中抛出一个方法   </span><br><span class="line">            //         // 执行某个方法， 这个方法要比较耗时一点 才能看出Send和Post的差距</span><br><span class="line">            //         while (true)</span><br><span class="line">            //         &#123;</span><br><span class="line">            //             </span><br><span class="line">            //         &#125;</span><br><span class="line">            //     &#125;, str);</span><br><span class="line">            //     </span><br><span class="line">            //     Debug.Log(&quot;str字段中的number是&quot; + str.number);</span><br><span class="line">            //     var threadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">            //     Debug.Log(&quot;执行线程方法的线程ID是&quot; + threadId);</span><br><span class="line">            //     Debug.Log(&quot;我是调用上下文Send/Post方法之后执行的语句&quot;);</span><br><span class="line">            // &#125;);</span><br><span class="line">            </span><br><span class="line">            // 开始执行这个线程 </span><br><span class="line">            this._thread.Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C# 中几种异步的返回类型</h1><p>C#中有三种比较常用的返回类型: void、Task<TResult>和Task</p><h1>TaskCompletionSource是什么？</h1><p>按照笔者的理解，TaskCompletionSource可以将一个基于回调的异步操作转换成一个可以被await的异步操作。</p><p>抛开ET的一个例子，比如协程 协程是不可以被await的</p><h1>ICriticalNotifyCompletion</h1><h2 id="参考文档">参考文档</h2><ul><li><a href="https://blog.csdn.net/q__y__L/article/details/133905192">https://blog.csdn.net/q__y__L/article/details/133905192</a></li><li><a href="https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c/">https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c/</a></li><li><a href="https://devblogs.microsoft.com/premier-developer/extending-the-async-methods-in-c/">https://devblogs.microsoft.com/premier-developer/extending-the-async-methods-in-c/</a></li><li><a href="https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/">https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/</a></li><li><a href="https://devblogs.microsoft.com/premier-developer//one-user-scenario-to-rule-them-all/">https://devblogs.microsoft.com/premier-developer//one-user-scenario-to-rule-them-all/</a></li><li><a href="https://www.cnblogs.com/liqingwen/p/6218994.html?tdsourcetag=s_pcqq_aiomsg">https://www.cnblogs.com/liqingwen/p/6218994.html?tdsourcetag=s_pcqq_aiomsg</a></li><li><a href="https://www.cnblogs.com/wwkk/p/17814057.html">https://www.cnblogs.com/wwkk/p/17814057.html</a></li><li><a href="https://blog.csdn.net/shizuguilai/article/details/121236777">https://blog.csdn.net/shizuguilai/article/details/121236777</a></li><li><a href="https://www.cnblogs.com/peterYong/p/16328187.html">https://www.cnblogs.com/peterYong/p/16328187.html</a></li><li><a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext">https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext</a></li><li><a href="https://www.cnblogs.com/eventhorizon/p/15316955.html#4991898">https://www.cnblogs.com/eventhorizon/p/15316955.html#4991898</a></li><li><a href="https://www.cnblogs.com/eventhorizon/p/15824541.html">https://www.cnblogs.com/eventhorizon/p/15824541.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇博客不止讨论ETTask如何实现, 更想探讨C#底层是如何支持异步实现的. 如果读者像笔者一样, 通过Unity接触到的C#语言, 可能对协程和异步概念的理解上有偏差, &lt;strong&gt;因为我们在Unity中使用的协程并不是操作系统层次下讨论的与线程、进程、协程中的协程</summary>
      
    
    
    
    <category term="ET" scheme="https://soincredible.github.io/categories/ET/"/>
    
    
    <category term="ET" scheme="https://soincredible.github.io/tags/ET/"/>
    
  </entry>
  
  <entry>
    <title>UniTask</title>
    <link href="https://soincredible.github.io/posts/9955c97f/"/>
    <id>https://soincredible.github.io/posts/9955c97f/</id>
    <published>2025-03-20T14:03:33.000Z</published>
    <updated>2025-04-17T05:42:38.062Z</updated>
    
    <content type="html"><![CDATA[<p>（摘抄自CLR Via C#）异步函数存在以下限制：</p><ul><li><p>不能将应用程序的Main方法转变成异步函数。另外构造器、属性访问器方法和事件访问器方法不能转变成异步函数</p></li><li><p>异步函数不能使用任何out或者ref参数</p></li><li><p>不能在catch，finally或unsafe块中使用await操作符（注意在try中可以使用await，笔者记得UniTask的文档中说过是可以在try catch中使用UniTask并被捕获的，是因为UniTask实现了自己的<code>AsyncMethodBuilderAttribute</code>吗？ 记得看一下）。</p></li><li><p>不能在await操作符之前获得一个支持线程所有权或递归的锁，并在await操作符之后释放它。这是因为await之前的代码由一个线程执行，之后的代码则可能由另一个线程执行。（使用了await就一定会涉及到多线程吗？那UniTask是怎么保证它使用await的时候是在同一个线程内？）在C#的lock语句中使用await，编译器会报错。如果显式调用Monitor的Enter和Exit方法，那么代码虽然可以编译，但Monitor.Exit会在运行时抛出一个SynchronizationLockException。</p></li><li><p>在查询表达式中，await操作符只能在初始from子句的第一个集合表达式中使用，或者在join子句的集合表达式中使用。</p></li><li><p>关于（使用了await就一定会涉及到多线程吗？那UniTask是怎么保证它使用await的时候是在同一个线程内？）GPT的回复：<br>是的，如果你使用的是Unity专用的异步API（如UnityWebRequest），await这些API的操作通常会在主线程上执行。<br>如果开发者显式创建Task或Thread并await这些任务，这些任务可能在非主线程上执行，但await后续的代码依然会回到主线程上执行。<br>因此，理解上可以简化为：只要不是开发者主动使用多线程机制，一般所有的await操作都会确保在主线程上安全地执行后续操作。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（摘抄自CLR Via C#）异步函数存在以下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不能将应用程序的Main方法转变成异步函数。另外构造器、属性访问器方法和事件访问器方法不能转变成异步函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步函数不能使用任何out或者ref参数&lt;/</summary>
      
    
    
    
    
  </entry>
  
</feed>
